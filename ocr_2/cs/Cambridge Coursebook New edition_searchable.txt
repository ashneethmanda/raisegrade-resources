               CAMBRIDGE
                UNIVERSITY PRESS




 Computer Science
for Cambridge International AS & A Level

                COURSEBOOK

          Sylvia Langfield & Dave Duddell
CAMBRIDGE
UNIVERSITY PRESS


University Printing House, Cambridge CB2 8BS, United Kingdom

One Liberty Plaza, 20th Floor, New York, NY 10006, USA

477 Williamstown Road, Port Melbourne, VIC 3207, Australia

314-321, 3rd Floor, Plot 3, Splendor Forum, Jasola District Centre,
New Delhi - 110025, India

79 Anson Road, #06 -04/06, Singapore 079906


Cambridge University Press is part of the University of Cambridge.

It furthers the University’s mission by disseminating knowledge in the pursuit of
education, learning and research at the highest international levels of excellence.


www.cambridge.org
Information on this title: www.cambridge.org/ 9781108733755

© Cambridge University Press 2019

This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.

First published 2015
Second edition 2019

201918 17 1615 141312111098765432

Printed in Spain by GraphyCems

A catalogue record for this publication is available from the British Library

ISBN 978-1-108-73375-5 Paperback
ISBN 978-1-108-56832-6 Paperback with Cambridge Elevate edition (2 years)
ISBN 978-1-108-70041-2 Cambridge Elevate edition (2 years)
ISBN 978-1-108-70039-9 Digital edition


Cambridge University Press has no responsibility for the persistence or accuracy of URLs
for external or third-party internet websites referred to in this publication, and does not
guarantee that any content on such websites is, or will remain, accurate or appropriate.
Information regarding prices, travel timetables, and other factual information given in
this work is correct at the time of first printing but Cambridge University Press does not
guarantee the accuracy of such information thereafter.

All exam-style questions and sample answers in this title were written by the authors.
In examinations, the way marks are awarded may be different.

Past exam paper questions throughout reproduced by permission of Cambridge
Assessment International Education.

COCO   H   SOE   H   HSE   HEHE   EEE   OH   EEE   HE   EEE   OOOO   EEE   OEE   SESE   OTE   OOO   OEE   OOOO   OOO   TOTES   OOOO   OOOOH   OOOO   SOOO   SOOO   OOOO   OOOO   OOOO   OOS   OOS




NOTICE TO TEACHERS IN THE UK

Itis illegal to reproduce any part of this work in material form (including
photocopying and electronic storage) except under the following circumstances:
(i)    where you are abiding by a licence granted to your school or institution by the
       Copyright Licensing Agency;
(ii)   where no such licence exists, or where you wish to exceed the terms of a licence,
       and you have gained the written permission of Cambridge University Press;
(ili) where you are allowed to reproduce without permission under the provisions
       of Chapter
                3 of the Copyright, Designs and Patents Act 1988, which covers, for
       example, the reproduction ofshort passages within certain types of educational
       anthology and reproduction for the purposes of setting examination questions.
Contents


Part 1: Theory fundamentals
Chapter 1   Information representation
Chapter
      2     Communication and networking technologies         26

Chapter
      3     Hardware                                          50

Chapter
      4     Logic gates and logic circuits                    66

Chapter
      5     Processor fundamentals                            80

Chapter
      6     Assembly language programming                     91

Chapter
      7     Monitoring and control systems                   112

Chapter
      8     System software                                  121

Chapter
      9     Security, privacy and data integrity             133

Chapter 10 Ethics and ownership                              146

Chapter 11 Databases                                         157



Part 2: Fundamental problem-solving and programming skills
Chapter 12 Algorithm design and problem-solving              178

Chapter 13 Data types and structures                         209

Chapter 14 Programming and data representation               239

Chapter 15 Software development                              285



Part 3: Advanced theory
Chapter 16 Data representation                               313

Chapter 17 Communication and Internet technologies           329

Chapter 18 Hardware and virtual machines                     340

Chapter 19 Logic circuits and Boolean algebra                350

      20 System software
Chapter                                                      367

Chapter
      21 Security                                            386

      22 Artificial Intelligence (Al)
Chapter                                                      397



Part 4: Further problem-solving and programming skills
      23 Algorithms
Chapter                                                      411

Chapter
      24 Recursion                                           434

      25 Programming paradigms
Chapter                                                      443

      26 File processing and exception handling
Chapter                                                      446

      27 Object-oriented programming (OOP)
Chapter                                                      459

      28 Low-level programming
Chapter                                                      4387

Chapter
      29 Declarative programming                             498



Glossary                                                     513
Index                                                        519
Acknowledgements                                             527
Introduction

This full-colour, illustrated textbook has been written by experienced authors specifically for the Cambridge International
AS & A Level Computer Science syllabus (9618) for examination from 2021. It is based on the first edition by the same
authors for the previous Cambridge International AS & A Level Computer Science syllabus (9608). There are substantial
changes, the most important being the inclusion of the topic ofArtificial Intelligence (See Chapter 22) and the replacement
of the Pascal programming language by the Java programming language.

The presentation of the chapters in this book reflects the content of the syllabus:

e   The book is divided into four parts, each of which is closely matched to the corresponding part of the syllabus.

e   Each chapter defines a set of learning objectives which closely match the learning objectives set out in the syllabus.

e   The chapters in Parts 1 and 3 have been written with emphasis on the promotion of knowledge and understanding.
    The chapters in Parts 2 and 4 have been written with an emphasis on problem solving and programming.

The key concepts for Cambridge International AS & A Level Computer Science are:

Computational thinking
Computational thinking is a set of skills such as abstraction, decomposition and algorithmic thinking. Chapter 12 (Algorithm
design and problem-solving), Chapter 15 (Software development) and Chapter 23 (Algorithms) concentrate on this key concept.

Programming paradigms
A programming paradigm is a way of thinking about or approaching problems. Most of the programming in this book
follows the imperative (procedural) paradigm. Chapter 25 (Programming paradigms) gives an overview of other paradigms,
while Chapter 6 (Assembly language programming), Chapter 28 (Low-level programming), Chapter 27 (Object Oriented
Programming) and Chapter 29 (Declarative programming) give an insight into these paradigms.

Communication
Communication in this context ranges from the internal transfer of data within a computer system to the transfer ofdata
across the internet. See Chapter2 (Communication and networking technologies) and Chapter 17 (Communication and
internet technologies).

Computer architecture and hardware
Computer architecture is the design of the internal operation of a computer system. Computer systems consist of
hardware (internal components and peripherals) and software that makes the hardware functional. See Chapter 3
(Hardware), Chapter
                  4 (Logic gates and logic circuits), Chapter 8 (System software), Chapter 18 (Hardware and virtual
machines), Chapter 19 (Logic circuits and Boolean algebra) and Chapter 20 (System software).

Data representation and structures
An understanding of binary numbers and how they can be interpreted in different ways is covered in Chapter 1 (Information
representation) and Chapter 16 (Data representation). Chapter 11 covers databases. Chapter 13 (Data types and structures) and
Chapter 14 (Programming and data representation) show how data can be organised for efficient use and storage.

The chapters in Parts 1 and 3 have a narrative which involve a number of interdependent topics. We would encourage
learners to read the whole chapter first before going back to revisit the individual sections.

The chapters in Parts 2 and 4 contain many more tasks. We would encourage learners to approach these chapters
step-by-step. Whenever a task is presented, this should be carried out before progressing further.

In particular, Chapter 12 (Algorithm design and problem-solving) may be worked through in parallel with Chapter 14
(Programming and data representation). For example, Task 14.03 is based on Worked Example 12.03. After studying this
worked example, learners may wish to cover the first part of Chapter 14 and write the program for Task 14.03. This will give
the learner the opportunity to test their understanding of an algorithm by implementing it in their chosen programming
language. Then further study of Chapter 12 is recommended before attempting further tasks in Chapter 14.
How to use this book
This book contains a number of features to help you in your study.



    L          ¥       Birt                                                                        Learning objectives - each chapter begins
         earning objectives                                                                        with a short list of the learning objectives
                                be able to:
                        you should
           of this chapter
    Bythe end                                                                                      and concepts that are explained in it.
    m    show anunderstanding of monitoring and control systems
    m=   show understanding of how bit manipulation can be used to monitor/control a device.




Key Terms - clear and                       EEE
straightforwe rd explanations                      Bit: a digit in the binary number system written using either of the symbols 0 and 1
of the most important terms
in each chapter.         Ye”



                                                                                                                     Task - exercises for you to test
                                                                                                                     your skills.
  TASK 1.01

  Convert each of the denary numbers 96, 215 and 374 into hexadecimal numbers.
  Convert each of the hexadecimal numbers B4, FF and 3A2C to denary numbers.




Question - questions for you to test your                             .
knowledge and understanding.                                 Question 1.01
                               \            ee”              Does a computer ever use hexadecimal numbers?




Discussion Point:
What is the two’s complement of the binary value 1000? Are you surprised by this?

                                                                     Discussion Point - discussion points intended for class discussion.




Reflection Point - opportunities for you to check your
understanding of the topic that has just been covered. IN

                                        Reflection Point:
                                        Can you recall the different possibilities for what one byte might be coded to represent?
Cambridge International AS & A Level Computer Science




Extension Question - extended questions for consideration of more
advanced aspects or topics beyond the immediate scope of the
Cambridge International AS & A Level syllabus.


                                 Extension Question 1.01
                                 Graphic files can be stored in a number of formats. For example, JPEG, GIF, PNG and TIFF are just a few of the possibilities.
                                 What compression techniques, if any, do these use?




  WORKED EXAMPLE 1.01


  To carry out the conversion you start at the most significant bit and successively multiply by two and add the result to the
  next digit. The following shows the method being used to convert the binary number 11001 to the denary number 25:

                             1    x    2       =          2

   add 2 to 1, then          2    x    3       =          6
   add 6to 0, then           2    x    6       =          12
   add 12 to 0, then         2    x    12      =          24
   add 24 to 1 to give 25.



                                            Worked Example - step-by-step examples of solving problems or implementing
                                            specific techniques.




Tip - quick notes to
highlight key facts and
important points.                              TIP
                                               To check that an answer with eight bits is sensible, remember that the maximum denary value
               N                               possible in seven bits is 2’- 1 which is 127 whereas eight bits can hold values up to 2° - 1 which
                                               is 255.




                                                                                                                          p>    nN
  Summary                                                                                                                                 Summary -these
  _                                                                                                                                       appear at the end of
                                                                                                                                          each chapter
                                                                                                                                                     to help
                                                                                                                                          you review what you
                                                                                                                                          have learned




                                                Exam-style Questions

                                                1    a_        The following are the symbols for three different logic gates.

                                                                    Gate 1                              Gate 2                   Gate 3
Exam-style Questions -
these aim to test your skills,                                 —) >                             |
knowledge and understanding
using exam-style questioning.                                  i    Identify each of the logic gates.
                                                                                                                                                          Nw




                                                               ii   Sketch the truth table for either Gate 1 or Gate 2.
Chapter 1:
Information representation


By the end of this chapter you should be able to:

m   show understanding of binary magnitudes and the               show understanding of how data for a vector graphic are
    difference between binary prefixes and decimal prefixes       encoded

    show understanding ofthe basis of different number systems    justify the use of a bitmap image or a vector graphic fora

    perform binary addition and subtraction                       given task

m   describe practical applications where Binary Coded            show understanding of how sound is represented and encoded
    Decimal (BCD) and Hexadecimal are used                        show understanding of the impact of changing the sampling

m   show understanding of and be able to represent                rate and resolution

    character data in its internal binary form, depending on      show understanding of the need for and examples of the use
    the character set used                                        of compression

m   show understanding of how data for a bitmapped image          show understanding of lossy and lossless compression and
    are encoded                                                   Justify the use of a method in a given situation

m   perform calculations to estimate the file size for a bitmap   show understanding of howa text file, bitmap image, vector
    image                                                         graphic and sound file can be compressed.

m   show understanding ofthe effects of changing elements
    of a bitmap image on the image quality and file size
                                                                                Part 1: Chapter 1: Information representation




1.01 Number systems
Denary numbers
Asa   child we first encounter the numbers that we use in everyday life when we are first
learning to count. Specifically, we learn to count using 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. This gives us
ten different symbols to represent each individual digit. This is therefore a base-10 number
system. Numbers in this system are called denary numbers or, more traditionally, decimal
numbers.


ft KEY TERM




When a number is written down the value that it represents is defined by the place values of
the digits in the number. This can be illustrated by considering the denary number 346 which
is interpreted as shown in Table 1.01.


 Place value                                      10? = 100           10'= 10              10°=1
 Digit                                                3                    4                  6
 Product of digit and place value                   300                    40                 6

Table 1.01 Use of place values in the representation ofa denary number


You can see that starting from the right-hand end of the number (which holds the least
significant digit), the place value increases by the power of the base number.


Binary numbers
The binary number system is base-2. Each binary digit is written with either of the symbols 0
and 1.A binary digit is referred to as a bit.




As with a denary number, the value ofa binary number is defined by place values. For
example, see Table 1.02 for the binary number 101110.


 Place value                 2° = 32      2*=16           22=8       22=4          2'=2           2°=]
 Digit                          1            0             1           1             1             0
 Product of digit and
                               32                          8           4             2             0
 place value


Table 1.02 Use of place values in the representation of a binary number


By adding up the values in the bottom row you can see that the binary number 101110 has a
value which is equivalent to the denary number 46.

You must be able to use the binary number system in order
                                                        to understand computer
systems. This is because inside computer systems there is no attempt made to represent ten
Cambridge International AS & A Level Computer Science




different digits individually. Instead, all computer technology is engineered with components
that represent or recognise only two states: ‘on’ and ‘off’. To match this, all software used
by the hardware uses binary codes which consist of bits. The binary code may represent a
binary number but this does not have to be the case.

Binary codes are most often based on the use of one or more groups of eight bits. A group of
eight bits is called a byte.


EEE
   Byte: a group of eight bits treated as a single unit




Hexadecimal numbers
These are base-16 numbers where each hexadecimal digit is represented by one of the
following symbols: 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F. The symbols A through to F represent
the denary values 10 through to 15. The value ofa number is defined by place values. For
example, see Table 1.03 for the hexadecimal number 2A6.


 Place value                                          16? = 256       16'=16            16°=1
 Digit                                                      2           A                 6
 Product of digit and place value                          512         160                6


Table 1.03 Use of place values in the representation of a hexadecimal number


Adding up the values in the bottom row shows that the equivalent denary number is 678.

In order
       to explain why hexadecimal numbers are used we need first to define the nibble as a
group of four bits.


——
EEE
   Nibble: a group of four bits



A nibble can be represented by one hexadecimal digit. This means that each byte of binary
code can be written as two hexadecimal digits. Two examples are shown in Table 1.04
together with their denary equivalent.

             Binary                 |          Hexadecimal        |            Denary
            00001010                                  OA                         10

            11111111                                  FF                        255


Table 1.04 Examples of a byte represented by two hexadecimal digits

Note here that if you were converting the binary number 1010 to a hexadecimal number as an
exercise on a piece of paper you would not bother with including leading zeros. However, a
binary code must not include blanks; all positions in the byte must have either a 0 ora 1. This
is followed through in the hexadecimal representation.

One example when you will see hexadecimal representations of bytes is when an error has
occurred during the execution ofa program. A memory dump could be provided which has a
hexadecimal representation of the content of some chosen part of the memory. Another use
is when the bytes contain binary numbers in the charts that define character codes. This is
discussed later in this chapter.
                                                                          Part 1: Chapter 1: Information representation




In the character code charts and in other online sources you may see references to octal
numbers which are base-8. You can ignore these.



Converting between binary and denary numbers
One method for converting a binary number
                                        to a denary number is to add up the place
values for every digit that has a value 1. This was illustrated in Table 1.02.

An alternative method is shown in Worked Example 1.01.


   WORKED EXAMPLE 1.01


  To carry out the conversion you start at the most significant bit and successively multiply by two and add the result to the
  next digit. The following shows the method being used to convert the binary number 11001 to the denary number 25:

                             1    x     2      =     2

   add 2 to 1, then          2    x     3      =     6
   add 6 to 0, then          2    x     6      =      12
   add 12 to 0, then         2    x     12     =     24
   add 24 to 1 to give 25.



To convert a denary number
                         to binary begin by identifying the largest power of 2 that has a
value less than the denary number. You can then write down the binary representation ofthis
power of 2 value. This will be a 1 followed by the appropriate number of zeros.

Now subtract the power of two value from the denary number. Then identify the largest
power of 2 value that is less than the remainder from the subtraction. You can now replace a
zero in the binary representation with a 1 for this new power of 2 position.

Repeat this process until you have accounted for the full denary number.

For example, for the denary number 78 the largest power of two value less than this is 64 so
you can start by writing down 1000000. The remainder after subtracting 64 from 78 is 14. The
largest power of two value less than this is 8 so the replacement of a zero by 1 gives 1001000.
Repeating the process finds values of4 then 2 so the final answer is 1001110.

An alternative approach is shown in Worked Example 1.02.


   WORKED EXAMPLE 1.02


  A useful way to convert a denary value to its binary equivalent is the procedure of successive division by two with the
  remainder written down at each stage. The converted number is then given as the set of remainders in reverse order.

  This can be illustrated by the conversion of denary 246 to binary:

  246    +   2    >    123        with remainder
                                               0

  123    +   2    5    61         with remainder 1

  61     +   2    >    30         with remainder 1

  30     +   2    >    15         with remainder
                                               0
  5      +   2    5    7          with remainder 1

  1      +   2    >    3          with remainder 1

  3      +   2    3    1          with remainder 1
  1      +   2    >    0          with remainder 1

  Thus, the binary equivalent of denary 246 is 11110110.
Cambridge International AS & A Level Computer Science




Oo      TIP

        To check that an answer with eight bits is sensible, remember that the maximum denary value
        possible in seven bits is 2’ - 1 which is 127 whereas eight bits can hold values up to 2° - 1 which
        is 255.




 Conversions for hexadecimal numbers
 Itis possible to convert a hexadecimal number
                                             to denary by using the method shown in Table
 1.03. However, if there are more than a few digits, the numbers involved in the conversion
 become very large. Instead, the sensible approach is to first convert the hexadecimal number
to a binary number which can then be converted to denary.

To convert a hexadecimal number
                              to binary, each digit is treated separately and converted into
 a 4-bit binary equivalent, remembering that F converts to 1111, E converts to 1110 and so on.

To convert a binary number to hexadecimal you start with the four least significant bits
 and convert them to one hexadecimal digit. You then proceed upwards towards the most
significant bit, successively taking groupings of four bits and converting each grouping to the
 corresponding hexadecimal digit.



      TASK 1.01

      Convert each of the denary numbers 96, 215 and 374 into hexadecimal numbers.
      Convert each of the hexadecimal numbers B4, FF and 3A2C to denary numbers.




 Question 1.01
 Does a computer ever use hexadecimal numbers?



 1.02 Numbers and quantities
 There are several different types of numbers within the denary system. Examples ofthese are
 provided in Table 1.05.

     Type of number                | Examples                 | Comments
     Integer                                 30r47              A whole number used for counting
     Signed integer                          -3 0r 47           The positive number has an implied + sign

     Fraction                              2/3 or 52/17         Rarely used in computer science

     A number with a whole
     number part and a                    -37.85 or 2.83        The positive number has an implied
                                                                                               + sign
     fractional number part

     A number expressed in            236x108 or4.2* 10°        The value can be positive or negative and
     exponential notation                                       the exponent can be positive or negative


 Table 1.05 Different ways to express a value using the denary number system

 We will focus on how large values are represented. If we have a quantity that includes units
 of measurement, it can be written in three different ways. For example, a distance could be
 written in any one of these three ways:

 ©     23567mM

 e     23.567     10°m

 e     23.567 km
                                                                         Part 1: Chapter 1: Information representation




The second example has used an exponential notation to define the magnitude of the value.
The third example has added a prefix to the unit to define this magnitude. We read this as
23.567 kilometres.

The ‘kilo’ is an example of a decimal prefix. There are four decimal prefixes commonly used
for large numbers. These are shown in Table 1.06.


     Decimal prefix name                 Symbol used                Factor applied to the value
               kilo                             k                                 10°

              mega                              M                                 10°
               giga                             G                                 10°

               tera                             T                                10”


Table 1.06 The decimal prefixes


ft KEY TERM




Unfortunately, for a long time the computing world used these prefix names but with a
slightly different definition. The value for 2"° is 1024. Because this is close to 1000, computer
scientists decided that they could use the kilo prefix to represent 1024. So, for example, if a
computer system had the following values quoted for the processor speed and the size of the
memory and of the hard disk:

         Processor speed                     1.6 GHz

         Size of RAM                         8 GB

         Size of hard disk                   400 GB

The prefix G would represent 10° for the processor speed but would almost certainly
represent 1024 x 1024 x 1024 for the other two values.

This unsatisfactory situation has now been resolved by the definition ofa new set of names
which can be used to define a binary prefix. A selection of these is shown in Table 1.07.

      Binary prefix name                 Symbol used                Factor applied to the value
               kibi                             Ki                                210

               mebi                             Mi                                220
               gibi                             Gi                                220
               tebi                             Ti                                2°

Table 1.07 Some examples of binary prefixes


| KEY TERM




When a number or a quantity is presented for a person to read it is best presented with
either one denary digit or two denary digits before the decimal point. If a calculation has
been carried out, the initial result found may not match this requirement. A conversion of
 Cambridge International AS & A Level Computer Science




 the presented value will be needed by choosing a sensible magnitude factor. For example,
 consider the following two answers calculated for the size of a file:

 a   34560bytes

     Here, a conversion to kibibytes would be sensible using the calculation:

     344560B = 34560 KiB = 33.75 KiB
                  1024

 b   3456000 bytes

     Here, a conversion to mebibytes would be sensible using the calculation:
                   are
                     1024
     3456000B = —————
                    MiB = 3.296 MiB
                     1024

 Ifa calculation is to be performed with values quoted with different magnitude factors there
 must first be conversions to ensure all values have the same magnitude factor. For example,
 if you needed to know how many files of size 2.4 MiB could be stored on a4GiB memory stick
 there should be a conversion of the GiB value to the corresponding MiB value.

 The calculation would be:

 (4.x 1024)MiB
                 = 1076
     2.4MiB




 1.03 Internal coding of numbers
 The discussion in this chapter relates only to the coding of integer values. The coding of non-
 integer numeric values (real numbers) is considered in Chapter 16 (Section 16.03).



 Coding for integers
 Computers need to store integer values for a number of purposes. Sometimes only a simple
 integer is stored, with the understanding that it is a positive number. This is stored simply
 as a binary number. The only decision to be made is how many bytes should be used. If the
 choice is to use two bytes (16 bits) then the range ofvalues that can be represented is 0 to
 (2'®—1) which is 0 to 65 535,

 However, in many cases we need to identify whether the number is positive or negative, so
 we use a signed integer. A signed integer can just have the binary code for the value with an
 extra bit to define the sign. This is referred to as ‘sign and magnitude representation’. For this
 the convention is to use a 0 to represent + and a 1 to represent -. A few examples of this are
 shown in Table 1.08.

 However, there are a number of disadvantages to using this format, so signed integers are
 usually in two’s complement form. Here we need two definitions.

 The one’s complement of a binary number is defined as the binary number obtained if each
 binary digit is individually subtracted from 1. This means that each 0 is switched to 1 and
 each 1 switched to 0. The two’s complement is defined as the binary number obtained if 1 is
 added to the one’s complement number.


Uf cevrenns
     One’s complement: the binary number obtained by subtracting each digit in a binary number from 1
     Two’s complement: the one’s complement of a binary number, plus 1
                                                                         Part 1: Chapter 1: Information representation




If you need to convert a binary number
                                     to its two’s complement form, you can use the
method indicated by the definition but there is a quicker method. For this you start at the
least significant bit and move left ignoring any zeros up to the first 1, which you also ignore,
Change any remaining bits from 0 to 1 or from 1 to 0.

For example, expressing the number 10100100 in two’s complement form leaves the right-
hand 100 unchanged, then the remaining 10100 changes to 01011, so the result is 01011100.

To represent a positive denary integer value as the equivalent two’s complement binary form,
the process is as follows.

e       Use one of methods from Section 1.01 to convert the denary value to a binary value.

e       Adda 0in front ofthis binary value.

To represent a negative denary integer value as the equivalent two’s complement binary
form the process is as follows.

e       Disregard the sign and use one of methods from Section 1.01 to convert the denary value
        to a binary value.

e       Adda0     in front ofthis binary value.

e       Convert this binary value to its two’s complement form.

A few simple examples of two’s complement representations are shown in Table 1.08.

To convert a two’s complement binary number representing a positive value into a denary
value, the leading zero is ignored and one of the methods in Section 1.01 is applied to convert
the remaining binary.

There are two alternative methods for converting a two’s complement binary number
representing a negative number into a denary value. These are illustrated in Worked Example 1.03.


    WORKED EXAMPLE 1.03


    Methods for converting a negative number expressed in two’s complement form to the corresponding
    denary number
    Consider the two’s complement binary number 10110001.

    Method 1. Convert to the corresponding positive binary number then convert to denary before adding the minus sign

    e     Converting 10110001 to two’s complement leaves unchanged the 1 in the least significant bit position then changes
          all of the remaining bits to produce 01001111.

    e     You ignore the leading zero and apply one of the methods from Section 1.01 to convert the remaining binary to
          denary which gives 79.

    e     You add the minus sign to give -79.

    Method 2. Sum the individual place values but treat the most significant
                                                                          bit as a negative value

    You follow the approach illustrated in Table 1.02 to convert the original binary number 10110001 as follows:

                          —2!      28       2     24       23     22    21      20

        Place              _        _       _     _        _      _     _        _

        value            -128 | 64          32    16       8      4     2        1
        Digit              1        0       1     1        0      0     0        1

        Product          -128       0       32    16       0      0     0        1


    You now add the values in the bottom row to get -79.
Cambridge International AS & A Level Computer Science




Some points to note about two’s complement representation are as follows.

e     There is only one representation ofzero.
¢     Starting from the lowest negative value, each successive higher value is obtained by
      adding 1 to the binary code. In particular, when all digits are 1 the next step is to roll over
      to an all-zero code. This is the same as any digital display would do when each digit has
      reached its maximum value.
e     Just adding a leading zero to an unsigned binary value converts it to the two’s
      complement representation of the corresponding positive number
e     You use a two's complement conversion to change the sign ofanumber from positive
      to negative or from negative to positive. We say that the two’s complement values are
      self-complementary.
e     You can add any number of leading zeros to a representation of a positive value without
      changing
            the value.
e     You can add any number of leading ones to a representation ofa negative value without
      changing
            the value.

    Signed denary number to            Sign and magnitude                   Two’s complement
    be represented                      representation                       representation

                   7                                  0111                                  0111

                   1                                  0001                                  0001

                   0                                  0000                                  0000

                  -0                                  1000                            Not represented

                  -l                                  1001                                  1111

                  -/                                  1111                                  1001

                  -8                             Not represented                            1000


Table 1.08 Representations of signed integers



=     TIP

      If you are converting a negative denary number into two’s complement you begin by converting
      the denary value to a binary value. Then you must not forget to add a leading zero before taking
      the two's complement to convert the positive value to a negative value.




     TASK 1.02

     Take the two’s complement of the binary code for —7 and show that you get the code
     for +7.




     TASK 1.03

     Convert the two’s complement number 1011 to the denary equivalent. Then do the
     same for 111011 and convince yourself that you get the same value.



Discussion Point:
What is the two’s complement of the binary value 1000? Are you surprised by this?
                                                                            Part 1: Chapter 1: Information representation




Binary arithmetic
Before considering the addition of binary numbers it is useful to recall how we add two denary
numbers. Two rules apply. The first rule is that the process is carried out starting with addition
of the two least significant digits and then working right to left. The second rule is that if an
addition produces a value greater than 9 there is a carry of 1. For example in the addition of
48 to 54, the first step is adding 8 to 4 to get 2 with a carry of 1. Then 5 is added to 4 plus the
carried 1 to give 0 with carry 1. The rules produce 102 for the sum which is the correct answer.

For binary addition, starting at the least significant position still applies. The rules for the
addition of binary digits are:

e   0+0=0

©   OF1=1

e   1+1=Owithacarry
                 of 1

e   1+1+0=O0withacarry
                    of 1

e   1+1+1=1withacarry
                   of 1

The last two rules are used when a carried 1 is included in the addition of two digits.

As an example, the addition of the binary equivalent of denary 14 to the binary equivalent of
denary 11 can be examined.




The steps followed from right to left are:

e   1+0=1 with no carry

e   1+1=0with carry 1

e   0+1+carried 1=0 with carry1

e   1+1+carried 1=1 with carry1

The rules have correctly produced the 5-bit answer which is the binary equivalent of25. In a
paper exercise like this these rules for addition will always produce the correct answer.

Again for subtraction we can first consider how this is done for denary numbers. As for
addition the process starts with the least significant digits and proceeds right to left. The
special feature of subtraction is the “borrowing” ofa 1 from the next position when a
subtracting digit is larger than the digit it is being subtracted from.

For example in subtracting 48 from 64 the first step is to note that 8 is larger than 4. Therefore
1 has to be borrowed as 10. The 10 added to 4 gives 14 and 8 subtracted from this gives 6.
When we proceed to the next digit subtraction we first have to reduce the 6 to 5 because of
the borrow. So we have subtraction of 4 from 5 leaving 1. The answer
                                                                 for the subtraction is 16.

For binary subtraction, starting at the least significant position still applies. The rules for the
subtraction of binary digits are:

«   0-0=0

e   0-1=laftera borrow

«   ]-0=1

e   1-1=0

As an example, the subtraction of the binary equivalent of denary 11 from the binary
equivalent of denary 14 can be examined.
Cambridge International AS & A Level Computer Science




The steps followed from right to left are:

e       lislarger than 0so 1 is borrowed giving subtraction of 1 from 10 leaving 1

e       Because of the borrow the 1 is reduced to 0 so that 1 is to be subtracted from 0. This
        requires a further borrow giving subtraction of 1 from 10 leaving 1

e       Because of the borrow the 1 is reduced to 0 leaving subtraction of 0 from 0

«       1-lgives0O

The answer is the binary value for denary 3.

When binary addition is carried out by a computer using internally stored numbers there is
a major difference. This arises from the fact that the storage unit will always have a defined
number of bits. For example, in the above addition, if binary values were limited to being
stored in a nibble the result of the addition would be incorrectly stored as 1001. This is an
example of an overflow. The value produced is too large to be stored.


EE
        Overflow: a condition when the result of a calculation is too large to fit into the number of bits defined
        for storage



When the values in a computer system are stored in two’s complement form this problem
has a characteristic behaviour.

In the following addition where +63 is added to +63 there is no problem; the answer is
correctly obtained as +126:




However, if the binary for +96 is added to +96 the result is as follows:

           0      1       1    0     0      0      0     0

    +      0      1       1    0     0      0)     0     0

           1      1       0    0)     0     0      0     0

The overflow means that the answer has a leading 1, which causes a computer system to
interpret the answer as a negative number.

A similar problem can occur when two negative values are added. For example the addition
of —96 to the same value results in the following:

                      1   0     1     0      0     0      0     0

    +                 1   0     1     0      0     0      0     0

           (1)        0   1     0     0      0     0      0     0

This time there has been a carry when the most significant bits were added and the result
obtained is a positive number.

Clearly we need the processor to detect overflow and output an error message. There is a
discussion of how a processor can detect overflow in Chapter 6 (Section 6.07).
                                                                                           Part 1: Chapter 1: Information representation




One of the advantages of using two’s complement representations is that it simplifies the
process of subtracting one number from another. The number being subtracted is converted
to its two’s complement form, which is then added to the other number.



  TASK 1.04

   Using a byte to represent each value, carry out the subtraction of denary 35 from
  denary 67 using binary arithmetic with two's complement representations.




Binary coded decimal (BCD)
One exception to grouping bits in bytes to represent integers is the binary coded decimal
(BCD) scheme. This is useful in applications that require single denary digits to be stored or
transmitted. The BCD code uses a nibble to represent a denary digit. We consider the simple
scheme where the digits are coded as the binary values from 0000 to 1001. The remaining
codes 1010 to 1111 do not have any meaning.


   KEY TERMS


                                 BC    fs SLOFage Of a DINALY \ alue representing One ¢ lenat / digit INa Nipple

                                                 e stored     In one byte




Ifa denary number with more than one digit is to be converted to BCD there has to bea
sroup offour bits for each denary digit. There are, however, two options for BCD; the first is
to store one BCD code in one byte, leaving four bits unused. The other option is packed BCD
where two 4-bit codes are stored in one byte. Thus, for example, the denary digits 8503 could
be represented by either of the codes shown in Figure 1.01.


One BCDdigit
         per byte |                   00001000     |       00000101    |    00000000   |   00000011      |


Two BCD digits per byte |             10000101     |       00000011    |

Figure 1.01 Alternative BCD representations of the denary digits 8503


There are a number of applications where BCD can be used. The obvious type of application is
where denary digits are to be displayed, for instance on the screen of a calculator or ina digital
time display.   ASomewhat unexpected application is for the representation of currency values.
When a currency value is written in a format such as $300.25 it is as a fixed-point decimal number
(ignoring the dollar sign). It might be expected that such values would be stored as real numbers
but this cannot be done accurately (this type of problem is discussed in more detail in Chapter 16
(Section 16.03)). One solution to the problem is to store each denary digit as a BCD code.

Let's consider how BCD arithmetic might be performed by a computerif fixed-point decimal
values for currency were stored as BCD values. Here is an example ofaddition.


0.26| 00000000       |       |    00100110             |
                         +



0.85| 00000000       |       |    10000101             |



     |   00000000    |       |    10101011             |

Figure 1.02 Incorrect addition using BCD coding
Cambridge International AS & A Level Computer Science




We will assume a two-byte packed BCD representation. The first byte represents two denary
digits for the whole part of the number and the second byte represents two denary digits for
the fractional part. If the two values are $0.26 and $0.85 then the result of the addition should
be $1.11. This would involve a carry from the first decimal place to the whole number 1.
However, applying simple binary addition of the BCD codes would produce the result shown
in Figure 1.02.

The additions for the fractional parts have produced values corresponding to the denary
values 10 and 11 but a BCD value is supposed to be a single digit. The error has resulted in no
carry to the whole number column.

We need the processor
                   to recognise that an impossible value has been produced and apply a
method to correct this. The solution is to add 0110 whenever the problem is detected. This is
illustrated in Figure 1.03.

                                       0.26 |   00000000   |       |    00100110     |
                                                               +



                                       0.85 |   00000000   |       |    10000101     |



     Initial sum (giving values over 1001) |    00000000   |       |    10101011     |


Add correction to least significant nibble                                   0110
                  The result has a carry bit                                10001

Add correction plus carry to next nibble                                0111 0001
                  The result has a carry bit                           1 0001 0001


      Add carry to next nibble to get 1.11 |    00000001   |       |    00010001

Figure 1.03 Use ofthe correction value to perform BCD addition


The steps shown in Figure 1.03 are as follows.

e   Starting with the least significant nibble, adding 0110 to 0101 gives 1011 which is
    recognised as being incorrect.

e   The0110 correction value is added to produce 10001.

e   The 0001 is stored and the leading 1 is carried to the next nibble.

¢   Inthe first decimal position adding 0100 to 1000 then adding the carry bit 1 gives 1011
    which is recognised as being incorrect.

e   The 0110 correction is added to produce 10001.

e   The 0001 is stored and the leading 1 is carried to the next nibble.

In this example the two whole number nibbles have zero values so adding these has no effect.



1.04 Internal coding of text
To store text in a computer, we need a coding scheme that provides a unique binary code for
each distinct individual component item ofthe text. Such a code is referred to as a character
code. There have been many different examples of character coding schemes throughout the
history of computing.
                                                                               Part 1: Chapter 1: Information representation




ASCII code
The scheme which has been used for the longest time is the ASCII (American Standard Code
for Information Interchange) coding scheme. The 7-bit version of the code (often referred
to as US ASCII) was standardised many years ago by ANSI (American National Standards
Institute). The codes are always presented in a table. Table 1.09 shows an edited version of a
typical table. The first column contains the binary code which would be stored in one byte,
with the most significant bit set to zero and the remaining bits representing the character
code. The second column shows the hexadecimal equivalent.

    Binary code        Hexadecimal equivalent               Character          Description
       00000000                         00                         NUL               Null character

       00000001                         01                         SOH              Start of heading

       00100000                         20                                                 Space

       00100001                         23                          #                      Number

       00110000                         30                          0                       Zero

       00110001                         31                          1                       One

       01000001                         41                          A                 UppercaseA

       01000010                         42                          B                 Uppercase B

       01100001                         61                          A                 Lowercase a

       01100010                         62                          B                 Lowercase b


Table 1.09 Some examples of ASCII codes stored in one byte with the remaining, most
significant bit set to zero


A full table would show the 2! (128) different codes available for a 7-bit code.




      TIP

      Do not try to remember any of the individual codes



You need to remember these key facts about the ASCII coding scheme.

e     Alimited number of the codes represent non-printing or control characters; these were
      introduced to assist in data transmission or for data handling at a computer terminal.

e     The majority of the codes are for characters that would be found in an English text and
      which are available on a standard keyboard.

e     These include upper- and lower-case letters, punctuation marks, denary digits and
      arithmetic symbols.

e     Thecodes for numbers and for letters are in sequence so that, for example, if 1 is added
      to the code for seven, the code for eight is produced.

e     The codes for the upper-case letters differ from the codes for the corresponding lower-
      case letters only in the value of bit 5, which allows a simple conversion from upper to
      lower case or the reverse. (Don’t forget that the least significant bit is bit 0.)

Note that this coding for numbers is exclusively for use in the context of stored, displayed or
printed text. All of the other coding schemes for numbers are for internal use in a computer
system and would not be used in a text.

Although a standard version of ASCII has been created, different versions of 7-bit ASCII are
tailored to different software or different countries. Mostly, the coding for the printable
Cambridge International AS & A Level Computer Science




characters has remained unchanged. A notable exception was the use in some countries ofthe
code 00100001 to represent a currency symbol rather than #. However, because most of the
control characters became of limited use, there were versions of ASCII that used these codes to
produce small graphic icons. For example, the code 00000001 would show @.

Extended ASCll is a code that uses all eight bits in a byte. The most used standardised
version is often referred to as ISO Latin-1. The name Latin-1 reflects the fact that many of
the new character definitions are for accented or otherwise modified alphabetic characters
found in European languages, for example C or U. As with the 7-bit code, there are many
variations of the standard code.


Question 1.02
Many years ago, a byte was defined as six bits. Ifa character was to be represented by one
byte, which characters would you expect to be representable and which ones would you
expect to be unavailable?



Unicode
Although ASCII codes are widely used, they do not cover all the characters needed for
some uses. For this reason, new coding schemes have been developed and continue to be
developed further. The discussion here describes one of the Unicode schemes. It should be
noted that Unicode codes have been developed in tandem with the Universal Character Set
(UCS) scheme, standardised as ISO/IEC 10646.

The aim of Unicode is to be able to represent any possible text in code form. In particular, this
includes all languages in the world. The most popular version of Unicode which is discussed
here is named UTF-8. The inclusion of
                                    8 in the name indicates that this version of the standard
includes codes defined by one byte in addition to codes using two, three and four bytes.

Figure 1.04 shows the structure of the codes. The 1 byte code reproduces 7-bit ASCII.
Because the byte has the most significant bit set to 0 there can be no confusion with any byte
which is part ofa multiple byte code. Note that for the two-byte, three-byte and four-byte
representations all continuing bytes have the two most significant bits set to 10. Whenever a
byte has the most significant bits set to 11 there will be at least one continuation byte following.


 0222227?

 1102227?   | 1022727?

 1110272?    | 10227272    _—«*|:1022227?

 11110272    | 10227272,    | 10222222_~—«|   10222277


Figure 1.04 Byte formats for Unicode UTF-8


The number of codes available is determined by the number of bits that are not pre-defined
by the format. For example, there are eleven bits free to identify codes in the 2-byte format.
This allows 2" = 2048 different codes.

Unicode has its own special terminology and symbolism. A character code is referred to as
a ‘code point’. In any documentation a code point is identified by U+ followed by a 4-digit
hexadecimal number. The code points U+0000 to U+00FF define characters which are a
duplicate of those in the standard Latin-1 scheme. The binary codes corresponding to
U+0000 to U+007F use one byte only and range from 00000000 through to 01111111. Then the
binary codes for U+0080 to U+O0FF require two bytes and range from 11000000 for the         first
byte followed by 10000000 for the second byte through to 11000001 followed by 10111111.
                                                                       Part 1: Chapter 1: Information representation




1.05 Images
Images can be stored in a computer system for the eventual purpose of displaying the image
on a screen or for presenting it on paper, usually as a component ofa document. Such an
image can be created by using an appropriate graphics package. Alternatively, when an
image already exists independently of the computer system, the image can be captured by
using photography or by scanning.


Vector graphics
In an image that is created by a drawing package or a computer-aided design (CAD) package
each component is an individual drawing object. The image is then stored, usually as a
vector graphic file.

We do not need to consider how an image of this type would be created. We do need to
consider how the data is stored after the image has been created. A vector graphic file
contains a drawing list. The list contains a command for each object included in the image.
Each command has a list of attributes, each attribute defines a property of the object. The
properties include the basic geometric data such as, for a circle, the position of the centre
and its radius. In addition, properties are defined such as the thickness and style ofa line, the
colour of a line and the colour that fills the shape. An example of what could be created as a
vector graphic file is shown in Figure 1.05.


   KEY TERMS




  TASK 1.05

   Construct a partial drawing list for the graphic shown in Figure 1.05. You can take
   measurements from the image and use the bottom left corner of the box as the
   origin of a coordinate system. You can invent your own format for the drawing list.




         O
                  \

        /N
Figure 1.05    Asimple example of a vector graphic image

The most important property of a vector graphic image is that the dimensionsof the objects
are not defined explicitly but instead are defined relative to an imaginary drawing canvas. In
other words, the image is scalable. Whenever   the image is to be displayed the file is read, the
appropriate calculations are made and the objects are drawn to a suitable scale. If the user
then requests that the image is redrawn at a larger scale the file is read again and another set
Cambridge International AS & A Level Computer Science




of calculations are made before the image is displayed. This avoids image distortion, such as
the image appearing squashed or stretched.

Note that a vector graphic file can only be displayed directly on a graph plotter, which is an
expensive specialised piece of hardware. For the image to appear correctly on other types of
display, the vector graphic file often has to be converted to a bitmap.



Bitmaps
Most images do not consist of geometrically defined shapes, so a vector graphic
representation is inappropriate. Instead, generally an image is stored as a bitmap. Typical
uses are when capturing an existing image by scanning or perhaps by taking a screen-shot.
Alternatively, an image can be created by using a simple graphics package.

The fundamental concept underlying the creation of a bitmap file is that the picture element
(pixel) is the smallest identifiable component of a bitmap image. The image is stored as a
two-dimensional matrix of pixels. The pixel itself is a very simple construct; it has a position
in the matrix and it has a colour. It does not matter whether each pixel is a small rectangle, a
small circle or a dot.

The scheme used to represent the colour has to be defined. The simplest option is to use
one bit to represent the colour, so that the pixel is either black or white. Storage of the colour
in four bits allows simple greyscale colouring. At least eight bits per pixel are necessary
to provide a sufficient range of colours to provide a reasonably realistic representation
of any image. The number of bits per pixel is sometimes referred to as the colour depth.


   KEY TERMS




An alternative definition is the bit depth. Although these terms are sometimes used
interchangeably, bit depth is best defined as the number of bits used to store each ofthe red,
green and blue primary colours in the RGB colour scheme.

A colour depth of 8 bits per pixel provides 256 different colours. A bit depth of 8 bits per
primary colour provides 256 x 256 x 256 = 16 777 216 different colours. The eye cannot
distinguish this number of different colours. However, this many are needed if an image
contains areas of gradually changing colour such as in a picture of the sky. If a lower bit depth
is used the image will show bands of colour.

We also need to decide which resolution to use for the image, which can be represented as
the product of the number of pixels per row times the number of rows. When considering
resolution it is important to distinguish between an image resolution, as defined in a bitmap
file, and a screen resolution for a particular monitor screen that might be used to display the
image. Both of these have to be considered if a screen display is being designed.


   KEY TERMS

    >on

    Bit d ptn. the number of bits used to represent each of the red, green and blue colours
            whine   +!     |     ae          L     NNN      ed     Fa      ’   ,      ,   |




    im ge} i r solution:
                    a  eo
                          Ine NUMDEF
                          «6+     |
                                                   the bitmapspy file
                                     OT¢ Pl els in Nee            fl
                                                                      defined
                                                                         f
                                                                              as\@ the
                                                                                   sf
                                                                                       product
                                                                                        .      1
                                                                                                 ofralthe AT
                                                                                                          width
                                                                                                              +I
                                                                                                                 and
                                                                                                                  =)
                                                                                                                     th
                                                                                                                      | ;
                                                                          Part 1: Chapter 1: Information representation




A bitmap file does not define the physical size of a pixel or of the whole image. When the
image is scaled the number of pixels in it does not change. If a well-designed image is
presented on a suitable screen the human eye cannot distinguish the individual pixels.
However, if the image is magnified too far the individual pixels will be seen. This is illustrated
in Figure 1.06 which shows an original small image, a magnified version ofthis small image
and a larger image created with a more sensible, higher resolution.




Figure 1.06 (a) a bitmap logo; (b) an over-magnified version of the image; (c) a sensible
larger version


File size is always an issue with an image file. A large file occupies more memory space and
takes longer
           to display or
                       to be transmitted across a network. Usually, a vector graphic file
uses considerably less memory space than a corresponding bitmap file.

You can calculate the size ofa bitmap graphic knowing the resolution and the colour depth.
As an example, consider that a bitmap graphic is needed to fill a laptop screen where the
resolution is 1366 by 768. If we want colour depth of 24 then the number of bits we need is:

                                 1366 x 768 x 24 = 25 178112 bits

The result of this calculation shows the number of bits, but a size is always quoted as a
number of bytes or multiples of bytes. For our bitmap graphic:

25178112 bits     =25178112+8=3147264 bytes

                  = 3147 264 + 1024 = 3073.5 kibibytes (3073.5 KiB)

                  = 3073.5 + 1024 = approximately 3 MiB

Note that this calculation has assumed that the colour depth specifies the total number of
bits used to define each pixel. If the information given was that the bit depth was eight, then
the calculation would use 8 + 8 + 8 for the number of bits per pixel.


   WORKED EXAMPLE 1.04



  You have been asked to calculate a value for the minimum size of a bitmap file. The bitmap is to use a bit depth of 8
  and the bitmap is to be printed with 72 dpi (dots per inch) and to have dimensions 5 inches by 3 inches.

  We use the information provided about the colour depth orthe bit depth to give the number of bits per pixel. In this case
  the bit depth is 8, which means 8 bits for each of the RGB components, so 24 bits are needed for one pixel.

  Let’s state that 72 dpi means 72 pixels per inch.

                                                                                                                 (Continued)
Cambridge International AS & A Level Computer Science




    So, the number of pixels per row is 5 x 72 = 360

    And the number of pixels per column is 3 x 72 = 216

    Therefore, the total number of pixels is 360 x 216 = 77 760

    The total number of bits is this value multiplied by 24. However, we want the size in bytes not bits, so we multiply by 3
    because there are 8 bits in a byte. So, we get:

    17 160 X 3 = 233280 bytes.

    We can quote this in kibibytes by dividing by 1024:

    233 280 / 1024 = 227.8 KiB



A bitmap file has to store the pixel data that defines the graphic, but the file must also have
a file header that contains information on how the graphic has been constructed. Because
of this, the bitmap file size is larger than the size of the graphic alone. At the very least the
header will define the colour depth or bit depth and the resolution.


Qo
    File header: a set of bytes at the beginning of a bitmap file which identifies the file and contains
    information about the coding used



The following are considerations when justifying the use of either a bit map or a vector
eraphic for a specific task.

e   Avector graphic is chosen if a diagram is needed to be constructed for part of an
    architectural, engineering or manufacturing design.

e   if avector graphic file has been created but there is a need to print a copy using a laser or
    inkjet printer the file has first to be converted to a bitmap.

e   Adigital camera automatically produces a bitmap.

e   Abitmap file is the choice for insertion of an image into a document, publication or
    web page.



1.06 Sound
Natural sound consists of variations in pressure which are detected by the human ear. A
typical sound contains a large number of individual waves, each with a defined frequency.
The result is a wave form in which the amplitude of the sound varies in a continuous but
irregular pattern.

lf we want to store sound or transmit it electronically the original analogue sound signal has
to be converted to a binary code. The measured sound values are input to a sound encoder
which has two components. The first is a band-limiting filter. This is needed to remove high-
frequency components. A human ear cannot detect these very high frequencies and they
could cause problems for the coding if not removed. The other component in the encoder is
an analogue-to-digital converter (ADC) which converts the analogue data to digital data.

Figure 1.07 shows the sampling operation of the ADC. The amplitude ofthe wave (the red
line) has to be sampled at regular intervals. The blue vertical lines indicate the sampling
times. The amplitude cannot be measured exactly; instead the amplitude is approximated
                                                                                          Part 1: Chapter 1: Information representation




by the closest of the defined amplitudes represented by the horizontal lines. In Figure 1.07,
sample values 1 and 4 will be an accurate estimate of the actual amplitude because the wave
is touching an amplitude line. In contrast, samples 5 and 6 will not be accurate because the
actual amplitude is approximately half way between the two closest defined values.

To code sound, we need to make two decisions. The first is the number of bits we will use to store
the amplitude values, which defines the sampling resolution. if we use only three bits then eight
levels can be defined as shown in Figure 1.07. If too few are used there will be a significant error
when the closest amplitude in the scale of values dictated by the sampling resolution is used as
the approximation for the real value. In practice, 16 bits provides reasonable accuracy for most
digitised sound.

We also need to choose the sampling rate, which is the number of samples taken per
second. This should be in accordance with Nyquist’s theorem which states that sampling
must be done at a frequency at least twice the highest frequency of the sound in the sample.


f KEY TERMS



                                                                            al Oak ek
                                                                    Lane
                                                            ol
                                                    st

                                                                      &
                                       D



                                                            ee ee
                           +

                                       Lt




                                                                           Va




  Sound
                           a


                                            |



                                                   >


                                                            ee




amplitude
                                       ee




                                                                            Seed ad adc
                        IN
                            =




                                       oe




                                                    ee




                                                            ee
                            | =




                                       fe
                            =




                                                    a




                                                            I, ee
                            NO = = =




                                                    Cn
                                       CO




                                                            (0)
                                                       Vv




                                            Time


Figure 1.07 ADC sampling


Once again file size can be an issue. An increased sampling rate and an increased sampling
resolution will both cause an increase in file size.



1.07 Compression techniques
Larger files require larger storage capacity but more importantly, larger files have lower
transmission or download rates. For this reason, compression techniques are often used to
reduce file size.

There are two categories of compression. The first is lossless compression where the file
size is reduced but no information is lost. The process can be reversed to re-create the
Cambridge International AS & A Level Computer Science




original file. The second is lossy compression where the file size is reduced with some loss
of information and the exact original file can never be recovered. In many applications a
combination of lossless and lossy methods are used.


————EEE
   Lossless compression: coding techniques that allow subsequent decoding to recreate exactly the
   original file

   Lossy compression: coding techniques that cause some information to be lost so that the exact
   original file cannot be recovered in subsequent decoding



We could use the same type of lossless file compression for everything, because all files
contain binary codes. A good compression application will recognise patterns in files that it
can compress, without any knowledge ofwhat file type the code represents. However, most
compression techniques have been developed to work with a particular type of file.

A common lossless compression technique is run-length encoding. This works particularly
well with a bitmap file. The idea is that compression converts sequences of the same byte
value into a code that defines the byte value and the number oftimes it is repeated (the count).

For example, the sequence of the same four bytes:

                                           01100110 01100110 01100110 01100110

could be replaced by:

                                                   00000100   01100110

which says that there is a run offour ofthe bytes.

However, this is not the full story because in this simple form it is not obvious which byte
represents the number (count) in the sequence. There are a number of methods used to
distinguish the count byte from a data byte, but we do not need to go into the details.

If a file contains text, then compression must be lossless because any loss of information
would lead to errors in the text. One possible compression method is called Huffman coding.
The procedure used to carry out the compression is quite detailed, but the principle is
straightforward. Instead of having each character coded in one byte, the text is analysed to
find the most often used characters. These are then given shorter codes. The original stream
of bytes becomes a bit stream.

A possible set of codes if a text contained only eight different letters is shown in Table 1.10.
The important point to note here is the prefix property. None of the codes begins with the
sequence of bits representing a shorter code. This means that there can be no ambiguity
when the transmitted compressed file has to be converted back to the original text.


      Code         | Character
         10              e

         O1
                         e€loljriy|olicd




       111

       110

      0001

      0000

      0011

      0010                Zz



Table 1.10 An example of Huffman coding
Huffman coding can also be used for compressing a sound file. This is effective because
some values for the amplitude occur far more often than others do.

lf a vector graphic file needs to be compressed it is best converted to a Scalable Vector
Graphics format. This uses a markup language description of the image which is suitable for
lossless compression.

Lossy compression can be used in circumstances where a sound file or an image file can
have some of the detailed coding removed or modified. This can happen when it is likely that
the human ear or eye will hardly notice any difference. One method for lossy compression
of a sound file takes advantage of the fact that the successive sampled values are unlikely
to change very much. The file of individual sample amplitudes can be converted to a file of
amplitude differences. Compression is achieved by using a lower sample resolution to store
the differences. An alternative is to convert the sampled amplitudes that represent time
domain data and transform them to a frequency domain representation. The values for
frequencies that would be barely audible are then re-coded with fewer bits before the data is
transformed back to the original time domain form.

For a bitmap a simple lossy compression technique is to establish a coding scheme with
reduced colour depth. Then for each pixel in the original bitmap the code is changed to the
one in the new scheme which represents the closest colour.




Reflection Point:
Can you recall the different possibilities for what one byte might be coded to represent?




      A binary code or a binary number can be documented as a hexadecimal number.
      Internal coding of signed integers is usually based on a two’s complement representation.
      Binary addition can cause overflow.

      BCD is a convenient coding scheme for single denary digits.
      ASCIl and Unicode are standardised coding schemes for text characters.
      An image can be stored either in a vector graphic file or in a bitmap file.
      An ADC works by sampling a continuous waveform.

      Lossless compression allows an original file to be recovered by a decoder; lossy compression
      irretrievably loses some information.
                                                                                    V1
                                                                                                                             =




1   A file contains binary coding. The following are twosuccessive bytes in the file: 1CG10101 anc OO1LOCLI


         vee‘binarynumberr.
    a




         i       Calculate thedenary number corresponding
                                                     to this.




                                                                                                                  —
         H = Calculate the hexadecimal numbercortesponctng to this.




                                                                                                                      faa)
                                                                                                           Ry
                                                                                                                 NY
             sive ane example ofwhena hexadecimal representation is used.
         nother possi ty for the information stored is that
                                                         the wo bytes individually
                                                                               represent two
         signed integer binary numbers in two’s complement form.

         i       State which byte represents a negative number and explain the reason for your choice.

         H       Calculate the denary number corresponding to each byte.




                                                                                                                  —T
         Give two advantages of representing signed integers
                                                           in two’s complement
                                                                           farm rather
         than using a sign and magnituce representation.

         Give three different examples of other options for the types ofinformation that could be
         represented by two bytes, For each example, state whethera representation requires
         two bytes each time, just one byteor only part of a byte each time.

    A designer wishes to incluce some multimedia components on a web
                                                                   page,

    a    If the designer has some images storedinfiles there are two possible formatsfor the files.

         i       Deseribe the approach used ifa graphicisstored in a vector graphic file.

         fi      Describe the approach used ifa graphicis stored in a bitmap file.

         Hi      State whichformatgives better        image quality if the image has to be magnified
                                               ther




                 and explain why,

         The designer is concerned about the size of some bitmap fites.

         i     6 if the resolution is to be 649 x 480 and the colour depth is to be 16, calculate an


         H Explain why this calculation only gives an approximate fleSize,
         The designer decides that the bitrnap files need compressing.
         i     = - Explainhow a simple form oflossless compression could be used.
                                                                                                         ioctl


                                                                                                             ———
                                                                                                               5
                                                                                                               2




         H       Explain one possible approach to lossycompressionthat could be used.

3   An audio encoder is to be used to create a recording of a song. The encoderhas two camponents,

    a    One of the components is an analogue-to-digital converter (ADC).

         i       Explain why this is needed.

         Ho fwo important factors associated with the use of an ADC are the sampling rate
                 and the sampling resolution. Explain the twoterms. Sketch a diagram if this will
                 heip your explanation.

         The other cornponent of
                               an audio encoder has to be used before the ADC is used.

         i       identify this component.
                                                                                                          —


                                                                                                                      a
                                                                                                                 —
                                                                                                                      —




         H#      Explain why itis used,
                                                                             Part 1: Chapter 1: Information representation




4   a_i         Using two’s complement, show how the following denary numbers could be stored
                in an 8-bit register:


                124



                11




                                                                                                                   NS NS
        ii     Convert the two numbers in part (a) (i) into hexadecimal.

    b   Binary Coded Decimal (BCD) is another way of representing numbers.
        i     | Write the number 359 in BCD form.                                                                  [1]

        ili     Describe a use of BCD number representation.                                                       [2|

                                        Cambridge International
                                                             AS & A Level Computer Science 9608 paper 13 QI June 2015

5   a   Soundcan be represented digitally in a computer.

        Explain the terms sampling resolution and sampling rate.                                                   [4]

    b   The following information refers to a music track being recorded on a CD:
        e     music is sampled 44100 times per second

              each sample is 16 bits
              each track requires sampling for left and right speakers.

        i       Calculate the number of bytes required to store one second of sampled music.
                Show your working.                                                                                 [2|

        ii      A particular
                     track is four minutes long.

                Describe how you would calculate the number of megabytes required to store
                this track.                                                                                        [2

    c   When storing music tracks in a computer, the MP3 format is often used. This reduces file
        size by about 90%.

        Explain how the music quality is apparently retained.                                                      [3]

                                   Cambridge International AS &A Level Computer Science 9608 paper 12 Q4 November 2015
Chapter 2:
Communication and networking
technologies

By the end of this chapter you should be able to:

   show understanding of the purpose and benefits of           describe the hardware that is used to support a LAN
   networking devices                                          describe the role and function of a router in a network
   show understandingof the characteristics of a LAN (local    show understanding of Ethernet and how collisions are
   area network) and a WAN (wide area network)                 detected and avoided
   explain the client-server and peer-to-peer models of        show understanding of bit streaming
   networked computers                                         show understandingof the differences between the World
   show understandingof thin-client and thick-client and the   Wide Web (WWW) and the Internet
   differences between them                                    describe the hardware that is used to support the Internet
   show understanding of the bus, star, mesh and hybrid        explain the use of IP addresses in the transmission of data
   topologies                                                  over the Internet
   show understanding of cloud computing                       explain how a Uniform Resource Locator (URL) is used to
   show understandingof the differences between and            locate a resource on the World Wide Web (WWW) and the
   implications of the use of wireless and wired networks      role of the Domain Name Service (DNS).
                                                  Part 1: Chapter 2: Communication and networking technologies




2.01 The evolution of the purpose and benefits of networking
Wide area network (WAN)
During the 1970s it would be normal for a large organisation to have a computer. This
computer would be a mainframe or minicomputer. The computer could have been running a
time-sharing operating system with individual users accessing the computer using a terminal
connected to the computer with a cable. Technology was developed that allowed computers
in different organisations to be networked using what would now be described as a wide area
network (WAN). In a WAN, the networked computers could be thousands of kilometres apart.

The benefits of having the computers connected by a WAN were:

e   a‘job’ could be run on a remote computer that had the required application software
e   adata archive that was stored on a remote computer could be accessed

e   amessage could be transmitted electronically to a user on a remote computer.


Today, a typical WAN is characterised by the following.

e   it will be used by an organisation ora company to connect sites or branches.

e   |t will not be owned by the organisation or company.

e   |twillbe leased froma public switched telephone network company (PSTN).

e   Adedicated communication link will be provided by the PSTN.

e   The transmission medium will be fibre-optic cable.

e   Transmission within the WAN will be from switch to switch.

e   Aswitch will connect the WAN to each site.

e   There will not be any end-systems connected directly to the WAN.


Local area network (LAN)
In the 1980s the arrival of the microcomputer or personal computer (PC) changed computing.
In an organisation, a user could have their own computer on their desk. The computer could
be a stand-alone system or some organisations chose to have more than one computer
connected using a local area network (LAN). It was called a local area network because it
typically connected PCs that were in one room or in one building or on one site.


    KEY TERMS




The benefits of connecting PCs in a LAN included the following.

e   The expense of installing application software on each individual PC could be saved by
    installing the software on an application server attached to the LAN instead.

e   A file server could be attached to the LAN that allowed users to store larger files and also
    allowed files to be shared between users.

e   Instead of   supplying individual printers to be connected to a user’s PC, one or more
    printers could be attached to a print server that was connected to the LAN; these could
    be higher quality printers.
Cambridge International AS & A Level Computer Science




e   Managers in organisations could use electronic mail to communicate with staff rather
    than sending round memos on paper.

e   The ‘paper-less office’ became a possibility, where files were to be stored in digital form
    on a file server rather than as paper copies in a filing cabinet.

Today, a typical LAN is characterised by the following.

e   |t will be used by an organisation or a company within a site or branch.

e   |t will be owned by the organisation or company.

e   |t will be one of many individual LANS at one site.

e   The transmission medium will be twisted pair cable or WiFi.

e   TheLAN will contain a device that allows connection to other networks.

e   There will be end-systems connected which will be user systems or servers.


Discussion Point:
Ifa print server was attached to a network, what functionality could it provide?


Internet working
The 1990s can be said to be when the modern era of computing and network use started, with
the beginning of widespread use of the Internet. The word Internet is a shortened form of the
term ‘internetwork’, which describes a number of networks all connected together. LANs are
connected to WANs which are in turn connected to the Internet to allow access to resources
world-wide. The other technologies defining the modern era, namely mobile devices and
wireless networking, started to become commonly used in the 2000s.

The purpose and benefits of networking have not changed but their scale and scope has increased
enormously. In particular, people now have full access to networks from their personal devices.


The client-server model
The client-server model (or architecture) was first used in large organisations when they
had installed internal networks. Typically, the organisation would have individual LANs
connected via an organisation-wide WAN. An individual LAN might have had an application
server attached. The organisation was likely to need a powerful central computer. The central
computer could be connected to the WAN as aserver. It would probably not have individual
users connected to it directly. A PC, attached to a LAN, could access the server as a client.

The client-server mode of operation nowadays is different. The client is a web browser
connected to the Internet. The server is a web server hosted on the Internet.

The server provides an application and the client uses the application. There are two options
for how the client functions.

A thin-client is one which:

e   chooses an application to run on the server

e   sends input data to the server when requested by the application

e   receives output from the application.


——EEEe
    Client-server: an architecture where a client runs an application provided by a server
                                                                                         on a network

    Thin-client: a client that only provides input and receives output from the application
                                                       Part 1: Chapter 2: Communication and networking technologies




A thick-client is one which:

e   chooses an application provided by the server

¢   possibly carries out some processing before running the application on the server and
    also after receiving output from the application

¢   alternatively, possibly downloads the application from the server and runs the application itself.




    TIP

    In thick-client mode the processing on the client can be controlled by the use of a scripting
    language. You do not need to know any details of this.




    KEY TERM




The client-server approach is the choice in the following circumstances.

e   The server stores a database which is accessed from the client system.

e   Theserver stores a web application which allows the client system to find or, sometimes,
    supply information.

e   The server stores a web application which allows the client system to carry out an
    e-commerce orfinancial transaction.


File sharing
ifa user uploads files to a file server then the client-server operation can be used by another
user to download these from the server.

An alternative mode of operation for sharing files is peer-to-peer networking. Instead of having
one server that many clients access, a peer-to-peer network operates with each peer (networked
computer) storing some ofthe files. Each peer can therefore act as a client and request a file
from another peer or it can act as a server when another peer requests the download of a file.

The peer-to-peer model has several advantages compared to client-server file downloading:

¢   it avoids the possibility of congestion on the network when many clients are
    simultaneously attempting to download files

¢   parts ofa   file can be downloaded separately

e   theparts are available from more than one host.

The client-server model has the following advantages.

e   |tallows an organisation to control the downloading and use of files.

e   The files can be better protected from malware attacks because the files are stored on
    one server which will be regularly scanned using appropriate anti-virus software.



2.02 Network topologies
There are five requirements for a data communications system: a sender, a receiver, a
transmission medium, a message and a protocol (see Chapter 17 for details about protocols).
A transmission medium can be air (e.g. for WiFi) or cables (e.g. for Ethernet). Data can be sent
through the medium in different modes:
Cambridge International AS & A Level Computer Science




e    simplex mode where data flow is one-way only

     half duplex where data can flow either way but not simultaneously

     full duplex where simultaneous both-ways data flow is possible.


A ‘message’ is any type of data, which can be sent as either:

e    a broadcast, which is a one-to-all communication (as used traditionally for radio and television)

e    amulticast, which is from one source to many destinations

e    aunicast, which isa one-to-one communication.

A data communications system may consist of a single isolated network. There are several
possibilities for the topology of an isolated network. The simplest of these is where two
systems are connected by a network link as shown in Figure 2.01. This is an example of a
point-to-point connection, which is a dedicated link. Transmission might be simplex or
duplex and a message can only be unicast.




Figure 2.01 A point-to-point network


Early LAN topologies used either a ring or a bus topology. We don’t need to cover the ring
topology as it is not used very often now. A bus topology has only one link but it is shared
by    anumber of end-systems and is therefore described as a multi-point connection. The
configuration is shown in Figure 2.02. There is no direct connection between any pair of end-
systems. A message must therefore be broadcast even though it might only be intended for
one end-system. The topology is resilient because a fault in an end-system or in the link to it
does not affect the use of the network by the other end-systems.




=

Figure 2.02 A bus network


An example of a fully-connected mesh topology is shown in Figure 2.03. In this
configuration, each end-system has a point-to-point connection to each ofthe other end-
systems. Transmission is duplex; messages might be unicast, multicast or broadcast.


Qa a
     Topology: the configuration of a network that defines how the various devices on the network are
     connected

     Bus topology: contains one shared link to which all devices are attached

     End-system: a computer or server connected to a network

     Mesh topology: contains direct links between devices
                                                  Part 1: Chapter 2: Communication and networking technologies




Figure 2.03 A mesh network.

Figure 2.03 shows end-systems connected in a mesh topology but this is unrealistic because
of the amount of cabling required. A mesh topology can be used when individual LAN
switches are connected in a network. The topology is essential for the connection of routers
within the infrastructure of the Internet.

The final possibility is a star topology which is shown in Figure 2.04.




Figure 2.04 could have been drawn so that it looked like a star but has been drawn to show
the physical configuration that is used in a real life installation. In a star topology, each end-
system has a point-to-point connection to the central device. Transmission is duplex and
messages from the central device might be unicast, multicast or broadcast. As with the bus
topology, the failure of an end-system, or its link, leaves the other end-systems unaffected.
However, the central device must not fail.

In the bus topology most of the end-systems might be user workstations and the others
are servers. However, in the star topology, the end-systems might be user workstations
or servers but the central device is different. It is a specialised device with the purpose of
connecting other devices in the network. Currently, the star topology is the usual way to
configure a network. There are several reasons for this. The most important is that the
central device can be used to connect the network to other networks and, in particular, to
the Internet.
Cambridge International AS & A Level Computer Science




Discussion Point:
Which network topologies have you used? You might wish to defer this discussion until you
have read about network devices later in this chapter.

in a situation where several LANs are connected, they can have different topologies or
supporting technologies. This collection of LANs then becomes a hybrid network. A special
connecting device is needed to ensure that the hybrid network is fully functional. Itis often
an advantage to be able to connect a new topology LAN to existing LANs where it is not
sensible or not possible to use the existing topology for the new LAN. An example is when a
wired LAN is already installed but a new wireless LAN is to be connected to it.


——
Er
   Hybrid network: a collection of connected LANs where some of them have different topologies or
   supporting technologies

   Cable: a transmission using copper wire or fibre-optic
   Bandwidth: a measure of the amount of data that can be transmitted per second




2.03 Transmission media
Cable
A network cable can be twisted pair, coaxial orfibre-optic. The twisted pair and coaxial cables
both use copper
            for the transmission medium. In discussing suitability fora given application
there are a numberof factors to consider. One of these is the cost of the cable and connecting
devices. Another is the best bandwidth that can be achieved. The bandwidth governs the
possible data transmission rate. There are then two factors that can cause poor performance:
the likelihood of interference affecting transmitted signals and the extent of attenuation
(deterioration of the signal) when high frequencies are transmitted. These factors will dictate
whether repeaters or amplifiers are needed in transmission lines and how many will be
needed. Table 2.01 shows some comparisons of the different cable types.


                                    | Twisted pair          Coaxial                Fibre-optic
 Cost                                Lowest                 Higher                 Highest
 Bandwidth or data rate              Lowest                 Higher                 Much higher
 Attenuation at high frequency       Affected               Most affected          Least affected
 Interference                        Worst affected         Less affected          Least affected
 Need for repeaters                  More often             More often             Less often

Table 2.01 Comparisons between cable types

You need to understand that for each of the three types of cabling there are defined
standards for different grades of cable which must be considered when you decide which
type of cable to use. Fibre-optic cable performs best but costs more than the other kinds.
For a new installation the improved performance of fibre-optic cable is likely to be the
factor that governs your choice. However, where copper cable is already installed the cost of
replacement by fibre-optic cable may not bejustified.
                                                             Part 1: Chapter 2: Communication and networking technologies




Figure 2.05 One cable with four twisted pairs with differing twist rates to reduce interference


Currently, twisted pair cable is normally used to connect telephone handsets to telephone
lines. This type of cable is illustrated in Figure 2.05. It is also the technology of choice for high-
speed local area networks.


Question 2.01
Twisted pair cable can be shielded or unshielded. What are the options for this? How does
shielding affect the use ofthe cable?

Coaxial cable is used extensively by cable television companies and in metropolitan area
networks. It is not usually used for long-distance telephone cabling. Fibre-optic cable is the
technology of choice for long-distance cabling. As shown in Figure 2.06, coaxial cable is not
bundled but a fibre-optic cable contains many individual fibres.



              plastic jacket


                      dielectric insulator




           C. vield
                 centre core                  a                                                                     b



Figure 2.06 (a) Coaxial cable and (b) a bundled fibre-optic cable



Wireless
The alternative to cable is wireless transmission. The three options here are radio,
microwave or infrared. These are all examples of electromagnetic radiation; the only intrinsic
difference between the three types is the frequency of the waves.


   KEY TERM


        @SS.eo dlfansSMISSION
                tra ic   or
                              USING
                               i  OrFat lio,
                                        {    micre
                                               |   5   +   or5 jinfrared
                                                                    } “y {
Cambridge International AS & A Level Computer Science




                                              Radio             Microwave                  Infrared
    Frequency range                         3kHz-3 GHz          3-300GHz                300 GHz-400
                                                                                                 THz


    Bandwidth or data rate




                                                                                                       VY
    Attenuation (mainly due to rain)

    Need for repeaters




                                                                                                       VV
    Directional focusing capability

    Penetration through a wall         <t

    Interference                                         There is no systematic trend


Figure 2.07 Frequency ranges and frequency dependency of factors affecting wireless transmission

When making a choice of which wireless option to use you need to consider all of the same
factors that were discussed when comparing different kinds ofcable. In addition, the ability
of the radiation to transmit through a solid barrier is an important factor. Also, the extent
to which the transmission can be focused in a specific direction needs to be considered.
Figure 2.07 shows the approximate frequency ranges for the three types of radiation. The
factors listed on the left increase in the direction of the arrows. The bandwidth increases
through radio and microwave to infrared but the ability of the waves to penetrate solid
objects is greatest for radio waves. Interference is not consistently affected by the frequency.

The increased attenuation for infrared transmission, which has the highest frequency, means
that it is only suitable for indoor applications. The fact that it will not penetrate through a wall
is then of benefit because the transmission cannot escape and cause unwanted interference
elsewhere. For most applications, microwave transmission is the best option because it has a
better bandwidth compared to that available using radio waves.



Comparing cable and wireless transmission
It is worth noting that cables are often referred to as ‘guided media’ and wireless as ‘unguided
media’. This is slightly misleading because only radio wave transmission fits the description
of unguided. It is possible with microwaves or infrared to direct a transmission towards a
particular receiver (as suggested in Figure 2.07).

There are other points to consider when we compare the relative advantages of transmission
through a cable or wireless transmission.

e     Theuse of certain wireless transmission frequencies is regulated by government agencies
      and so permission has to be obtained before wireless transmission is used.

e     Outside these frequencies, no permission is needed to use the air for transmission but
      cables can only be laid in the ground with the permission of landowners.

e     For global communications, the two competing technologies are: transmission through
      fibre-optic cables laid underground (or on the sea bed) and satellite transmission
      (discussed later in this section).

e     Interference is much more significant for wireless transmission and its extent is
      dependent on which frequencies are being used for different applications.

e     Repeaters are needed less often for wireless transmission.

e     Mobile (cell) phones now dominate Internet use and for these, only wireless transmission
      is possible.

e     Forhome or small office use, wired or wireless transmission is equally efficient; often, not
      having to install cables favours wireless connections for a small network.
                                                  Part 1: Chapter 2: Communication and networking technologies




Satellites are components of modern communication systems. Figure 2.08 shows the
altitudes (distances above Earth) ofthree different types ofsatellite. The Van Allen belts are
areas containing high levels of electrically charged particles, which interfere with satellites.

                A
Altitude (km)

      35786         K         F#       #K            GEO


                      Upper Van Allen belt
      15000
                    K         SK       §             MEO

                      Lower Van Allen belt
       5000
                    K         SF       K             LEO


Figure 2.08 Satellite altitudes

The highest altitude satellites are in geostationary Earth orbit (GEO) over the equator and
these are used to provide long-distance telephone and computer network communication.
‘Geostationary’ means that the satellite orbits at the same speed as the Earth spins, so from
a point on the Earth the satellite always appears to be at the same point in the sky. Only three
GEO satellites are needed for full global coverage. Closer to Earth are a group of medium-
Earth-orbit (MEO) satellites some of which provide the global positioning system (GPS). Ten
MEO satellites are needed for global coverage. Finally, low-Earth-orbit (LEO) satellites work in
‘constellations’ to supplement the mobile phone networks. Fifty LEO satellites are needed for
full global coverage but currently there are several hundred LEO satellites in orbit.

A satellite can act as a component in a network and can directly connect with ground-based
components. These ground-based components can be much further apart than in a network
with no satellites. The disadvantage of satellites is that the greater transmission distance
causes transmission delays, which can cause technical problems for the network.



  TASK 2.01

  Calculate the approximate time taken for a transmission from the surface of the
   Earth to a medium-Earth-orbit satellite. (Take the speed of light to be 300 000 km
  per second.)



The use of satellites in networks tends to be for specialised applications such as the Global
Positioning System (GPS) or for Internet use in remote locations. At one stage, a lot of Internet
communication was expected to make use of satellites, but the development of high-speed
fibre-optic cabling at relatively low cost has reduced the need for satellites.



2.04 LAN hardware
Wired LANs
In the early years, coaxial cable was used for LANs. Nowadays, twisted pair cables are
probably the most widely used networking connections, and fibre-optic cables are becoming
more common. In a bus configuration the bus will consist ofa series of sockets linked by
cables. The ends of the bus have terminators attached that prevent signals from reflecting
 Cambridge International AS & A Level Computer Science




 back down the bus. Each end-system (which is either a user workstation or a server), has
 a short length of cable with an RJ-45 connector at each end. One end is plugged into a bus
 socket and the other end is plugged into the LAN port of the end-system.

 In astar configuration each end-system has the same type of cable with the same connectors
 but the cable tends to be much longer because it has to plug into a socket on the central device.

 A bus can be extended by linking two bus cables using a repeater. A repeater is needed
 because over long distances, signals become attenuated (reduced in strength), making
 communication unreliable. A repeater receives an input signal and generates a new full-
 strength signal. Sometimes a bus network is constructed in what are called segments. Two
 segments are connected using a bridge. The bridge stores the network addresses for the
 end-systems in the two segments it connects.

 The LAN port on an end-system is connected to a Network Interface Card (NIC). The NIC
 is manufactured with a unique network address that is used to identify the end-system in
 which it has been installed. The addressing system is discussed in Chapter 17 (Section 17.05).
  For a star network, the central device might be a hub, a switch or a router. The switch is
 by far the most likely. A switch is a connecting device that can direct a communication to
 a specific end-system. There is discussion of how it functions in Section 2.05. The router is
 discussed later in this chapter and also in Chapter 17.


 Wireless LANs
 WiFi (WLAN in some countries) is a term used to describe wireless Ethernet. Its formal
 description is IEEE 802.11. This is a wireless LAN standard that uses radio frequency
 transmission. The central device in a WiFi LAN is a Wireless Access Point (WAP). This can be
 an end-system in a wired network. The WAP can communicate with an end-system in the WiFi
  LAN provided that the end-system has a Wireless Network Interface Card (WNIC) installed.


CB cer renns
     Server: a system providing a service to end-systems

     Repeater: a device that connects two cables and provides a full-strength signal to the second cable
     Bridge: a device that connects two segments of a LAN

     Network Interface Card (NIC): a component used to identify the end-system

     Switch: a connecting device that can send a unicast message

     Wireless Access Point (WAP): the connecting device in a WiFi LAN

     Wireless Network Interface Card (WNIC): provides the NIC function in a WiFi LAN




 2.05 Ethernet
  Ethernet is one of the two dominant technologies in the modern networked world. It is
  primarily focused on LANs. Although Ethernet was first devised in the 1970s independently
  of any organisation, it was later adopted for standardisation by the Institute of Electrical and
  Electronics Engineers (IEEE). In particular it was their 802 committee that took responsibility
 for the development of the protocol. The standard for a wired network is denoted as IEEE
 802.3 which is sometimes used as an alternative name for Ethernet. The standard has so far
  evolved through five generations: standard ortraditional, fast, gigabit, 10 gigabit and 100
  gigabit. The gigabit part of the name indicates its data transfer speed capability.

  Original (or‘legacy’) Ethernet was implemented on a LAN configured either as a bus or as a
 star with a hub as the central device. In either topology, a transmission was broadcast type.
 Any message would be made available to all of the end-systems without any controlled
                                                                .
                                                                                                                      |.
cornmunication exchange between any pair of end-systems. For each message received an
end-system had to check the destination address defined in the message
                                                                    to see if it was the
intended recipient.

The use ofa shared medium for message transmission has the potential for messages                           to be
corrupted curing transmission. If two enc-systerns were to transmit messages at the same
time there would be whatis described as
                                      a ‘collision’. This is when the voltages associated
with the transmission interferewith each ner eee coruption ofthe individual                                messages
The method adopted for dealing with this was                      CSMA/CD (carriersense multiple access with
collision detection). This relied on thefact that if a message was neing transmitted there was
a voltage level on the Ethernet cable which could be detected by an end-system.

The transmitter uses the following procedure.

     Check the voltage on the transmission medium.
ks




      i this indicates activity, waita random time before checking again.
HN




      no activity is detected, start transmission.
W




     Continuously check for a callision,
&
wm




      ifno collision is detected, continue transmission,

      a collision is detected,                 stop transrnission of the message and
                                                                                   transmit a jamming signal
&S




     to warn all enc-stations; alter arandam time, try again.

Although there might be some legacy Ethernet LANs still operating,                    modern Ethernet is
switched. The star configuration has a switchas the central device. 1ihe switchcontrols
transmission to specific end-systems. Eachend-system is connected to the switch by
                                                                                 a tull-                               ces
cuplex link, So no collisionis possible alongthat link. Becausethere might be high levels of                           —
activity
    the switch needsto beable
                           to store an incoming message                               a buffer until the cable
                                                                                                             is        =
free for
       the transmission totakeplace. Since collisions are now impossible, CSMA/CDis no longer
needed, Some further detalis concerning Ethernetare provided
                                                           in Chapter 17 (Section17.04),




a    ey, art ar       £   the tte        as = : Fe Js he Beate see athe
 f   Fs,     & Pees SEs             oes ob ee Seo eit es gees setts



To describe the Internet as a WANpays little attention to its size and complexity. The Internet
is the biggestinternetworkin existence. Furthermore, it has never been designed as4 single
‘whole’ it hasjust evolved to reach
                                  its current form and is still evolving towards whatever
futureform it will take,
A               : oes           o         Ky        gage asad
PERLE PRR QP WEL RNA
                 PP MAay      Leds
B set ox ots ostkeEY ass ye    SS          Sanne   FES   PRS
RS ESYERY NERY MSRP OSE
                     FEOE ERR PERS



One of the consequences of the Internet not having been designedisthat there
                                                                          is no agreed
cefinition
       of its structure. However, there is a hierarchical
                                                     aspect to the structure (meaning
thatthere are severaldistinct ‘levels’ withinthestructure). For exarnple, the initial function of
an internet Service Provider (SP) was to give Internet access to an individual or company. This
function is now performed by what we can call an ‘access ISP’. These access ISPs thenconnectc
vnat we can cali ‘miccle tier’ or regional ISPs, wich in turn are connected to ter1 (or ‘back sone’
ISPs, An ISP is2 networkand connections between                   iSPs   are handied by Internet Excnange Paints
UXPs), The tier 1 iSPs are atthe top ofthe Nerarchy, sorne ith maior internet content providers,
Cambridge International AS & A Level Computer Science




Router
We can also think of the Internet in terms of the connections that carry the most traffic,
which consist of a set offibre-optic cables laid under the sea and across land, which can be
described as a ‘mesh’ structure. This mesh of cables contains many points where the cables
connect together, which we call nodes. At every node is a device called the router. Routers
are found not only in the general ‘mesh’ ofthe Internet but also within the ISP networks. Each
router is connected to several other routers and its function is to choose the best route for a
transmission. The details of how a router works are discussed in Chapter 17 (Section 17.05).


ee
   Router: a device that acts as a node on the Internet




Question 2.02
How near are you to an under-the-sea Internet fibre-optic cable?


Public switched telephone network (PSTN)
Communication systems that were not originally designed for computer networking provide
significant infrastructure support for the Internet. The longest standing example is what is
often referred to as POTS (plain old telephone service) but is more formally described as
a PSTN (public switched telephone network). There is some discussion about how PSTNs
provide that support in Chapter 17. During the early years of networking the telephone
network carried analogue voice data. However, digital data could be transmitted provided
that a modem was used to convert the digital data to analogue signals. Another modem
was used to reverse the process at the receiving end. Such so-called ‘dial-up’ connections
provided modest-speed, shared access when required. However, an organisation could
instead pay for a leased line service that provided a dedicated, permanently connected link
with guaranteed transmission speed. Typically, organisations made use of leased lines to
establish WANs (or possibly MANs (metropolitan area networks).

More recently, the PSTNs have upgraded their main communication lines to fibre-optic cable
employing digital technology. This has allowed them to offer improved leased line services
to ISPs but has also given them the opportunity to provide their own ISP services. In this role
they provide two types of service. The first is a broadband network connection for traditional
network access. The second is WiFi hotspot technology, where an access point as described
in Section 2.04 has a connection to a wired network providing Internet access.


Cell phone network
For users of devices with mobile (cell) phone capability there is an alternative method for
gaining Internet access. This is provided by mobile phone companies acting as ISPs. The mobile
phone, equipped with the appropriate software, communicates with a standard cell tower
                                                                                     to
access the wireless telephone network, which in turn provides a connection to the Internet.


2.07 Applications that make use of the Internet
The World Wide Web (WWW)
It is common practice to talk about ‘using the web’ or ‘using the Internet’ as though these
were just two different ways of saying the same thing. This is not true. The Internet is, as
has been described above, an Internetwork. By contrast, the World Wide Web (WWW) is a
distributed application which is available on the Internet.
                                                         Part 1: Chapter 2: Communication and networking technologies




Specifically, the web consists of an enormous collection of websites each having one or more
web pages. The special feature of a web page is that it can contain hyperlinks which, when
clicked, give direct and essentially immediate access to other web pages.



Cloud computing
Cloud computing is the provision of computing services usually via the Internet. An
organisation may choose to establish its own private cloud. In this case there are three
possible approaches:

e   The organisation takes full responsibility for creating and managing the cloud installed
    on-site and connected to a private network

e   The organisation outsources to a third-party
                                              the creation and management of an on-site
    installation connected to a private network

e   Theorganisation outsources the creation and management of an Internet accessible
    system by a third-party.

The alternative is a public cloud. This is created, managed and owned by a third-party cloud
service provider.

The services provided by a cloud are familiar ones provided by file servers and application
servers. They are accessible via a browser and therefore accessible from any suitable device
in any location. A public cloud can be accessed by an individual user or by an organisation.
One major difference is the scale of the systems. The provision is established using large
mainframe computers or server farms. The services provided can be characterised as
being one of:

e   infrastructure provision

e   platform provision

e   software provision

Many ofthe advantages to a cloud user arise from the fact that the cloud does not have
the limitations that the systems already available have. For the infrastructure provision,
the advantages include the better performance when running software and the increased
storage capacity. For the platform provision, the cloud can offer facilities for software
development and testing. For the software provision, the cloud will be able to run
applications that require high performance systems. Alternatively, it could be that the costs
to a company of buying and installing a software package themselves would be far too high.
The other advantage is the familiar one with regard to outsourcing. The cloud user no longer
needs technical expertise.

The disadvantages to a cloud user relate to the use of a public cloud. The cloud service
provider has complete access to all of the data stored on the cloud. The cloud user cannot
be sure that their data is not being shared with third-parties. This is a concern with regard to
data privacy. The security of the data stored is an issue; the cloud service provider is being
relied on to ensure data cannot be lost.


    KEY TERMS


    Private   loud:   owner   by and   Ol rL\ accesse\
Cambridge International AS & A Level Computer Science




Bit streaming
Streaming media make use of the Internet for leisure activities like listening to music or
watching a video. But what is a ‘bit stream’? In general, before data is transmitted it is stored in
bytes which can be transmitted one after the other as a ‘byte stream’. Because of the file sizes
involved, streamed media is always compressed to a sequence of bits - a ‘bit stream’. Generic
compression techniques mentioned in Chapter 1 (Section 1.07) can convert the byte stream
to a bit stream with fewer bits overall. For the decoding process at the receiver end to work
properly, the data must be transferred as a bit stream.

For one category of streaming media, the source is a website that has the media already
stored. One option in this case is for the user to download a file then listen to it or watch it at
some future convenient time. However, when the user does not wish to wait that long there
is the streaming option. This option is described as viewing or listening on demand. In this
case the delivery of the media and the playing of the media are two separate processes. The
incoming media data are received into a buffer created on the user’s computer. The user’s
machine has media player software that takes the media data from the buffer and plays it.

The other category of streaming media is real-time or live transmission. In this case the
content is being generated as it is being delivered such as when viewing a sporting event. At
the receiver end the technology is the same as before. The major problem is at the delivery
end because a very large number of users may be watching simultaneously. The way this is
managed now is to transmit the media initially to a large number of content provider servers
which then transmit onwards to individual users.

A crucial point with media streaming is whether the technology has sufficient power to
 provide a satisfactory user experience. When the media is created it is the intention that
the media is to be delivered to the user at precisely the same speed as used for its creation;
a song that lasted four minutes when sung for the recording would sound very peculiar if,
when it is received by a user, it lasts six minutes. The process of delivering the content is
determined by the bit rate. For example, a relatively poor-quality video can be delivered
at a bit rate of 300 kbps but a reasonably good-quality audio file only requires delivery at
    128 kbps. Figure 2.09 shows a simple schematic diagram of the components involved in
the streaming.
    ee                                                               1
|




                                                                      ! Control data
|                   woo nemececeneneanecseccessrrrrss wrrnnennee prrmoreecesscces >         Media
if      Media        \¢                     '    Buffer}         Ley                        server
|       player            Data flow                                   i;   Data flow
|                                        High-          Low-
|                                       water          water          i
|                                        mark           mark          i
|                                                                    4
                            User's computer


    Figure 2.09 Schematic diagram of bit streaming




       On-demand: when the bit stream content is transmitted at a time chosen by the user

       Real-time: when the bit stream content is transmitted as it is produced

       Bit rate: the number of bits transmitted per second
                                                         Part 1: Chapter 2: Communication and networking technologies




The buffer must deliver the data to the user, at the correct bit rate for the media being used.
Data which is sent into the buffer should be sent at a higher rate to allow for unexpected
delays. The media player continuously monitors how full the buffer is and controls the bit
rate in relation to the defined high- and low-water marks. It is essential to have a buffer size
that is sufficiently large for it never to get filled.

The rate of transmission to the buffer is limited by the bandwidth of the network
connection. For a connection via a PSTN, a broadband link is essential. For good-quality
movie presentation the broadband requirement is about 2.5 Mbps. Because this will not
be available for all users it is often the practice that an individual video is made available
at different levels of compression. The most highly compressed version will be the poorest
quality but the bit rate may be sufficiently low for a reasonable presentation with a relatively
low bandwidth Internet connection.



  TASK 2.02

   Consider a bit-streaming scenario for a video where the following values apply:

   e   the buffer size is 1 MiB
   e   the low-water mark is set at 100 KiB

   e   the high-water mark is set at 900 KiB
   e   the incoming data rate is 1 Mbps

   e   the video display rate is 300 Kbps.
  Assume that the video is playing and that the buffer content has dropped to the low-
  water mark. The media player sets the controls for data input to begin again.

   Calculate the amount of data that will be input to the buffer in two seconds and the
   amount of data that will be removed from the buffer in the same time period.
   Repeat the calculation for 4, 6, 8, 10 and 12 seconds.
   From this data, estimate when the buffer will have filled up to the high-water mark.
  Assuming that the incoming transmission is halted at this time, calculate how long it
  will be before the buffer content has again fallen to the low-water mark level.




2.08 IP addressing
The Internet requires technical protocols to function. A protocol suite called TCP/IP is used as
a standard (see Chapter 17). One aspect of this is IP addressing, which is used to define from
where and to where data is being transmitted.



IPv4 addressing
Currently the Internet uses Internet Protocol version 4 (iPv4) addressing. IPv4 was devised
in the late 1970s, before the invention of the PC and the mobile phone. |Pv4 provides for a
large but limited number of addresses for devices, which is no longer enough to cover all the
devices expected to use the Internet in future.

The IPv4 addressing scheme is based on 32 bits (four bytes) being used to define an IPv4
address. It is worth putting this into context. The 32 bits allow 2°? different addresses. For
big numbers like this it is worth remembering that 2!° is approximately 1000 in denary so the


Qa
   IPv4 address: a 32-bit long, hierarchical address of a device on the Internet
Cambridge International AS & A Level Computer Science




32 bits provide for approximately four billion addresses. The population of the world is about
seven billion and it is estimated that approaching half
                                                     of the world’s population has Internet
access. From this we can see that if there was a need to supply one IP address per Internet
user the scheme would just about be adequate. However, things are not that simple.

The original addressing scheme was designed on the basis of a hierarchical address with
a group of bits defining a network (a netID) and another group of bits defining a host on
that network (a hostID). The aim was to assign a unique, universally recognised address for
each device on the Internet. The separation into two parts allows the initial transmission
to be routed according
                    to the netID. The hostID only needs to be examined on arrival at
the identified network. Before proceeding, it is important to note that the term ‘host’ is a
little misleading because some devices, particularly routers, have more than one network
interface and each interface requires a different IP address.

The other feature of the original scheme was that allocated addresses were based on the
concept of different classes of networks. There were five classes; we are going to look at the
first three classes. The structures used for the addresses are shown in Table 2.02.


 Class         Class identifier      Number of bits for netID       Number of bits for hostID

 Class A                0                          7                             24

 Class B               10                         14                             16

 Class C              110                         21                              8


Table 2.02 Address structure for three classes of IPv4 address


It can be seen from Table 2.02 that the most significant bit or bits identify the class. A group of
the next most significant bits define the netID and the remaining, least significant, bits define
the hostiD. The reasoning behind this was straightforward. The largest organisations would
be allocated to Class A. There could only be 2’ i.e. 128 of these but there could be 2” distinct
hosts for each of them. This compared with 22! (approximately two million) organisations that
could be allocated to Class C but each of these could only support 2° i.e. 256 hosts.

The problems with this scheme arose once LANs supporting PCs became commonplace.
The numberof Class B netIDs available was insufficient but if organisations were allocated to
Class C the number of hostiDs available was too small. There have been a number of different
modifications made available to solve this problem.

Before considering some of these, the representation used for an IP address needs to be
introduced. During transmission, the technology is based on the 32-bit binary code for the
address; to make it simpler for users, we write the address using decimal numbers separated
by dots. Each byte is written as the denary equivalent of the binary number represented by
the binary code. For example, the 32 bit code:

         10000000   00001100   00000010   00011110


is written in dotted decimal notation as:

                                            128.12.2.30




Discussion Point:
There were options available when the dotted decimal notation was chosen. Can you
identify these?
                                                   Part 1: Chapter 2: Communication and networking technologies




Classless inter-domain routing (CIDR)
The first approach developed for improving the addressing scheme is called ‘classless
inter-domain routing’ (CIDR). This retains the concept ofa netiD and a hostiD but removes
the rigid structure and allows the split between the netID and the hostID to be varied to
suit individual need. The simple method used to achieve this is to add an 8-bit suffix to the
address that specifies the number of bits for the netiD. If, for instance, we define the suffix as
21, that means that 21 bits are used for the netID and there are 11 bits remaining (ofa 32-bit
address) to specify hostIDs allowing 2TM (i.e. 2048) hosts. One example of an IP address using
this scheme is shown in Figure 2.10. The 21 bits representing the netID have been highlighted.
The remaining 11 bits represent the hostiD which would therefore have the binary value
11000001110.


Binary code:       [100007100007700000001 1000001110/00010101
                             Y¥                                Y


                            netID                            suffix

Dotted decimal notation: 195.12.6.14/21

Figure 2.10 A CIDR IPv4 address


Note that with this scheme there is no longer any need to use the most significant bit or bits
to define the class. However, it does allow already existing Class A, B or C addresses to be
used with suffixes 8, 16 or 24, respectively.



   TASK 2.03

   Create an example of the binary code for a Class C address expressed in CIDR
   format. Give the corresponding dotted decimal representation.




Sub-netting
Sub-netting is a different approach. It allows a more efficient use of a hostiD by applying a
structure to it.

To illustrate an example of this we can consider a medium-sized organisation with about
150 employees each with their own computer workstation. Let’s assume that there are
six individual department LANs and one head-office LAN. Figure 2.11 shows a schematic
diagram of how the LANs would be connected to the Internet if the original scheme were
used. Note that the diagram has been simplified by showing the LANs connected to a
gateway. This is a device that connects networks with different protocols. For the connection
to the Internet the gateway would either first connect to a router or have the capability to act
as a router itself.

The organisation would need seven individual Class C netiDs; one for each LAN. Each of these
would point to one of the LAN gateways. The netiD for each LAN would be identified by the
first 24 bits of the IPv4 address, leaving 8 bits for the hostID. This would mean 256 individual
codes for identifying different workstations on just one LAN. For the seven LANs the total
number
  of workstations that could be identified would be:

                                           256 x   7= 1792

Since the organisation only has 150 workstations in total, there are 1642 unused addresses.
Not only would these be unused they would be unavailable for use by any other organisation.
Cambridge International AS & A Level Computer Science




                         7 [ena]              >        reagonce




                           + [Eateway)
                            —_—§+[Eenay]
                            $+ [fateway
                           | __» [Gateway
                        ——>| Gateway                     LAN 5 |
                                 >| Gateway |—| LAN 6

Figure 2.11 Connecting LANs using the original classful IPv4 scheme


The sub-netting solution for this organisation would require allocating just one Class C netID.
For example, the IP addresses allocated might be 194.10.9.0 to 194.10.9.255 where the net|D
comprises the first three bytes, represented by the decimal values 194, 10 and 9.

The sub-netting now works by having a defined structure for the 256 codes constituting
the hostID. A sensible solution for this organisation is to use the top three bits as a code for
the individual LANs and the remaining five bits as codes for the individual workstations.
Figure 2.12 shows a schematic diagram of this arrangement.


                                                             Head
                                                           office LAN
                                          // ||\s

                                                              LAN 1


                                                              LAN 2


                                                             LAN 3
                                 Router

                                                              LAN 4


                                                           LAN 5


                                                         LAN 6


Figure 2.12 Connecting LANs using sub-netting


On the Internet, all of the allocated IP addresses have a netiD pointing to the router.
The router then has to interpret the hostID to direct the transmission to the appropriate
workstations on one of the LANS via a gateway. Examples of workstation identification:

e   hostlD code 00001110 would be the address for workstation 14 on the head office LAN 0 (LAN 000)

e   hostlD code 01110000 would be the address for workstation 16 on LAN 3 (LAN 011).

With 150 workstations the organisation hasn’t used all of the 256 allocated IP addresses.
However, there are only 106 unused which is a reasonable number
                                                              to have available in case
of future expansion. Only one netiD has been used leaving the other six that might have been
used still available for other organisations to use.
                                                   Part 1: Chapter 2: Communication and networking technologies




Network address translation (NAT)
The final scheme to be considered is different in that it deviates from the principle that every
IP address should be unique. In this scheme, provision has been made for large organisations
to have private networks (intranets) which use the same protocols as those used for the
Internet. One justification for using a private network has always been that this provides
extra security because ofthe isolation from the Internet. However, this is no longer normal
practice. Organisations want private networks but they also want Internet connectivity.

The solution for dealing with the addressing is to use network address translation (NAT).
Figure 2.13 shows a schematic diagram of how this can be used.




                         «<
                                       NAT
                                       box     <
                                                                              <>
                                                              Internal router -——>

                                                                              ST


Figure 2.13 An intranet connected to the Internet using a NAT box


The NAT box has one IP address which is visible over the Internet and so can be used as a
sending address or as a receiving address. Internally the IP addresses have to be chosen from
one ofthe three ranges of IP addresses shown in Table 2.03 that have been allocated for such
networks. (You do not need to remember these numbers!)


 Lower bound                                       | Upper bound
 10.0.0.0                                           10.255.255.255

 172.16.0.0                                         172.31.255.255


 192.168.0.0                                        192.168.255.255



Table 2.03 IPv4 addresses to be used in private networks


The important point is that each address can be simultaneously used by any number of
different private networks. There is no knowledge of such use on the Internet itself
                                                                                  or in
any other private network. The interface in the NAT box has software installed to examine
each incoming or outgoing transmission. There can be a security check before an incoming
transmission is directed to the correct internal address. The diagram shows undefined
arrows from the router connected to the NAT box. These indicate that the network structure
within the organisation could take many different forms.



Static and dynamic IP addresses
As discussed in Section 2.06, when a user wishes to have a connection to the Internet the
connection is handled by an Internet Service Provider. The ISP will have available a large
number of hostiDs. However, the number of users that the ISP is supporting could very likely
be larger than the total number of addresses available. Fortunately for the ISP and for an
individual user many of these potential users will not be engaged in Internet interaction.
         Cambridge International AS & A Level Computer Science




         The normal practice is for the ISP to create a ‘dynamic address’ for a user. This is one that the
         ISP is free to change if it suits but more importantly the address is available for re-allocation
         once a user disconnects from the Internet. The alternative is a ‘static address’ which never
         changes and can be provided if a user is prepared to pay an extra charge.


         Discussion Point:
         Can you find out which IP addressing scheme is being used when you are connected to the
         Internet?



         IPv6 addressing
         Today there are combinations of IPv4 approaches in use and these allow the Internet
         to continue to function. Respected sources argue that this cannot continue beyond the
         current decade. There must soon be a migration to IP version 6 (IPv6), which uses a 128-
         bit addressing scheme allowing 2!” different addresses, a huge number! In practice, this
         will allow more complex structuring of addresses. Documenting these addresses is
         going to be difficult. The addresses are written in a colon hexadecimal notation. The
         code is broken into 16-bit parts, with each part represented by four hexadecimal
         characters. Fortunately, some abbreviations are allowed. A few examples are given in
         Table 2.04.




          68E6:7C48:FFFE:FFFF:3D20:1180:695A:FFO1              A full address

ss 72E6::CFFE:3D20:1180:295A:FFO1                              0000:0000: has been replaced by :
          6C48:23:FFFE:FFFF:3D20:1180:95A:FFO1                 Leading zeros omitted

          192.31.20.46                                         An IPv4 address used in IPv6


         Table 2.04 Some examples of IPv6 addresses


         Extension Question 2.01

         If |IPv6 addressing is used, how many addresses would be available per square metre ofthe
         Earth’s surface? Do you think there will be enough to go round?



         2.09 Domain names
         In everyday use of the Internet, a user needs to identify a particular web page or email box. As
         users, we would much prefer not to identify each IP address using its dotted decimal value!
         To get round this problem the domain name service (DNS, also known as domain name
         system) was invented in 1983. The DNS service allocates readable domain names for Internet
         hosts and provides a system for finding the IP address for an individual domain name.


       Qa
            Domain name service (DNS): a hierarchical distributed database installed on domain name servers
            that is responsible for mapping a domain name to an IP address. Also known as domain name system.
The system is set up as a hierarchical distributed database which is installed on a large
number of domain name servers covering the whole ofthe Internet. The domain name
servers are connected in a hierarchy, with powerful root servers at the top of the hierarchy
supporting the whole Internet. The root servers are replicated, meaning that multiple copies
of all their data are kept at all times. DNS name space is then divided into non-overlapping
zones. Each zone has a primary name server with the database stored on it. Secondary
servers get information from this primary server.

As a result, the naming system is hierarchical. There are more than 250 top-level domains
which are either generic (e.g. .com, .edu, and .gov) or represent countries (e.g. .uk and .nl).

The domain name is included in a universal resource locator (URL), which identifies a web
page, or an email address. A domain is named by the path upward from it. For example, .eng.
cisco.com. refers to the .eng subdomain in the .cisco domain of the .com top-level domain.

Looking up a domain name to find an IP address is called ‘name resolution’. For such a query
there are three possible outcomes.

e   lf the domain is under the control of the server to which the query is sent then an
    authoritative and correct IP address is returned.

e   |fthe domain is not under the control of the server, an IP address can still be returned if it
    is stored in a cache of recently requested addresses but it might be out ofdate.

e   |fthe domain in the query is remote then the query is sent to a root server which can
    provide an address for the name server of the appropriate top-level domain. This in turn
    can provide the address for the name server in the next lower domain. This continues
    until the query reaches a name server that can provide an authoritative IP address.


Reflection Point:
In several places you have been asked to carry out some research. Are you using the most
efficient search methods? Specifically, how could they be improved?




        Client-server and peer-to-peer networking are options for file sharing.

        The star topology is the one most commonly used for a LAN.

        The main transmission media are copper (twisted pair, coaxial) cables, fibre-optic cables and wireless
        (radio, microwave, infrared).

    m   Factors to consider when choosing a medium are bandwidth, attenuation, interference and the need for
        repeaters.

    m   CSMA/CD (carrier sense multiple access with collision detection) has been used to detect and avoid
        message collisions in shared media.
        The Internet is the largest internetwork in existence.

        ISPs provide access to the Internet.

        Internet infrastructure is supported by PSTNs and cell phone companies.

        The World Wide Web is a distributed application accessible on the Internet.

        The current Internet addressing scheme is IPv4, with IPv6 a future contender.

        The DNS resolves a domain name to an IP address.
                                                                                               |
ZL   Anew company has been established. It has bought some new premises which consist ofa number of
     buildings on a single site. thas deciced that all of the cormputer workstationsin the differentbuildings
     need to be networked. They are considering waysin which the network might be set up.

          One option they are considering is to use cabling
                                                        for the network and to install it themselves.

          i                    identify the three types of cabling that they might consider.

          ii                 = Explain twe factors, other than cost, that theyneed to consider when choosing


          Another option they are considering is to use wirelesstechnologyfor
                                                                            atleast part of
           the network,

          i                    explain ene optionthat mightbe suitable for wireless networking.

          ii                   identify one acvaritage, other than cost, of using wireless rather than
                               cable networking.
          wees
                 ann»
                        =o




                               identify one disadvantage (other than cost) of using wireless rather than
                               cable networking.

          The final option they are considering is to use the services of a PSTN,

          i                  == Define what a PSTN is or does.

          f=                   Explain howa PSTN could
                                                     provide a networkfor the cornpany.
                                                oT




          The Domain Name system is vitally important for Internet users,
          i                    identify the type of software used by the system and the type of hardware on which
                               the sottware is installed.

          ii                 = identify twe types of application that use the Domain Narne System anc for each give
                               a brief description of how it is used.

          In theclassful |Pv4 addressing scheme, the 32-bit binary code for the address has the
          top (most significant) bit set to Oifit is of class
                                                            A, the top two bitsset to 10 if class          8or
          the top threebits set to 110if class
                                             C. In a document an |Pv4 address has been written
          as 205.124.16.152.
          ans




                               Givethe namefor this notation for aniP address and explain how it relates to the
                               32-bit binary coce.

          ii                 = identify   the class of the address and explain your reason.
                                                                                                                      roan

                                                                                                                         ho




          Hi                 = Explain why an |Pv4 address defines a netlD and a hostib,
                                                                                                                         CO




          If the CIDR schemefor
                             an |Pv4 address is used the
                                                       IP address 205.124.16.152 would be
         written                  as:

                                                                    205.124.16.152/24

         State the binary code for the hostlD in this address, with a reason.
                                                                                                                             (a)




3    Auser watches a video provided by a website that uses on-demand bit streaming.

     Describe
           the measures needed to ensure                         that
                                                                  the video does not periodically pause when it

                                                                                                                      6]
          Describe where orivate IP addresses can be used.

          Explain how it cam be ensured that private and public IP addresses are not used in
         the wrong context.
                                                   Part 1: Chapter 2: Communication and networking technologies




5   a   An|P address has the following value:

                             11.64.255.90

         i      Write the above IP address in hexadecimal.




                                                                                                                   N eS
         ii.    Explain the format of an IP address.

    b    Study the following sentence:

         “When a user enters a URL into their web browser, the DNS service locates the required resource.”

         Explain how a URL and DNS are used to locate a resource.                                                  [4]
                                      Cambridge International AS & A Level Computer Science 9608 paper 12 Q9 June 2015

6   Access to World Wide Web content uses IP addressing.

    a    State what IP stands for.                                                                                 [1]
    b   The following table shows four possible IP addresses.

         Indicate for each IP address whether it is valid or invalid and give a reason.


             Address           Denary/Hexadecimal | Valid or Invalid                 Reason
             3.2A.6AA.BBBB     Hexadecimal


             2.0.255.1         Denary


             6.0.257.6         Denary


             A.78.F4.38        Hexadecimal                                                                         [4]

    c   Describe two differences between public and private IP addresses.                                          [2]
                                      Cambridge International AS &A Level Computer Science 9608 paper 11 Q7 June 2016
                  !        Tot             j/AMMRREORERE

  —         7         Z   Ke     =             APO PERE ERREER                "            —
                                               \           ,     =      “     Z




Hardware

Learning objectives
By the end of this chapter you should be able to:

   show understanding of the need for input, output, primary memory and secondary (including removable) storage

   show understanding of embedded systems

   describe the principal operations of hardware devices

   show understanding ofthe use of buffers

   explain the differences between Random Access Memory (RAM) and Read Only Memory (ROM)

   explain the differences between Static RAM (SRAM) and Dynamic RAM (DRAM)

   explain the difference between Programmable ROM (PROM), Erasable Programmable ROM (EPROM) and Electrically
   Erasable Programmable ROM (EEPROM).
                                                                                                      Part 1: Chapter 3: Hardware




3.01 Overview of computer system hardware functionality
A computer system has to support three major areas of operational capability:

e     the processing of data

e     thestorage of data

e     theinput and output
                      of data.

At the heart of the system the processing of data is carried out by the CPU (Central
Processing Unit). The workings of the CPU are the subject of Chapter
                                                                   5 and will not be
discussed further here.



Data storage
The terminology used in the computer literature to describe components for storing data is
not always consistent. One variation is to distinguish between memory as the component
which the processor can access directly and the (file-) store used for long-term storage. An
alternative is to describe the memory as primary storage and the remainder as secondary
storage.

Whatever names are used, the memory hierarchy is a useful concept when we choose the
components to be used in a computer system for data storage. Figure 3.01 shows a version
of this hierarchy that includes the trends in the important factors that affect our choice. The
factors increase in the direction of the arrow. The register is a component within the CPU that
has the fastest access speed. The cache memory has faster access speed than that of main
memory, particularly when the cache is a built-in part of the CPU chip.


     Component             Category                    Accesstime      Capacity    Size        Cost

     Register              Processor component                                                   Li

     Cache memory          Primary storage


     Main memory


     Hard disk             Secondary storage


     Auxiliary storage
                                                             Vv            Vv


Figure 3.01 Trends in the factors affecting the choice of memory components


Computer users would really like to have a large amount of primary storage that costs little
and allows quick access. This is not possible; the fastest components cost more and have
limited capacity. In practice, the choice made is a compromise. It could be argued that there
is     aneed for secondary storage because the use of primary storage alone would be far too
expensive. However, it is more sensible simply to recognise that long-term storage of data
requires separate dedicated components.

An alternative approach when choosing a storage medium or device is to consider which of
the following applies:

e     itis anintegral part of the system, to which the user cannot normally get access — the
      options here are a hard disk or solid-state drive

e     itis an individual item that can be inserted into a drive which is part of the computer system or
      which can be connected to it- could be a floppy disk, optical disc or magnetic tape cartridge
                                                                                                            |
®             jtisa peripheral device that can be connected to ttye system W nen needed — there are
              many possibilities hereincluding a hard drive, a memory stick ora memory card

e             itis a portable itern that the user can carry around with them forattaching to different
              systems; possibly used tor personal backup
                                                       -usuallya flash memory stick nowadays but
              a floppy disk or optical disc is an alternative

«             itis remote from the system, possibly accessible via a networkcormection; offen                        u
              for backup ~ cloud
                               storage is one option, but others are magnetic tape, RAID(Re                         dun cant
              Arrays of independe                                   r SAN (Storage-Area Network).


PA
SRRce AR                               AS         SEERPs        —
S       Sot   h    on         FBS                     LS
SP es hae ARERR ©




e             hardcopy
                     usinge printer or plotter

e             virtual heacset display

®             aspeaker

»             writing to any of the data storage devices described earlier

e             transmission on a network tink.
                              Bs




        og 4
                                                           ye
              ge
                   ue


                                           wert




                                                  SKS
                                       *
                              wotate




                                       8          SSRs
                       Bewt




                  es

    “    *e       oF
                                                  o




For the input
          of data toa computer systen                                               swing are arnong the options available

»             keyboard or keypad entry by a user

®             user interaction with a screen usingscreen icons or menus; possibly using a pointing
              cevice anapossibly involvingtheuse of a touch screen

®             auserusing a game controller

®             auserusing a scanner


®             auserusinga microphonein tandem with voice recognition sattware

®             reading trom any ofthe storage devices described earlier

»             transmission on a network tink.

Note that input andoutput in a computer system are controlled by an 1/O sub-system. This
handles cata input to or output from the computer system
                                                       as wellas data readfrom or
written to theinternal hard disk or solid-state Crive.




Much of the hardware in Section3.01 relates
                                          to what
                                                we can call a general-purpose computer
system. We also need to consider embedced computer systems because there are mary
rnore ofthesesysterns in use than there are general-purpose systems. Any manufactured
item that has mechanical or electrical parts will almost certainly contain one or more
embeddec systems
An embedded system must still contain a processor, memoryanc an |/O capabslity. If these
are constructed on one chip this
                               is called a microcontroller. For some apr
system will have input and outputsolely associated withthe internal
                                                                 workinos of the host
system, In othercases, perhaps when servinga monitoring or control function, there might
be input from within the system but some output
                                              is provided to the                                         Alternatively, the
embedded systemcan providea full user interface as, for exam ole, |ina mobile phone.
                                                                                               Part 1: Chapter 3: Hardware




The major advantage of embedded systems is that they are special-purpose; possibly
performing only a single function. This function is likely to be required in a wide variety
ofdifferent manufactured products. Mass production of
                                                    an embedded system brings
economies ofscale: the more we make, the cheaper they become. During the early years of
their use, embedded systems had the disadvantage that programming was difficult because
the memory space available to store a program was limited. For this reason, programs
had to be short. In addition, there was the disadvantage that if errors were found following
installation then new chips had to be manufactured and used to replace the faulty ones.
In modern systems these problems are less likely, but a new problem has developed.
Embedded systems are now part of what is called the loT (Internet of Things). More and more
embedded systems are being installed with a network connection. This can greatly improve
the usefulness ofa product, for example by providing information and updates to the owner.
However, this accessibility via a network is a security concern. Embedded systems are less
likely to be protected against unlawful actions than general-purpose systems.


Discussion Point:
How might useful information from an embedded system installed in a domestic appliance
be communicated over a network to the owner ofthe appliance?



3.03 Memory components

   KEY TERMS




The components that make up the main memory of a general-purpose computer system
are called random-access memory (RAM). It is called RAM because any byte ofdata stored
can be accessed without affecting the other bytes stored. Because of this it might have been
better called ‘direct-access memory’. Another possible name would be ‘read—-write memory’
because RAM can be repeatedly read from orwritten to. A key feature of RAM is that it is
volatile, which means that when the computer system is switched off the contents of the
memory are lost.

There are two general types of RAM technology. Dynamic RAM (DRAM) is constructed
from capacitors that leak electricity and therefore need regularly recharging (every few
milliseconds) to maintain the identity of the data stored. Static RAM (SRAM) is constructed
from flip-flops that continue to store data indefinitely while the computer system is switched
on. The circuits and logic for flip-flops are discussed in Chapter 19 (Section 19.02)).

The major difference between the two types of RAM is that DRAM requires fewer electronic
components per bit stored. This means DRAM is cheaper
                                                    to make and has a higher density for
data storage. The major advantage of SRAM is that it provides shorter access time. In a general-
purpose computer system, it is normal practice for main memory to be constructed from
DRAM but for cache memory to be provided by SRAM becauseof the faster access speed. By
contrast, embedded systems that need RAM with only limited capacity often use SRAMfor this.

The second category of memory component is called read-only memory (ROM). Again,
this name does not give a full picture of the characteristics of this type of component. ROM
shares the random-access or direct-access properties of RAM. However, as the name implies it
Cambridge International AS & A Level Computer Science




cannot be written to when in use within the computer system. The other key feature is that the
data in ROM is not lost when the computer system is switched off; the memory is non-volatile.



0   TIP

    The word volatile has several meanings. Try to remember that volatile memory no longer stores
    data when the system is switched off.



ROM has specialised uses for the storage of data or programs that are going to be used
unchanged over and over again. In a general-purpose system the most important use is in
storing the bootstrap program. This is a program that runs immediately when a system is
switched on. There are a number of other uses for ROM in such a system, some of which we
will see later in this book. In addition, ROM is used in many embedded systems.

There are four different types of ROM.

1   Inthe simplest type of ROM the programs or data are installed as part of the manufacturing
    process. If different contents are needed the chip must be replaced.
2   Analternative is Programmable ROM (PROM). The manufacturer of the chip supplies chips
    to asystem builder. The system builder installs the program or data into the chips. This
    allows the system builder to test some samples of programmed chip before committing the
    whole batch to be programmed. As with the simplest type of ROM, the program or data once
    installed cannot be changed.

3   Amoreflexible type of ROM is Erasable PROM (EPROM). The installed data or program can be
    erased (using ultraviolet light) and new data ora new program can be installed. However, this
    reprogramming usually requires the chip to be removed from the circuit.
4   Themost flexible type of ROM is Electrically Erasable PROM (EEPROM). As the name suggests,
    this works in a similar way to EPROM, except an electrical signal can be used to remove
    existing data. This has the major advantage that the chip can remain in the circuit while the
    contents are changed. However, the chip is still used as read-only.


Discussion Point:
Can you find out what memory components are in the computer system you are using and
any details about them such as the type and storage capacity?


Buffers
Whenever data has to be transferred from one part ofacomputer system to another, a
problem occurs if the data can be sent more quickly than it can be received. The solution to
the problem is to use a buffer. Data enters a buffer before being transmitted to its destination.
The buffer functions as a queue so the data emerges in the order that it has entered the buffer.
Typically, the buffer is created in the computer memory.


EEE
    Buffer: a temporary storage created for data transmitted from one part of the system to another which
    functions as a queue




Question 3.01
Can you think of examples of data transfer that would need a buffer?
                                                                                                Part 1: Chapter 3: Hardware




3.04 Secondary storage devices
Before discussing storage devices, we should introduce some terminology. For any hardware
device, whether
              an integral part of the computer system ora connected peripheral, its
operation requires appropriate software to be installed. This software is referred to as the
‘device driver’. This should not be confused with the term ‘drive’ associated specifically with
a storage device. The term ‘drive’ initially referred to the hardware that housed a storage
medium and physically transferred data to it or read data from it. However, as so often
happens, such distinctions are often ignored. As a result, for example, references to a ‘hard
disk’, a ‘hard disk drive’ or to a ‘hard drive’ have the same meaning.



Magnetic media
Magnetic media have been the mainstay of filestore technology for a very long time. The
invention of magnetic tape for sound recording pre-dates the invention of the computer by
many years. As a result, magnetic tape was the first storage device. In contrast, the hard disk
was specifically invented for computer storage. The hard disk also used magnetisation to
write data, and arrived a few years after magnetic tape was first used for storage.

For either type of magnetic medium the interaction with it is controlled by a read head and
a write head. A read head uses the basic law of physics that a state of magnetisation will
affect an electrical property; a write head uses the reverse law. Although they are separate
devices the two heads are combined in a read-write head. The two alternative states of
magnetisation are interpreted as a1 or 0.

A schematic diagram of a hard disk is shown in Figure 3.02. Points to note about the physical
construction are:

e   there is more than one platter (disk)

e   each platter has a read-write head for each side
e   the platters spin in unison (all together and at the same speed)

e   theread-write heads are attached to actuator arms which allow the heads to move over
    the surfaces of the platters

e   the motion of each read-write head is synchronised with the motion of the other heads
e   acushion of air ensures that a head does not touch a platter surface.

                              Read-write   Actuator
                                 head        arm

           Spindle
                                              |
                     /




Platter




Cylinder




                                                  Track



                                                                              Sector


                (a) A hard disc drive                     (b) A single disk


Figure 3.02 A schematic drawing of the components of a hard disk drive
Cambridge International AS & A Level Computer Science




Data are stored in concentric tracks (tracks sharing the same centre). Each track consists of a
sequence of bits. These are formatted into sectors where each sector contains a defined number
of bytes. The sector becomes the smallest unit of storage. Because the movement of the heads is
synchronised, the same tracks on different disks can have related data stored on them. These are
accessible by just one movement of the head. The collection of tracks is referred to as a ‘cylinder’.

To store a file, a sufficient number of sectors have to be allocated but these might or might
not be next to each other. As files are created and subsequently deleted or edited the use
of the sectors becomes increasingly fragmented, which degrades the performance ofthe
disk. A defragmentation program can reorganise the allocation ofsectors to files to restore
performance. This is discussed in Chapter
                                        8 (Section 8.03).

A hard drive is considered to be a direct-access read-write device because any sector can be
chosen for reading or writing. However, the data in a sector has to be read sequentially (in order).

This is only a simplified explanation of hard drive technology. There are several issues that
arise when making hard drives. For example, the length of a track on the disk gets larger as
you move from centre to edge. Manufacturers have to take account ofthis in their designs,
otherwise the data storage capacity will be less than it potentially might be.



Optical media
As with the magnetic tape medium, optical storage was developed from existing technology
not associated with computing systems. The compact disc (CD) evolved into CD digital audio
(CD-DA) and this became the technology used in the CD-ROM. This was extensively used for
distributing software but was of no value as a replacement for the floppy disk. The read—write
version (CD-RW) which came later finally meant CD was a complete alternative to floppy disks.
However, the CD has now given way to the DVD (originally ‘digital video disc’ but later renamed
as ‘digital versatile disc’). The latest and most powerful technology is the Blu-ray disc (BD).

A schematic diagram of a design for an optical disc drive is shown in Figure 3.03. This is
equipped to read a CD with infrared laser light of wavelength 780 nm ora DVD with red laser
light of wavelength 680 nm.


               Tracking laser
                   (780 nm)


  Tracking |
  detector




Focus offset con                       .    .
                                      Dichroic mirror


Read-write
      laser
      (red)

         Dichroic mirror                        Objective
                                                 lens and
             Signal collection lens                optical
                                                correction
               Read signal detector


Figure 3.03 A schematic drawing of an optical disc drive
                                                                                                     _
                                                                                                  _ —SsGe

We can ignore
          the finer details of the construction of the crive and concentrate on the
principles of how
                it operates.         Tne important features for the process
                                                                          of reading data from the
aise are as follows.

e   The opticaldisc has one spiral track running
                                            from the inner extreme of the surface to the
    outer edge.

»   During operation, the cisc spins.

e   Simultaneouslythe laser moves across ensuring that it is continuouslyfocused on the
    spiral track.



e   The laser beamis reflected fram the surface of the disc.

*   Thedi[ferentce between the reflection from a pit compared to that from a land can be
    detected

e   This difference in the intensity of the light the detector receives can be interpreted as
    either a 1 or a0 to allow
                            a binary code to be read from the disc.

For CD-RW and DVD-RW technologies, the reflective surfaceis a special alloy material. When
data is being written tothe disc (the' burn’ process) the heat generated by the absorption
of the laser light changes the material to liquid form. Depending on iheey of the laser
light the material reverts to either
                                  a crystailine or an amorphous solid        form whenit cools.
When the discis reac, the laserlight
                                  is reflectedfrorn
                                                the crystalline solid but not from the
amorphous solid, allowing
                       the cocingof a            Lord.

Despite     there being only one trackthe disc functions asa direct-accessdevice because the             “<   x
laser can move forwards or backwards.The datais formatted into sectors alongthe track in a               -
similar way to the formatting of a magnetic hard disk,                                                   _
Another sirnilarity with magnetic cisk technology is that the storage capacity Is cependent
on how close together individual physical representations ofa binary digit can get.There
are two aspects governing thisfor an optical disc. The speed of rotation is one but the most
irnportant is the wavelength of the light. Shorter wavelength light can be better focused. This
is why a DVD can store more than a CD but much less than a Blu-ray disc.


kaha      adoadon   aa   eet   soe

WSEAS Shee          PPPS ES

Despite the continued improvernentin optical technology there is nowa powerful
competitor in the form ofsolia-state storage. The basisfor this is ‘flash’ memory, which is a
semiconductor technolagy with no moving parts. The circuits consist of arrays of transistors
acting as memory cells.|nhs most frequently used technologyis called ‘NAND’ because the
basic circuitry resembles that of a N,AND logic gate (seeChapter 4 Section 4.94) with the
memory cells connected in series. The writing
                                          to the            memaryandthe reading fromitis
handled by a NAND flash controller. he special feature is that blocks of memory cells car
nave their contents erased all at ance ‘ina flash’. Furthermore, before cata can be written to
a blockof ceils in the memory the datainthe blockfirst has to be er ased. Abt ock CONSISES
of several pages of memory. When data is reac, a single page ofdata can be read in one
operation.

The most frequent use is either in a mernory
                                           c
                                           care orina USB flash crive (memory stick). In
the latter case ine flash memory
                               is incorporated in a devicewith the memory chip connected
to a standard USB connector. This is currently the technology of choicefor removable data
storage. How lone this will remain so is uncertain with alternative technologies such as
phase-change random access memory (PRAM) already underdevelopment.
Cambridge International AS & A Level Computer Science




The alternative use is as a substitute for a hard disk when it is often referred to as a solid-
state drive (SSD). You might think that, with no moving parts, the technology would last
forever. This is not true; with continuous use there is a degradation in the material used for
construction. However, this is only gradual and it can be detected and its effects corrected
for. Another major advantage over the traditional hard drive is the faster access speed.


Extension Question 3.01
Carry out some research into the technologies currently available for storage.

Consider first the options available for the storage device inside a laptop computer. Create a
table showing cost, storage capacity and access speed for typical examples. Then consider
the options available for peripheral storage devices. Create a similar table for these.

Can you identify which technologies remain viable and which ones are becoming
uncompetitive? Are there any new technologies likely to come into common use?



3.05 Output devices provided for a user of a
general-purpose computer system
Screen display
Chapter 1 (Section 1.05) described how an image could be stored as a bitmap built up from
pixels. Screen displays are also based on the pixel concept but with one major difference. A
screen pixel consists of three sub-pixels typically one each for red, green and blue. Varying the
level of light emitted from the individual sub-pixels allows a full range of colours to be displayed.

There have been a number ofvery different technologies used to create a pixel. In the original
cathode ray tube (CRT) technology, there is no individual component for a pixel. The inner
surface of the screen is covered with phosphor, which is a material that emits light when
electrons fall on it. An individual pixel is lit up by controlling the direction of the electron
beam used. Colour CRT displays have individual red, green and blue phosphors arranged so
as to create an array of pixels.

Flat-screen technologies now dominate. The liquid-crystal display (LCD) screen is an
example. It has individual cells containing a liquid crystal to create each pixel. The pixel
matrix is illuminated by back-lighting and each pixel can affect the transmission of this light
to create the on-screen display. A typical arrangement is shown in Figure 3.04.




                                               a




           le Colour Filter
                                                            \ ee Colour Filter glass

                                                                        \

                                                                             aN
                                                                                  \
                                          P|                                          AN

                 L           j             1                                               AN



                                                                                                TFT Glass
                         4
                                                                                                Polariser
           wf
            /,   £   £           €   ft        i   ot   I    1   of   VY».        VNN



                                                   Backlight


Figure 3.04 The components of a liquid-crystal display screen
                                                                                                               Part 1: Chapter 3: Hardware




The back-lighting is usually provided by light-emitting diodes (LEDs). Polarised light is
directed towards the pixel matrix and a further polariser is placed between the pixel matrix
and the screen. If a voltage is applied to an individual pixel cell the alignment ofthe liquid
crystal molecules is affected. This changes the polarisation ofthe light and so changes what
is displayed on the screen.


    KEY TERM


                                                                      Y    LA   +                +>
                                                                     and   witn     liquid   crystal   cells
     .      |    |            .

    SaANAWICNE       aM   f       IFISETS




Virtual reality headset
The most important components of a virtual reality headset are the two eye-pieces. These
are fed paired images from the controlling system which, when looked at together, give
the eyes the sensation of being in a 3D environment. The images can be collected using
specialised photographic techniques or can be created using a 3D graphics package. The
wearer of the headset can control which part of the 3D environment is in view. They do this
by moving their head or by using a controlling device.



Hard-copy output of text
Two technologies have come to dominate the printing of documents from data stored in a
computer system. These are the inkjet printer and the laser printer. Both these technologies
can be used to print text or images.

An inkjet printer works in the following way. A sheet of paper is fed in; the printhead moves
across the sheet depositing ink on to the paper; the paper is moved forward a fraction and
the printhead moves across the paper again. This continues until the sheet has been fully
printed. The printhead consists of nozzles that spray droplets on to the paper. Ink is supplied
to the printhead from one or more ink cartridges.

A schematic diagram of the workings of a laser printer is shown in Figure 3.05. The operation
can be summarised as follows.

1   The drum is given an electric charge.

2   Thedrum starts to revolve step by step.

3   Ateach step a laser beam is directed by the mirror and lens assembly to a sequence of
    positions across the width of the drum.

4   Ateach position the laser is either switched off to leave the charge on the drum or
    switched on to discharge the position.

5   This process repeats until a full-page electrostatic image has been created.

6   Thedrum is coated with a charged toner that only sticks to positions where the drum has
    been discharged.

    The drum rolls over a sheet of paper which is initially given an electric charge.

    The sheet of paper is discharged and then is passed through heated rollers to fuse the
    toner particles and seal the image on the paper surface.

9   Thedrum is discharged before the process starts again for the next page.

The above sequence represents black and white printing.
Cambridge International AS & A Level Computer Science




For colour printing, separate toners are required for the colours and the process has to
take place for each colour. The colours are created from cyan, magenta, yellow and black.
The technology produces dots. Image quality depends on the number of dots per inch and
software can control the number of dots per pixel.


      paper exit




                                                Laser Unit

                                            Photoreceptor
                                         <— Drum
                                                 Assembly




                                >
       |               PAPER TRAY                        |


Figure 3.05 A schematic diagram of a laser printer

The same principles apply for colour printing using an inkjet printer, where separate colour
inks are used.


Hard-copy graphics output
As discussed in Chapter 1 (Section 1.05) a graphic image can be stored either as a bitmap or
as a vector graphic. The printing technology described above can be used to print a hard-
copy of a bitmap. Ifa vector graphic file has been created the image can be displayed ona
screen or printed by first converting the file to a bitmap version. However, specialised technical
applications often require a more accurate representation to be created on paper. This requires
the use of a graphics plotter. A plotter uses pens to write, usually, on a large sheet of paper
constrained by sprockets along one pair of sides. The sprockets can move the paper forwards
or backwards and pens can either be parked or in use at any given time. The controlling
circuitry and software can create the drawing directly from the original vector graphic file.

Graph plotters are used by engineers and designers working in manufacturing. Engineers and
designers may also use a 3D printer, which is a device that offers an alternative technology for
computer-aided manufacture (CAM).




Figure 3.06 A bionic ear created using a 3D printer
                                        |                                                                                           —
                                                                                                                                   _ —m—m'_se

A 3D design is created in a suitable computer-aided design (CAD) package.|The design is
split into layers. The catafor the first layer is transmitted to the 3D printer. Rather than using
ink
  to drawthe layer, the 3D printer uses a nozzle to squirt material on to the printer bed te
createa physical layer
                     to match the design.This process is repeated for successive layers
When the whole objecthas been forrned it has
                                           to be cured in some way to ensure that the
layers are stuck together and the material has been converted to the form required for the



The technology is versatile. Figure 3.06 shows a striking example.

(For those of you interestedin the details ofFipure3.06: the bionic ear was constructed with
three‘inks’, Silicone
                  was used forthe basic structure, a gel containing chondrocyte celis
and silicone infused with silver nanoparticles
                                           were the other two ‘inks’. The final curing
                                                                                    step
involved incubation in a culture medium to allow the chondrocyte ceils to produce cartilage,
Fhe only missing component was skin.)


Se
2      SE FnSSeS
       ESE.        ee Etsts    &       se
                              SE SRA eee    gate Sehee
                                                     FRE a       2
                                                                 Se        ood See
                                                                               we & ek
                                                                                    cal            :
                                                                                                  Sk   SEES ees    = seSb
                                                                                                                  EE
weolfih ERRGLGG CHS WECGes GO Os PS ch Ley Gy ge
                   By                                                 eS                     %.
Sy Sh ER SS EE          ROG SR              es rt            Ge       a         ee       Sate a   a, tee,
gate
 Ses
hace
     # EES
        =
           gH~E ETRE
                 Soo
                   F
                     RAS
                      SES
                        :
                         ReLeIMG
                           RS RSS
                                  Rol
                                   :
                                                        EEG BYRE RR
                                                             ”
                                                                  Soh
                                                                      Sp
                                                                      &
                                                                         UCRLf EES
                                                                                Ss
                                                                                   YEE
                                                                                     a



“Ths
   ow Leas    shy aca
                    eet
 SES MATYAS aS


The keyboard ailowsa user to input text cata. Duringtext input it appears as thougn a key
pressimmediately transfers the appropriate charactertothe computer screen, pas isan
illusion.The keypress has
                        to be convertedto a character code, whichis transmitted
                                                                              tothe
processor. The processor, under the control of                                       the operating system, ensures that the text
characteris displayed on                    the screen. The same process takes place if the keyboardis used to
initiate some action, perhaps by using
                                   a shortcut key combination. The cifference is that the
processor has
            to respond by takingthe requested action,

To achieve this functionality the keyboard has electrical circuitry together withits own
microprocessor and a ROM chip. The significant details of howa keyboard works are
as follows.

e      The keys are positioned above a key matrix, which consists ofa set of rowsofwires and
       another set of colurnns of wires.

»      Pressinga key causescontact at one ofthe pointswhere wires cros

e The microprocessor continuously tests to see if any electrical circuitinvolving a row wire
       and a column wire has become closed.

e      When the microprocessor recognises that a circuit has become closed, it can identify the
       particular intersection (wirecrossing
                                           ray point) that
                                                         is causing this.

e      Tne processor then uses data stored in the ROM to identitythe character code relating
                                                                                          to
       the key associated with that intersection and sends this character tothe screen.




                   number
                      of ways in whicha user can cause data to be input through aninteraction
with a screen. At one time a computer systemuser only had access toa keyboare and 2
screen acting as a monitor. Even then the software could display a menu on tne screen and
the user could choose an option by keying in a number from the menu.

A significant step terward came with the introduction of graphical user interfaces (GUIs)
as standard features for microcomputer systems in the 1980s. AGUI providesa number of
different types of screen icon, each of which allows the user tocontrol data input. The user
Cambridge International AS & A Level Computer Science




needs a pointing mechanism to use a GUI effectively. One example of a pointing mechanism
is   acomputer mouse that controls the position ofa cursor on the screen. The screen is now
not just an output device but also an input device activated by a mouse click.



Touch screens
The early versions of touch screen technology worked with a CRT screen but could equally
well be used with a flat screen. The mechanism required emitters to be positioned on the
sides of the screen with detectors positioned opposite to them. The emitters produced either
infrared light or ultrasonic waves. When a finger touched the screen and blocked some of the
light or ultrasound, some of the detectors would measure a reduced signal level.

As well as providing improved display capability, flat-screen technology has allowed new
mechanisms for touch screen interaction.

The modern version of a touch-sensitive screen has layers providing the light output by the
display with further, touch-detecting layers added immediately beneath the surface ofthe
screen. There have been two approaches used. The first is the resistive touch screen. This
type has two layers separated by a thin space beneath the screen surface. The screen is not
rigid so when a finger presses on to the screen the pressure moves the topmost of these
two separated layers, so that the top layer makes contact with the lower layer. The point of
contact creates a voltage divider in the horizontal and vertical directions.

The second technology is the capacitive touch screen. This does not require a soft
screen but instead makes use of the fact that a finger touching a glass screen can cause
a capacitance change in a circuit component immediately below the screen. The most
effective technology is projective capacitive touch (PCT) with mutual capacitance. PCT
screens have a circuit beneath the screen that contains an array of capacitors. This
capacitive technology can detect the touch ofseveral fingertips at the same time, which
allows for more sophisticated applications.

In any type of touch screen the processor takes readings from measuring devices and
uses these readings to calculate the position of the touch. This calculation then allows the
processor
        to set in motion whatever action the user was requesting.


——
Er
     Resistive touch screen: a flexible surface that causes contact between electrically resistive layers
     beneath when touched

     Capacitive touch screen: a rigid surface above a conductive layer that undergoes a change in
     electrical state when a finger touches the screen



Extension Question 3.02
Consider the different possibilities for interacting with a screen display. Create a table
showing the advantages and disadvantages for each technique.


Discussion Point:
Investigate which flat-screen technologies are used in any computer, laptop, tablet or mobile/
cell phone that you use. Discuss the benefits and drawbacks associated with their use.
8Seeerea
       3
       h
              caer
            eyh sk     gee
                             rae
                              se
                                   BA
                                   eas
SERRSLEL ASE Gk RAE GEESE EE.
                               8




There are several ways to store and use image (graphic) data in a computer.                                 Awebcam
is a device used to stream video images into a computer system. A digital camera can be
connected to a computer and stored irnages or videos can then be cownloaded into the



containing the irnage (which ray be text) is held ina fixed position and a light source moves
from one end of the sheet to the other. it covers the width of the paper. The reflected light is


You don’t need to know the details of haw a CCD works, but three aspects to nate are:

»    a CCD consists of an array of photo-sensitive cells
e    aCCD produces an electrical response proportional to the light intensity for each cell


     the computer,

ay   gyre    Sob BRS gt            op ged             eye gbens oe    2g   a heg   ak
“fe
sai ht &     EE ERS SSRS SSS. RSSSEES
             EES
                   :
                                       STRESS SRS SS HSS ASSESS ses
                                   Sh8 Re BR LE REE BAe SSESESE SAS
                                                            :




ye     .
 FEAT LR     TREE SS
                       2      .
                             Weed3      oye     a
                                              sdews   ok
                                                      of




IF telephony and video conferencing are two applications that require both voice input
and voice output. In addition, voice recognition can be used as an alternative technique
for data input to a computer and voice synthesis is being usec for an increasing variety of


For input, a microphone is needed. This is a device that nas a diaphragm, a flexible material
that is caused to vibrate by an incoming sound. if the diaphragm is connected to suitabie
circuitry the vibration causes a change in an electrical signal.                              Acondenser microphone uses
capacitance change as the mechanism: an alternative is to use a piezoelectric crystal. The
analogue electrical signal is converted to a digital signal by an analogue-to-digital (ADC)
converter so that it can be processed inside the computer.

For output, a speaker (loudspeaker) is needed. How this works is effectively the reverse
process to that for input. Digital data from the cormputer system is converted to analogue
by a digital-to-analogue (DAC) converter. The analogue signal is fed as a varying electrical
current to the speaker, In most speakers, the current flows through a coil suspended within
the magnetic field provided by a perrnanent magnet in the speaker. As the size anc direction




The input and output are controlled by a sound (audio) card installed in the computer.


Myehar    Somes MPP
SARE ERIS AY RSA
                 af cause    imi     ans susan
                    GSR ESAS PERERA, CRE RRA COREE SOR


                                                                     recorded or live streamed in the same way that voices
are recorded, Some sound recording devices carry out the analogue to digital conversion
very early on in the process so that all the sound processing is done digitally.                              Music can be
output via speakers or stored in digital form for tater play back.
Cambridge International AS & A Level Computer Science




    Summary




Exam-style Questions

1   a_   Examples of primary and secondary storage devices include:

         e     hard disk

         e     DVD-RW

         e     flash memory

         For each device, describe the type of media used.

         Hard disk

         DVD-RW

         Flash memory

         Describe the internal operation ofthe following devices:

         DVD-RW

         Pressing a key on a computer keyboard can cause a character
                                                                  to be displayed on the
         computer screen.

         i      Identify four aspects of the basic internal operation of a keyboard that makes
                this happen.

         ii     Describe an alternative method for a user to enter some text into a computer system.

         i      Inthe operation of a laser printer there are a number of initial stages which lead up to
                the creation of a full-page electrostatic image. Identify three of these stages and
                present them in the order that they would occur.

         ii     Identify two ofthe stages that make use of this electrostatic image.

         iii    State the difference in the procedure used for colour printing from that used for
                black and white printing.

         Describe the operation ofa touch screen technology that can be used in association with
         any type of computer screen.

         Describe the operation of a touch screen technology that is only applicable for use with a
         flat screen.
         Examples of primary and secondary storage devices include:

                e   hard disk       e   DVD-RW          e   flash memory

         For each device, describe the type of media used.

         Hard disk

         DVD-RW

         Flash memory
b   Describe the internal operation of the following devices:
66




     Logic gates and logic circuits

     Learning objectives
     By the end of this chapter you should be able to:

        use logic gate symbols for NOT, AND, OR, NAND, NOR and        construct a truth table from:
        XOR                                                           * aproblem statement
        understand and define the functions of the NOT, AND, OR,      ° a logic circuit
        NAND, NOR and XOR (EOR) gates
                                                                      * a logic expression
        construct the truth table for each of the above logic gates
                                                                      construct a logic expression from:
        construct a logic circuit from:
                                                                      * aproblem statement
        * a problem statement                                         * a logic circuit

        * a logic expression                                          * atruth table.
        * atruth table
                                                                          Part 1: Chapter 4: Logic gates and logic circuits




4.01 Boolean logic and problem statements
Consider
      the following question:

                            ls Colombo further north than Singapore?

in everyday language the answer will be either yes or no. (‘Yes’, in fact.) However, the question
could be rephrased to make use ofthe language of Boolean logic:

                   Colombo is further north than Singapore: TRUE or FALSE?

More formally, the statement:

                            Colombo is further north than Singapore.

can be described as an example of a logic assertion or a logic proposition that can have
only one ofthe two alternative Boolean logic values: TRUE or FALSE.




Now consider
          the following two individual statements.

e   You should take an umbrella if it is raining or if the weather forecast
                                                                          is for rain later.
e   The air-conditioning system is set to come on in an office only during working hours but
    also only if the temperature rises to above 25°C.

Each of these statements contains two logic propositions which are highlighted. In each
statement these logic propositions are combined in some way. Finally, each statement has
the addition of
              an outcome which is dependent on the combination of the two propositions.
Each of these is, therefore, an individual example of a problem statement.


f KEY TERM




4.02 Boolean operators
The problem statements identified above can be more formally expressed in a form that is
suitable for handling with Boolean logic. To do this it is necessary to use Boolean operators.
The three basic Boolean operators are AND, OR and NOT.

The definition for AND, OR and NOT can be expressed as:

e   AAND Bis TRUE If      Ais TRUE and Bis TRUE

e   AORBis TRUE if Ais TRUE orBis TRUE

e   NOT Ais TRUE if     Ais FALSE.

Here, both A and B represent any logic proposition or assertion that has a value TRUE or FALSE.

The two problem statements above can now be rephrased as follows:

e   Take_umbrella = TRUE IF (raining= TRUE) OR (rain_forecast = TRUE)
e   System_on=TRUE IF (office hours = TRUE) AND (temperature > 25°C).
Cambridge International AS & A Level Computer Science




Each original problem statement has now been rephrased to include a form of logic
expression. The format of each expression here does not follow any formally defined
convention but the structure does allow the underlying logic to be understood. In general,
a logic expression consists of logic propositions combined using Boolean operators. The
expression may be included in an equation with a defined output.


Qe
     Logic expression: logic propositions combined using Boolean operators, which may be equated to a
     defined outcome



Any logic expression can be constructed using only the Boolean operators AND, OR and NOT
but it is often convenient to use other operators. Here are the definitions for the three other
operators that you should be familiar with:

e    ANAND Bis TRUE if       Ais FALSE or B is FALSE

e    ANORBis TRUE if       Ais FALSE and B is FALSE

¢    AXORBis TRUE if Ais TRUE or Bis true but not both of them.


     WORKED EXAMPLE 4.01


    Constructing a logic expression from a problem statement
    Consider the following problem statement.

    A shopkeeper orders a delivery of goods at the end of each month. However, if the stock of a particular item falls to the
    re-order level before the end of the month, a delivery is ordered immediately. Also, ifa regular customer orders a large
    amount of goods, a delivery is ordered immediately.

    We need to identify the conditions in the statement that can have true orfalse values. These can be underlined:

    A shopkeeper orders a delivery of goods at the end of each month. However, if the stock of a particular item falls to the
    re-order level before the end of the month a delivery is ordered immediately. Also, if a regular customer orders a large
    amount of goods a delivery is ordered immediately.

    The conditions can now be collected together in one logic expression:

    End_of_month OR re-order_level_reached OR (regular_customer AND large_amount)

    To simplify this we change each condition into a symbol.

    e   LetA represent End_of_month.

    e   Let B represent re-order_level_reached.
    e   LetC represent regular customer.

    e   LetD represent large_amount.

    The logic expression can now be written in an equation using
                                                               X to represent ‘a delivery is ordered’:

    X=AORBOR (CAND         D)
                                                                            Part 1: Chapter 4: Logic gates and logic circuits




  TASK 4.01

  Convert the conditions in the following problem statement into a simple logic
  expression:

  A document can only be copied if it is not covered by copyright or if there is
  copyright and permission has been obtained.




4.03 Truth tables
The truth table is a simple but powerful technique for representing any logic expression or for
describing the possible outputs from a logic circuit.

A truth table is presented by making use of the convention that TRUE can be represented as 1
and FALSE can be represented as 0. The simplest use of a truth table is to represent the logic
associated with a Boolean operator.

As an example, let us consider the AND operator. The labelling of the truth table follows
the convention that the initially defined values are represented byA and B and the value
obtained from the simple expression using the AND operator is represented by X. In other
words, we write the truth table forX =A AND B. Remembering that AND only returns TRUE if
both A and B are TRUE we expect a truth table with only one instance of X having the value 1.
The truth table is shown in Table 4.01.

The truth table has four rows corresponding to the four combinations ofthe truth values for
                                                                                          A
and B. Three of these lead to a0 in the X column as expected.
:                    | oO Fis
               ePloOoleFR




                                        es
                                FPlo|o!|o
     | OoOlo
    Pir




Table 4.01 The truth table for the AND operator




    TIP

    When constructing a truth table make sure that the left-hand columns for the input values are
    written as though they were increasing binary values.




  TASK 4.02

  Without looking further on in the chapter, construct the truth table for the OR
  operator.
Cambridge International AS & A Level Computer Science




4.04 Logic circuits and logic gates
The digital circuits that constitute the inner workings of a computer system operate as logic
circuits where each individual part ofthe circuit is either in an ‘on’ state, corresponding to a 1,
or in an off state, corresponding to a 0. A logic circuit comprises component parts called logic
gates. Each different logic gate has an operation that matches a Boolean operator.




Figure 4.01 The symbol for the AND logic gate



— aE
     Logic gate: a component of a logic circuit that has an operation matching that ofa Boolean operator



When drawing a circuit, standard symbols are used for the logic gates. As an example, the
symbol shown in Figure 4.01 represents an AND gate.

The first point to note here is that the shape of the symbol tells us the type of gate. The
second point is that the inputs are shown on the left-hand side and the output is shown
on the right-hand side. In general, the number of inputs is not limited to two. We will only
consider circuits where the number of inputs is two or fewer.

Figure 4.02 shows the logic gate symbols and the associated truth tables for each of the six
Boolean operators introduced in Section 4.02.




NOT           >                                    o | 1
                                                   aA |      x


                                                             0


                                             A         |B]       X

                                              o    |   o     |   o
AND           =_>                             o        |i1       io
                                              1    | 0       |   0

                                              1/1]1


                                             A         |B]       X                                         A|B]X

                                              o    | o       |   o                                         o   | oli
OR            -) >                            o        fila             NOR          ~) >>                 o     fio
                                              1/011                                                        1   | 0    |    0

                                              1/i1]1                                                       1     11   |    0


                                              Al       BX                                                  A|B]X

                                              o    | of]         1                                         o   | o    |    o
NAND          |p                              o/1]i1                    XOR           -) >                 o     fai
              ~                               1 | of]            41                                        11o]41
                                              1/110                                                        1     11   {|   0


Figure 4.02 Logic gate symbols and their associated truth tables
                                                                             Part 1: Chapter 4: Logic gates and logic circuits




There are two other points to note here. The NOT gate is a special case, having only one
input. The second point is that a NAND gate is a combination ofa NAND gate followed by a
NOT gate, and a NOR gate is a combination of an OR gate followed by a NOT gate. NAND and
NOR gates produce a complementary output to the AND and OR gates.



  TASK 4.03

  Drawa circuit where A and B are input to an AND gate, from which the output is
  carried to a NOT gate, from which there is an output X. Show that this has the same
  outcome as having one NAND gate.




Extension Question 4.01
Could the same outcome be produced by positioning a NOT gate before the AND gate?




      TIP

      You need to remember the symbol for each of these gates. A good start here is to remember that

      AND has the proper D symbol and OR has the curvy one.



You also need to remember the definitions for the gates so that you can construct the
corresponding truth table for each gate.


Question 4.01
Can you recall from memory the symbols and definitions ofthe six logic gates introduced in
this chapter?


   WORKED EXAMPLE 4.02


  Constructing a logic circuit from a problem statement or logic expression
  You need to be able to construct a logic circuit from either a problem statement or from a logic expression. If you are
  given a problem statement, the best approach is to first convert it to a logic expression.

  Consider the following problem statement: A bank offers a special lending rate to customers subject to certain
  conditions. To qualify, a customer must satisfy certain criteria.

  e    The customer has been with the bank for two years.

  e    Two ofthe following conditions must also apply:

       e    the customer is married

       e    the customer
                       is aged 25 years orolder

       e    thecustomer’s parents are customers ofthe bank.

  To convert this statement to a logic expression using symbols we can choose:

        let A represent an account held for two years

  e     let Brepresent that the customer is married

        let C represent that the customer is aged 25 years or older

        let D represent that the customer’s parents have an account.


                                                                                                                   (Continued)
Cambridge International AS & A Level Computer Science




 The logic expression can then be written as:

 AAND (((B AND C) OR (BAND D)) OR (C AND D))

 This could alternatively be presented with an outcome:

 Special_rate IF A AND (((B AND C) OR (BAND D)) OR (CAND D))

 alternatively as

 X=AAND (((B AND C) OR (B AND D)) OR (C AND D))

  Note the use of brackets to ensure that the meaning is clear. You may think that not all of the brackets are needed. In
 this example, an extra pair has been included to guide the construction ofthe circuit where only two inputs are allowed
 for any ofthe gates.

  From this, we can see that the logic circuit corresponding to this logic expression derived from the original problem
 statement could be constructed using four AND gates and two OR gates as shown in Figure 4.03.

 A




      aN                                                 D>.

 re                              4 >—
            [
           LY
  D


  Figure 4.03 A logic circuit constructed from a problem statement




  WORKED EXAMPLE 4.03


 Constructing a truth table from a logic expression or logic circuit
 You also need to be able to construct a truth table from either a logic expression or a logic circuit. We might have
 continued with the problem in Worked Example 4.02 but four inputs will lead to 16 rows in the truth table. Instead, we
 consider a slightly simpler problem with only three inputs and therefore only eight rows in the truth table. We will start
 with the circuit shown in Figure 4.04.




 ;                           [
  Figure 4.04 A circuit with three inputs for conversion to a truth table


 Table 4.02 shows how the truth table needs to be set up initially. There are two points to note here. The first is that you
  must take care to include all of the eight different possible combinations of the input values. The second point is that
 for such a circuit it is not sensible to try to work out the outputs directly from the input values. Instead a systematic

                                                                                                                    (Continued)
                                                                      Part 1: Chapter 4: Logic gates and logic circuits




approach should be used. This involves identifying intermediate points in the circuit and recording the values at each
of them in the columns headed ‘Workspace’ in Table 4.02.


                  Inputs                                          Workspace                                  Output

      A             B              Cc                                                                           X

      0             0              0

      0             0              1

      0              1             0

      0              1             1

      1             0              0

      1             0              1

      1              1             0

      1              1             1


Table 4.02 The initial empty truth table

Figure 4.05 shows the same circuit but with four intermediate points labelled M, N, P and Q identified. Each one has
been inserted on the output side of a logic gate.


*—~)!                        > p



;                            EB
Figure 4.05 The circuit in Figure 4.04 with intermediate points identified

Now you need to work systematically through the intermediate points. You start by filling in the columns for M and N.
Then you fill in the columns for P and Q which feed into the final AND gate. The final truth table is shown as Table 4.03.
The circuit has two combinations of inputs that lead to a TRUE output from the circuit.

The columns containing the intermediate values (the workspace) could be deleted at this stage.

                    Inputs                                                Workspace                                 Output

       A                 B              Cc            M               N               P               Q               X
       0                 0              0             0               1               1               0               0

       0                 0              1             0               1               1               1               1

       0                 1              0             0               0               1               0               0

       0                 1              1             0               0               1               0               0

       1                 0              0             0               1               1               0               0

       1                 0              1             0               1               1               1               1

       1                 1              0             1               0               0               0               0

       1                 1              1             1               0               0               0               0


Table 4.03 The truth table for the circuit shown in Figure 4.05


One final point to make here is that you may be able to check part of your final solution by looking at just part of the
circuit. For this example, if you look at the circuit you will see that the path from input C to the output passes through two
AND gates. It follows, therefore, that for all combinations with C having value 0 the output must be 0. Therefore, in order to
check your final solution you only need to examine the other four combinations of input values where C has value 1.
Cambridge International AS & A Level Computer Science




If a logic circuit is to be constructed from a truth table, the first stage is to create a logic
expression. To do this only the rows producing a 1 output are used. Consider
                                                                          the truth table
shown in Table 4.04. There are three rows producing a 1 output. Each of these produces a
logic expression with AND operators. These three logic expressions are then combined with
OR operators.

                                   Inputs                                    |        Output
            A                         B                        Cc                        X

            0)                        0)                        0)                        0)

            0)                        0                         1                         1

            0                         1                         0                         0)

            0                         1                         1                         1

            1                         0                         0                         1

            1                         0                         1                         0

            1                         1                         0                         0)

            1                         1                         1                         0


Table 4.04 A truth table to be converted to a logic circuit


The three rows that produce a 1 output have the following values for the inputs:

A=0,B=OandC=1

A=0,B=landC=l1

A=1,B=0andC=0

Each one can be converted to a logical expression:

NOT AAND NOT BAND C

NOTAAND BAND C

AAND NOT BAND NOT C

The combination ofthe three such rows produces the following expression:

NOT AAND NOT BAND C

OR

NOTAAND BAND C

OR

AAND NOT BAND NOT C

This could be used to create a logic circuit, but the circuit would be quite complex. In
Chapter 19 methods will be discussed that allow the simplest possible circuit to be
constructed for a given logic problem.

If a logic expression is to be constructed from a logic circuit the first step is to construct a
truth table from the circuit. Then the above method can be applied to this truth table.
                                                                       Part 1: Chapter 4: Logic gates and logic circuits




  TASK 4.04

  An oven has a number of components that should all be working properly. For each
  component there is a signalling mechanism that informs a management system
  either if all is well, or if there is a problem. Table 4.05 summarises the signal values
  that record the status for each component.




            A                  0          Fan not working
                               1          Fan working properly

            B                  0          Internal light not working
                               1          Internal light working properly

            C                  0          Thermometer reading too high
                               1          Thermometer reading
                                                            in range


  Table 4.05 Signals from the oven components

  lf the thermometer reading is in range but either or both the fan and light are not
  working, the management system has to output a signal to activate a warning light
  on the control panel. Draw a logic circuit for this fault condition.




Reflection Point:
Looking back over the chapter content, what would you say is the central concept in the
subject matter?




  Summary
Cambridge International AS & A Level Computer Science




Exam-style Questions

1   a   The following are the symbols for three different logic gates.

             Gate 1                              Gate 2                         Gate 3



        J-                                d>                                Yt
        i     Identify each ofthe logic gates.




                                                                                                  Nw
        ii    Sketch the truth table for either Gate 1 or Gate 2.

        Consider
              the following circuit:

        ‘——               )—

        B—                      =>>




                  (2
        i     Complete the truth table for the circuit using the following template:


                             Inputs                                 Workspace            Output

                      A         B            C                                             X

                      0                      0

                      0         0            1

                      0         1            0

                      0         1            1

                      1         0            0

                      1         0            1

                      1         1            0

                      1         1            1                                                    [3]



        ii    Thereis an element of redundancy in this diagram. Explain what the problem is.      [2]

        The definition of the NAND gate can be expressed as:

              ANAND Bis TRUE if Ais FALSE or B is FALSE

        Sketch the truth table fora NAND gate.                                                    [2]

        Consider
              the following statement:

        In a competition, two teams play two matches against each other. One of the teams
        is declared the winner if one ofthe following results occurs:

        e    Theteam wins both matches.

        e    Theteam wins one match and loses the other but has the highest total score.
                                                                             Part 1: Chapter 4: Logic gates and logic circuits




         i       identify the three logic propositions in this statement.                                     [3]

         ii      By assigning the symbols A, B and C to these three propositions give the
                outcome of the competition as a logic expression.




                                                                                                              iz)
         iii    }=Sketch a logic circuit to match this logic expression.                                      [4]

3   Adomestic heating system has a hot water tank and a number of radiators. There is a
    computerised management system which receives signals. These signals indicate
    whether or not the conditions for components are as they should be. The following table
    summarises the signals received:

              Signal               Value           Component condition

                                     0             Water flow in the radiators is too low

                .                    1             Water flow in the radiators is within limits
                                     0             Hot water tank temperature too high

                8                    1             Hot water tank temperature within limits
                                     0             Water level in hot water tank too low

                C                    1             Water level in hot water tank within limits
    a    Consider the following fault condition. The water level in the hot water tank is too low
         and the temperature in the hot water tank is too high. The management system must
         output a signal to switch off the system.

         i      Sketch a truth table for this fault condition including
                                                                     the A, B and C signals.                  [4]

         ii     Sketch the circuit diagram for this fault condition to match this truth table.




                                                                                                              ci
    b    Consider the fault condition where the hot water tank temperature is within limits but
         the water flow in the radiators is too low and the water level in the hot water tank is too
         low. Sketch the circuit diagram for this fault condition which requires the
         management system to output a signal to increase water pressure.                                     [5]

4   a_   Threedigital sensors A,         Band C are used to monitor a process. The outputs from the sensors are
         used as the inputs to a logic circuit.

         A signal, X, is output from the logic circuit:

         A

         B                            logic circuit                          output X

         C

         Output, X, has a value of 1 if either of the following two conditions occur:

         e     sensor
                    A outputs the value 1 OR sensor B outputs the value 0

         e     sensor B outputs the value 1 AND sensor C outputs the value 0

         Draw a logic circuit to represent these conditions.


    A—
Cambridge International AS & A Level Computer Science




    b    Complete the truth table for the logic circuit described in part (a).

              A          B           C                       Workspace                          X

              0          0           0

              0          0           1

              0          1           0

              0          1           1

              1          0           0

              1          0           1

              1          1           0

              1          1           1                                                                         [4]


    c    Write a logic statement that describes the following logic circuit.




                                         [ )
                                         __


                                                         >>

                                              >
                                                                          D.




         .                                     >                                                              [3]
                                     Cambridge International
                                                          AS & A Level Computer Science 9608 paper 13 Q6 June 2015

5   a_   Astudent writes the following logic expression:

              XiS LIF    (Bis NOT 1 AND Sis NOT 1) OR (P is NOT 1 AND Sis 1)

         Draw a logic circuit to represent this logic expression.

         Do not attempt to simplify the logic expression.
                                                                                                                               Part 1: Chapter 4: Logic gates and logic circuits




b   Complete the truth table for the logic expression given in part (a).




                                                   ln
                                                                                                       Workspace                                   X


                               FPIPIJOlLlOIlRPIRFlolo
      PIlFIFIRFIiIololo|;o!w




                                                        FPIOIJFIOIlRFIol;rRi{s|oy!v




                                                                                                                                                                      [4]

                                                                                      Cambridge international AS & A Level Computer Science 9608 paper 12 Ql November 2016
                                                                                                                        “
                                                                                                                  4

                                                                                                                       i  i
                                                                                                                  i,
                                                                                                                       NsMES
                                                                                                                        Od




Chapter 5:
Processor fundamentals


By the end of this chapter you should be able to:

   show understanding of the basic Von Neumann model for        show understanding of how factors contribute to the
   a computer system and the stored program concept             performance of the computer system

   show understanding of the purpose and role of registers,     understand how different ports provide connection to
   including the difference between general purpose and         peripheral devices
   special purpose registers                                    describe the stages of the fetch-execute (F-E) cycle
   show understanding of the purpose and roles of the           show understanding ofthe purpose of interrupts.
   Arithmetic and Logic Unit (ALU), Control Unit (CU), system
   clock and Immediate Access Store (IAS)
   show understanding of how data are transferred between
   various components of the computer system using the
   address bus, data bus and control bus




            .       ~ ha
                                                                           Part 1: Chapter 5: Processor fundamentals




5.01 The von Neumann model of a computer system
John von Neumann was the first person to describe the basic principles ofa computer
system and its architecture in a publication.

The model von Neumann described has the following basic features.

e   There is a processor - the central processing unit (CPU).

e   The processor has direct access to memory.

e   Thememory contains a ‘stored program’ (which can be replaced by another at any time)
    and the data required by the program.

e   Thestored program consists ofindividual instructions.

e   The processor executes instructions sequentially.


5.02 Central processing unit (CPU) architecture
In order
       to understand how the von Neumann model could be put into practice in a real
computer system, we need first to identify
                                        the individual hardware components ofa CPU and
define their functions. Let’s consider a system that has the minimum number of components
needed. Figure 5.01 gives a simplified schematic diagram of a processor.




                      ArtAMeTIC




Figure 5.01   Aschematic diagram of the architecture of a simple CPU

The dotted outline shows the boundary ofthe processor. The logical arrangement of some of
the processor components is indicated. The arrows show possible directions of flow of data.
As the following discussion will show, the data for some of the arrows is actually an address
or an instruction. However, in general, data might be an address, an instruction or
                                                                                  a value.
Cambridge International AS & A Level Computer Science




The active components of the CPU
The two components of the CPU that have an active role in its operation are the arithmetic
and logic unit (ALU) (or Arithmetic Logic Unit) and the control unit. As its name implies, the
ALU is responsible for the arithmetic or logic processing requirements of the instructions
in a running program. The functions of the control unit are more diverse. One aspect is
controlling the flow of data throughout the processor and the rest of the whole computer
system. Another is ensuring that program instructions are handled correctly. A vital part of
the control unit is a clock that is used by the unit to synchronise processes. Strictly speaking
there are two clocks. The first is an internal clock that controls the cycles of activity within
the processor. The other is the system clock that controls activities outside the processor.
The CPU will have a defined frequency for its clock cycle, which is usually referred to as the
clock speed. The frequency defines the minimum period of time that separates successive
activities within the system.



————               EEE
   Internal clock: controls the cycles of activity within the processor

   System clock: controls the cycles of activity outside the processor



Registers
The other components of the CPU are the registers. These are storage components which,
because they are placed very close to the ALU, allow very short access times. Each register
has limited storage capacity, typically 16, 32 or 64 bits. A register is either general purpose
or special purpose. If there is only one general-purpose register it is referred to as the
Accumulator. Here and in Chapter 6, we assume that the processor has just this one general-
purpose register. The Accumulator is used to store a single value at any one time. A value is
stored in the Accumulator
                      that is to be used by the ALU for the execution of an instruction.
The ALU can then store a different value in the Accumulator after the execution of the
instruction.



Qo
   Accumulator: a general-purpose register that stores a value before and after the execution of an
   instruction by the ALU



Figure 5.01 shows some of the special-purpose registers as individual components. The box
labelled ‘other registers’ can be considered to comprise the Accumulator plus the special-
purpose registers not identified individually. The full names of the special-purpose registers
included in the simple CPU that we are considering are given in Table 5.01 with a brief
description of their function.
                                                                                  Part 1: Chapter 5: Processor fundamentals




 Register name                   Abbreviation | Register’s function

                                                 Stores the current instruction while it is being
 Current instruction register   | CIR            decoded and executed


 Index register                  IX              Stores a value; only used for indexed addressing

                                                 Stores the address ofa memory location or an |/O
 Memory address register         MAR             component which is about to have a value read from
                                                 or written to

 Memory data register                            Stores data that has just been read from memory or
 (memory buffer register)        MDR (MBR)       is just about to be written to memory
                                                 Stores the address of where the next instruction is to
 Program counter                 PC
                                                 be read from

 Status register                 SR              Contains bits that are either set or cleared which can
                                                 be referenced individually


Table 5.01 Registers in a simple CPU


There are three important points to remember. The first is that the MDR must act as a buffer.
This is because transfers of data inside the processor take place much more quickly than
transfers outside the processor. The second point to note is that the index register (IX) can be
abbreviated as IR but in some sources the current instruction register (CIR) is abbreviated as
‘IR’. This is a potential cause of confusion. In this book, the index register is always IX and the
current instruction register is CIR. Finally, there is also possible confusion if the abbreviation
PC is used. This will only be used in this book when register transfer notation is being used,
as you will see later in the chapter. Everywhere else, a PC is a computer.

For all of the special-purpose registers, except for the status register, the contents represent
one value. For the status register each individual bit is used as a logical flag. The bit is set to 1
if a condition is detected. Examples are the carry flag, the negative flag and the overflow flag.

Chapter 6 (Section 6.07) contains some examples of the use of the accumulator and the
status register.



5.03 The system bus
A bus is a parallel transmission component with each separate wire carrying a single bit. It is
important not to describe a bus as a storage device. A bus does not hold data. Instead it is a
mechanism for data to be transferred from one system component to another.

There will be buses inside the CPU. These are not considered here. The system bus connects
the CPU to the memory and to the I/O system. In the simple computer system described
in this chapter there will be a system bus that comprises three distinct components: the
address bus, the data bus and the control bus. The schematic diagram of the CPU in Figure
5.01 shows the logical connection between each bus and a CPU component. The address
bus is connected to the MAR; the data bus to the MDR; and the control bus to the control unit.
The system bus allows data flow between the CPU, the memory and input or output (I/O)
devices as shown in the schematic diagram in Figure 5.02.
Cambridge International AS & A Level Computer Science




                                            Input and
                                            Output


       1            ee
       Vv                Vv                Vv

 |                    Control bus                         |

 |                    Address bus                         |   E
               Vv               v                    Vv       a
 |                    Data bus                            | ”

Figure 5.02     Aschematic diagram of the system bus

The address bus
The sole function of the address bus is to carry an address. This address is loaded on to the
bus from the MAR as and when directed by the control unit. The address specifies a location
in memory or an |/O component which is due to receive data orfrom which data is to be read.
The address bus is a ‘one-way street’. It can only be used to send an address to a memory
controller or an |/O controller. It cannot be used to carry an address back to the CPU.


EE
     Address bus: a component that carries an address. This can be to the memory controller       to identify
     a location in memory which is to be read from or written to or it can be to the I/O system to identify the
     source or destination of the data



The data bus
The function of the data bus is to carry data. This might be an instruction, an address ora
value. As can be seen from Figure 5.02, the data bus is two-way (bidirectional): it might be
carrying data from the CPU to the memory or carrying data to the CPU. However, another
option is to carry data to or from an |/O device. The diagram does not make clear whether,
for instance, data coming from an input device is carried first to the CPU or directly to the
memory. There is a good reason for this. Some computer systems will only allow input to
the CPU before the data can be stored in memory. Other systems will allow direct transfer to
memory.




EEE
     Data bus: a component that can carry data from the processor
                                                                to the memory or to an output device
     or can carry data from the memory orfrom an input device



The control bus
The control bus is another bidirectional bus which transmits a signal from the control unit to
any other system component or transmits a signal to the control unit. There is no need for
extended width, so the control bus typically has just eight wires. A major use ofthe control
bus is to carry timing signals. As described in Section 5.02, the system clock in the control
unit defines the clock cycle for the computer system. The control bus carries timing signals
at time intervals dictated by the clock cycle. This ensures that the time that one component
transmits data is synchronised with the time that another component reads it.
                                                                                  Part 1: Chapter 5: Processor fundamentals




5.04 Factors contributing to system performance
The processor clock speed could is a very important factor governing the processing speed
of the system. This is because one clock cycle defines the shortest possible time that
any action can take. Actually, none of the components outside of the processor can work
anywhere near as fast as the processor can. The components that are directly addressable by
the processor, which can be referred to as the immediate access store (IAS), can only accept
data from or provide data to the processor at speeds much slower than the processor speed.

Because of this problem modern processors are far more complex than the simple example
that has been discussed in this chapter. One example of this complexity is that the CPU chip or
integrated circuit will be multi-core. Each core is a separate processor. Performance improves
with increasing number of cores. A further factor is the use of cache memory which was briefly
discussed in Chapter 3 (Sections 3.01 and 3.03). Cache memory is the fastest component of the
IAS. Performance improves with increased storage size for the cache and with increased rate
of access. Fastest access is obtained by having all or part of the cache on the CPU chip.

Before considering other factors, it is useful to introduce the concept of a word. A word
consists of   anumber of bytes and for any system the word length is defined. The significance
of the word length is that it defines a grouping that the system can handle as one unit.
The word length might be stated as a number of bytes or as a number of bits. Typical
word lengths are 16, 32 or 64 bits; that is, 2, 4 or 8 bytes, respectively. The word length will
influence the system architecture design in regard to the capacity of the components. For
example, it is usual for the size of registers to match the word length. Word length also has to
be considered when making decisions about bus widths.


   KEY TERM




For the address bus, the bus width defines the number of bits in the address’s binary
code. In a very simple computer system the bus width might be 16 bits, allowing 65536
memory locations to be directly addressed. Such a memory size would, of course, be totally
inadequate for a modern computer system. Even doubling the address bus width to 32
bits would only allow direct addressing of a little over four billion addresses. As a result,
special techniques are used when the storage capacity of the memory is too large for direct
addressing. Their use affects system performance.

Bus width is again an important factor in considering how the data bus is used. For a given
computer system, the data bus width is ideally the same as the word length. If this is not possible,
the bus width can be half the word length so that a full word can be transmitted by two consecutive
data transfers. Clearly the performance of the system is affected if the latter case applies.


Extension Question 5.01
In an advertisement for a laptop computer, the system is described as 4 GB, 1 TB, 1.7 GHz.

a Which three components are being referred to here?

b Calculate the minimum time period that could separate successive activities on this system.


Extension Question 5.02
Can you find out the bus widths used in the computer system you are using?
Cambridge International AS & A Level Computer Science




5.05 I/O ports
The schematic diagram in Figure 5.02 slightly misrepresents the system architecture
because it looks as if the CPU, the memory and the |/O devices have similar access to the
data and control buses. The reality is different. Each |/O device is connected to an interface
called a port. Each port is connected to the I/O or device controller. This controller handles
the interaction between the CPU and an I/O device. A port is described as ‘internal’ if the
connected |/O device is an integral part of the computer system. An external port allows the
computer user to connect a peripheral |/O device.



The Universal Serial Bus (USB)
In the early days of the PC, the process of connecting a peripheral was not something the
ordinary user would try to do; it required technical expertise. The aim of the plug-and-play
concept was to remove the need for technical knowledge so that any computer user could
connect a peripheral and start using it straight away. The plug-and-play concept
                                                                              was only
fully realised by the creation of the Universal Serial Bus (USB) standard. Nowadays anyone
buying a new peripheral device will expect it to connect to a USB port. There is an alternative
technology known as FireWire, but this is not so commonly used in computer systems.



0   TIP

    Don’t forget that the USB is a bus. A USB drive stores data and is connected to a USB port which
    allows data to be transmitted along the bus.



The following is some information about the USB standard.

e   Ahierarchy of connections is supported.

e   The computer is at the root of this hierarchy and can handle 127 attached devices.

e   Devices can be attached while the computer is switched on and are automatically
    configured for use.

e   Thestandard has evolved, with USB 3.2 being the latest version.


Discussion Point:
Carry out an investigation into storage devices that could be connected as a peripheral to a
PC using the USB port.

For two representative devices find out which specific USB technology is being used and
what the potential data transfer speed is. How do these speeds compare with the speed of
access ofa hard drive installed inside the computer?


Specialised multimedia ports
Despite the widespread use of USB ports there are some peripheral devices that require
a different port, one that is specialised for the type of device. Although computer systems
come packaged with a monitor
                          for screen display there is sometimes a requirement for a
second screen to be used. The connection of the second screen can be through a Video
Graphics Array (VGA) port. This provides high-resolution screen display which is suitable for
most display requirements. However, if the screen is needed to display a video, the VGA port
is not suitable because it does not transmit the audio component.

A High Definition Multimedia Interface (HDMI) port will provide a connection to a screen and
allow the transmission of high-quality video including the audio component.
                                                                             Part 1: Chapter 5: Processor fundamentals




5.06 The fetch-execute (F-E) cycle
The full name for this is the fetch, decode and execute cycle. This is illustrated by the
flowchart in Figure 5.03.



                        START

                             RA




                    Any instructions   NO
                      to execute?




                       Fetch next
                      instruction


                                                Transfer control to
                            Vv                  interrupt-handling
                        Decode                       program
                      instruction


                                                           A
                            Vv
                        Execute
                      instruction




             NO /    Any interrupts    \.YES
                    to be processed?




Figure 5.03 Flowchart for the fetch, decode and execute cycle


If we assume that a program is already running, then the program counter will already hold
the address of the next instruction. In the fetch stage, the following steps will now happen.

1   This address in the program counter is transferred within the CPU to the MAR.

2   During the next clock cycle two things happen simultaneously:

    e   the instruction held in the address pointed to by the MAR is fetched into the MDR

    e   the address stored in the program counter is incremented.

3   Theinstruction stored in the MDRis transferred within the CPU to the CIR.

    There are two points to note here.

    e   Theclock cycle is the one controlled by the system clock which will have settings that
        allow one data transfer from memory to take place in the time defined for one cycle.

    e   Inthe final step the program counter is incremented by 1. However, the instruction
        just loaded might be a jump instruction. In this case, the program counter contents
        will have to be updated in accordance with the jump condition. This can only happen
        after the instruction has been decoded.
                                                                                                         it
            In the decode stage, the
                                   instruction stored In the CIR is received as input by the circuitry
            within the control unit, Depending on the type of instruction, the control unit will senc
            signals tothe appropriate components sothat the executestagecan begin. At this stage, the
            ALU willbe activated if the instruction requiresarithmetic or logicprocessing.

            The des ae‘ion of the execute stage is given In Chapter 6,                   wherea simple instruction set is
            introduced and discussed


                             o     ~         :        oo              .     .0


            adehd £   ERAS ELSIE LESS       ELE GESECSERTY   E SSPE       SER ELLE S

            operons involving registers can be described by register transfer notation. A simple
            example of this
                          is a representation of the fetch stage of the fetch-execute cycle:



            PC    +   [PC]   +   1;        MDR »   [[MAR]]




            In register transfer notation the basic format for
                                                             an individual data transfer is similar
                                                                                                  to that
            for variable assignment. The first item is the destination for the data. Here the appropriate
            abbreviation is used to identity the particular register. To the right of the arrow showing
            the transmission of cataisthe definition ofthisdata. Inthis cefinition,
                                                                                the square brackets
            arcund a register abbreviation show that the content of the register is being moved. This
            movement might also inciucle
                                      an arithmetical operation. When two cata operations
                                                                                       are
            placed on the same line separated bya semi-colon, this means that the two transfers take

 —   lace simultaneously. The   double pair ofbrackets around MAR on the secand line needs
            an)




_ _ careful interpretation. The content of the MAR is an address; itis the content of that address
            which is being transferred to the MDR,


            & AS leetowrgiest assy cli g ge
                                         dees
            or




            softs OPPLEN LEO Fishy REG                       ines
                                       _




            There are many different reasons for an interrupt to be generated. Some examples are:

            »     afatalerrorin a program

            »     ahardware fault

            *®    aneed for |/O processing to begin

            ®     wUserinteraction

            «     atimer signal.




            Interrupts are hancled oy a number ofdifferent mechanisms, but thereare someclear
            overriding principies. Each differentinterrupt needs to be handied appropriately Different
            interrupts might have different priorities. Therefore, the processor must have
                                                                                        a means of
            identifying the type of interrupt. One way is to have an interrupt register in the CPU that works
            like the status register, with each       individual bit operating
                                                                            as a flag for a specitic type of interrupt.

            As theflowchartin Figure 5.03 shows, the existence of an interrupt is only detected at the
            end ofa fetch-execute cycle. This allows the current program to beinterrupted and lettina
            cdetined statewhich can be returned to later. An interruptis handled bythe following steps.

            e     The contents of the program counter and any other                    registers are stored somewnere safe
                  in memory,
e   The appropriate interrupt handler or Interrupt Service Routine (ISR) program is initiated
    by loading its start address into the program counter.

e   When the ISR program has been executed there is an immediate check to see if further
    interrupts need handling.

¢   Further interrupts are dealt with by repeated execution of the ISR program.

¢   lf there are no further interrupts, the safely stored contents of the registers are restored to
    the CPU and the originally running program is resumed.


Reflection Point:
Have you worked out a method to remember all of the names and abbreviations for the
special purpose registers?




        The von Neumann architecture for a computer system is based on the stored program concept.

        The CPU contains a control unit, an arithmetic and logic unit and registers.

        Registers can be special purpose or general purpose.

        The status register has individual bits acting as condition flags.

        The system bus contains the data, address and control buses.

        A universal serial bus (USB) port can be used to attach peripheral devices.

        Instructions are handled by the fetch-execute cycle.

        Register transfer notation is used to describe data transfers.

        If an interrupt is detected, control passes to an interrupt-handling routine.




          A processor has just one general-purpose register. Give the name of this register.

          The memory address register (MAR) is a special-purpose register. State:

          i       its function

          ii      thetype of data stored in it

          iii     the register that supplies these data at the start of the fetch stage of the
                  fetch-execute cycle.
          The current instruction register (CIR) is another special-purpose register. State:

          i       its function

          ii      the type of data stored in it

          iii     the register that supplies this data at the end of the fetch stage of the
                  fetch-execute cycle.

          Explain three differences between the memory address register and the memory
          data register.

2   Thesystem bus comprises of three individual buses: the data bus, the address bus and the
    control bus.

    a     For each bus give a brief explanation of its use.

    b     Each bus has a defined bus width.

          i       State what determines the width of a bus.
                                                                                                       ns|
                                                                                                      fe




          ii.    = Explain which bus will have the least width.
                                                                                                      NO




          lili    Explain the effect of changing the address bus from a 32-bit bus to a 64-bit bus.
                                                                                                      TW
                                                                                                       a
Cambridge International AS & A Level Computer Science




3   The fetch stage of the fetch-decode-execute cycle can be represented by the following
    statements using register transfer notation:
    MAR <             [PC]

     PC    «—        [PC]    +    1;   MDR    [[MAR]]

    CIR         «—    [MDR]


    a___    Explain the meaning of each statement. The explanation must include definitions of
            the following items: MAR, PC, [],, MDR, [[]], CIR.                                                                                 [10]

    b       Explain the use of the address bus and the data bus for two ofthe statements.                                                       [4]

4   a       Nameand describe three buses used in the von Neumann model.                                                                         [6]

            The sequence of operations shows, in register transfer notation, the fetch stage of the
            fetch-execute cycle.

           1         MAR «        [PC]

            2        PC      «    [PC]    +   1

            3.       MDR <«       [[MAR]]

            4        CIR     <—   [MDR]


            *          [register] denotes contents of the specified register or memory location

            «          step 1 above is read as “the contents of the Program Counter are copied to the
                       Memory Address Register”

            i          Describe what
                                   is happening at step 2.                                                                                      [1]

            ii         Describe what
                                   is happening at step 3.                                                                                      [1]

            iii        Describe what
                                   is happening at step 4.                                                                                      (1]

    c       Describe what happens to the registers when the following instruction is executed:

            LDD 35                                                                                                                              [2]

    d       i          Explain what is meant by an interrupt.                                                                                   [2]

            ii         Explain the actions of the processor when an interrupt is detected.                                                      [4]
                                                  Cambridge International
                                                                       AS &A Level Computer Science 9608 paper 13 Q5 June 2015

5   a__     Describe how special purpose registers are used in the fetch stage of the fetch-execute cycle.                                      [4]

            Use the statements A, B, C and D to complete the description of how the fetch-execute cycle
            handles an interrupt.


                 A | the address of the Interrupt Service Routine (ISR) is loaded to the Program
                     Counter (PC).

                 B | the processor checks if there is an interrupt.

                 C | when the ISR completes, the processor restores the register contents.

                 D | the register contents are saved.


            At the end of the cycle for the current iNStrUuctiOn w..eceeeseceeseseeees ,

            If the interrupt flag iS Set, coceccceecsesseseesteenee y ccsvavaveeusuenensecevaveveveneeens ANG vicccseeeeseesseevevsrseeneees

            The interrupted program continues its execution.                                                                                    [4]

                                                  Cambridge International
                                                                       AS &A Level Computer Science 9608 paper 11 Q3 June 2016.
                                           ).a(a);                                      update slide
                                                                                          yar c = 1
                                                                                                       ‘om   |




                                K();                                 n();




                                                                                                  91




Assembly language programming

Learning objectives
By the end of this chapter you should be able to:

   show understanding of the relationship between assembly language and machine code
   describe the different stages of the assembly process for a two-pass assembler
   trace a given simple assembly language program

   show understanding that the set of instructions are grouped into instructions for:

   ¢ data movement

   ¢ input and output of data

   ¢ arithmetic operations

   * unconditional
                and conditional jumps

   * comparisons

   show understanding of modes of addressing

   show understanding of and perform binary shifts.
Cambridge International AS & A Level Computer Science




6.01 Machine code instructions
We need to start with a few facts.

e      The only language that the CPU recognises is machine code.

e       Machine code consists of a sequence of instructions.

e      Aninstruction contains an opcode.

e      Aninstruction may not have an operand but up to three operands are possible.

e       Different processors have different instruction sets associated with them.

e       Different processors will have comparable instructions for the same operations, but the
       coding of the instructions will be different.

    For a particular processor, the following must be defined for each individual machine code
instruction:

e      the total number of bits or bytes for the whole instruction

e      thenumber of bits that define
                                  the opcode

e      thenumber of operands that are defined in the remaining bits

e      whether the opcode occupies the most significant or the least significant bits.

We will consider a simple system where there is either one or zero operands. This simple
system will be assumed to have a 16-bit address bus width. Following on from the approach
in Chapter 5 (Section 5.02), the system will have the accumulator as the only general purpose
    register.



3 0
       Opcode: defines the action associated with the instruction

       Operand: defines any data needed by the instruction

       Machine code instruction: a binary code with a defined number of bits that comprises an opcode
       and, most often, one operand



The number of bits needed for the opcode depends on the number of different opcodes
in the instruction set for the processor. The opcode can be structured with the first few
    bits defining the operation and the remaining bits associated with addressing. A sensible
instruction format for our simple processor is shown in Figure 6.01.

                              Opcode                                            Operand
     Operation       Address mode          Register addressing
|       4bits    |       2 bits        |          2 bits            |             16 bits               |

    Figure 6.01 A simple instruction format


This has an eight-bit opcode consisting offour bits for the operation, two bits for the address
    mode (discussed in Section 6.05) and the remaining two bits for addressing registers. This
allows 16 different operations each with one offour addressing modes. This opcode will
occupy the most significant bits in the instruction. Because in some circumstances the
operand will be a memory address it is sensible to allocate 16 bits for it. This is in keeping
with the 16-bit address bus.

When an instruction arrives in the CPU the control unit checks the opcode to see what action
it defines. This first step in the decode stage of the fetch-execute cycle can be described using
                                                                 Part 1: Chapter 6: Assembly language programming




the register transfer notation which was introduced in Chapter 5 (Section 5.07). However, a
slight amendment is needed to the format. The following shows the transfer of bits 16 to 23,
which represent the opcode, from the current instruction register to the control unit:

                                    CU <    [CIR(23:16)]




6.02 Assembly language
A programmer might wish to write a program where the actions taken by the processor
are directly controlled. It is argued that this is the most efficient type of program. However,
writing a substantial program as a sequence of machine code instructions would take a very
long time and there would be inevitably lots of errors along the way. The solution for this type
of programming is to use assembly language. As well as having a uniquely defined machine
code language, each processor has its own assembly language.


f KEY TERMS




The essence of assembly language is that for each machine code instruction there is an
equivalent assembly language instruction which comprises:

e¢   amnemonic (a symbolic abbreviation) for the opcode

e    acharacter representation for the operand.

Ifa program has been written in assembly language it has to be translated into machine code
before it can be executed by the processor. The translation program is called an assembler.

Using an assembly language, the programmer has the advantage of the coding being easier
to write than it would have been in machine code. In addition, the use of the assembler
allows a programmer
                  to include some special features in an assembly language program.
Examples of some of these are:

e    comments

e    symbolic names
                for constants

e    labels for addresses
e    macros


e    directives.




A macro is a sequence of instructions that is to be used more than once in a program. A
directive is an instruction to the assembler as to how it should construct the final executable
machine code. This might be to direct how memory should be used or to define files or
procedures that will be used.
Cambridge International AS & A Level Computer Science




Discussion Point:
Although writing a program in assembly language is much easier than using machine code,
many would argue that its use is no longer justified. Can you investigate the arguments for
and against?



6.03 Symbolic, relative and absolute addressing
When considering how an assembler would convert an assembly language program into
machine code it is necessary to understand the difference between symbolic, relative and
absolute addressing. To explain these, we can consider a simple assembly language program
which totals single numbers input at the keyboard. Table 6.01 shows the program as it would
be written using symbolic addressing together with an explanation of each instruction.


Assembly language          Explanation of each instruction
 program using
 symbolic addressing

 IN                       A single number is input at the keyboard and its ASCII code is stored in
                          the accumulator

 SUB    #48                This subtraction converts the ASCII code into the binary code for the
                           number (see Task 6.01)

 STO MAX                   The number in the accumulator is stored at the address labelled MAX:

 LDM    #0                 Loads zero into the accumulator

 STO TOTAL                 The zero in the accumulator is stored at the address labelled TOTAL:

 STO COUNT                 The zero inthe accumulator is stored at the address labelled COUNT:

 STRTLP:IN                A single number is input at the keyboard and its ASCII code is stored in
                          the accumulator

 SUB    #48                This subtraction converts the ASCII code into the binary code for the number

ADD TOTAL                 Adds the value at address labelled TOTAL: to the value in the
                           accumulator and stores the sum in the accumulator

 STO TOTAL                 The number in the accumulator is stored at the address labelled TOTAL:

 LDD COUNT                 Loads the value stored at address COUNT: into the accumulator

 INC    ACC               Adds 1 to the value in the accumulator

 CMP MAX                   Compares the value in the accumulator with the value stored at
                           address MAX:

 JPN STRTLP                If the compared values are not equal the program jumps to the
                           instruction labelled STRTLP:

 END                       The execution of the program has finished
 MAX:                      A labelled address where
                                                a value can be stored

 TOTAL:                    A labelled address where a value can be stored

 COUNT :                   A labelled address where a value can be stored


Table 6.01 An assembly program using symbolic addressing with explanations

The convention has been followed that a label is written with a following colon which is
ignored when the label is referenced. Note how the code is dominated by the use ofthe
accumulator.



  TASK 6.01

  Check the ASCII coding table to see why the subtraction in Table 6.01 works.
                                                                   Part 1: Chapter 6: Assembly language programming




The use of symbolic addressing allows a programmer to write some assembly language
code without having to bother about where the code will be stored in memory when the
program is run. However, it is possible to write assembly language code where the symbolic
addressing is replaced by either relative addressing or absolute addressing. Table 6.02 shows
the simple code from Table 6.01 converted to use these alternative approaches.


    Assembly language program using          Assembly language program using
    relative addressing                       absolute addressing

    (0)     IN                                (200)               IN

    (1)     SUB #48                           (201)               SUB #48
    (2)     STO   [BR]    +   15              (202)               STO   215

    (3)     LDM   #0                          (203)               LDM   #0

    (4)     STO   [BR]    +   16              (204)               STO   216

    (5)     STO   [BR]    +   17              (205)               STO   217

    (6)     IN                                (206)               IN
    (7)     SUB #48                           (207)               SUB #48
    (8)     ADD   [BR]    +   16              (208)               ADD   216

    (9)     STO   [BR]    +   16              (209)               STO   216

    (10)    LDD   [BR]    +   17              (210)               LDD   217

    (11)    INC Acc                           (211)               INC ACC

    (12)    CMP   [BR]    +   15              (212)               CMP   215

    (13)    JPN   [BR]    +   7               (213)               JPN   207

    (14)    END                               (214)               END

    (15)                                      (215)
    (16)                                      (216)

    (17)                                      (217)


Table 6.02 A simple assembly language program using relative and absolute addressing

For the relative addressing example, the assumption is that a special-function base register
BR contains the base address. The contents of this register can then be used as indicated by
[BR]. Note that there are no labels for the code. The left-hand columnis just for illustration
identifying the offset from the base address which is the address of the first instruction in the
program.


For the absolute address example there are again no labels for the code. The left-hand
column is again just for illustration but this time identifying actual memory addresses. This
has been coded with the understanding
                                  that the first instruction in the program is to be
stored at memory address 200.



6.04 The assembly process for a two-pass assembler
For any assembler there are a number of things that have to be done with the assembly
language code before any translation can be done. Some examples are:

e     removal of comments

e     replacement ofa macro name used in an instruction by the list of instructions that
      constitute the macro definition

e     removal and storage of directives to be acted upon later.
Cambridge International AS & A Level Computer Science




A two-pass assembler is designed to handle programs written in the style of the one
illustrated in Table 6.01. This program contains forward references. Some of the instructions
have a symbolic address for the operand where the location of the address is not known
at that stage of the program. A two-pass assembler is needed so that in the first pass the
location of the addresses for forward references can be identified.

To achieve this during the first pass the assembler uses a symbol table. The code is read line
by line. When a symbolic address is met for the first time its name is entered into the symbol
table. Alongside the name a corresponding address has to be added as soon as that can be
identified. Table 6.03 shows a possible format for the symbol table that would be created for
the program shown in Table 6.01.


 Symbol              |   Offset
 MAX                         +15

 TOTAL                       +16

 COUNT                       +17

 STRTLP                       +7



Table 6.03 A completed symbol table for the assembly language program in Table 6.01

Note that the assembler has to count the instructions as it reads the code. Then when it
encounters a label it can enter the offset value into the symbol table. In this example the first
entry made in the offset column is the +7 for STRPLP.

For the second pass the Assembler uses the symbol table and a lookup table that contains
the binary code for each opcode. This table would have an entry for every opcode in the
set defined for the processor. Table 6.04 shows entries only for the instructions used in the
simple program we are using as an example. Note that the binary codes are just suggestions
of codes that might be used.


 Opcode mnemonic         |         Opcode binary
 IN                                  0001 0000

 SUB                                 0110 0001
 STO                                 0100 0100

 LDM                                 0010 0001

ADD                                  0100 0101
 LDD                                 0010 0101

 INC                                 0101 0101

 CMP                                 1000 0100

 JPN                                 1010 0100

 END                                 11111111


Table 6.04 An opcode lookup table

Provided that no errors have been identified, the output from the second pass will be a
machine code program. For our example, this code is shown in Table 6.05 along with the
original assembly code for comparison.
                                                                                   Part 1: Chapter 6: Assembly language programming




    Machine code
    Opcode               Operand           Assembly code

    0001 0000                                                                            IN

    0110 0001 0000 0000 0011 0000                                                        SUB #48
    0100 0100 0000 0000 0000 1111                                                        STO MAX

    0010 0001 0000 0000 0000 0000                                                        LDM #0
    0100 0100 0000 0000 0001 0000                                                        STO TOTAL

    0100 0100 0000 0000 0001 0001                                                        STO COUNT

    0001 0000                                  STRTLP:                                   IN

    0110 0001 0000 0000 0011 0000                                                        SUB #48
    0100 0101 0000 0000 0001 0000                                                        ADD TOTAL

    0100 0100 0000 0000 0001 0000                                                        STO TOTAL

    0010 0101 0000 0000 0001 0001                                                        LDD COUNT

    01010101                                                                             INC ACC

    1000 0100 0000 0000 0000 1111                                                        CMP MAX

    1010 0100 0000 0000 0000 0110                                                        JPN STRTLP

    11111111                                                                             END

    0000 0000                                  MAX:

    0000 0000                                  TOTAL:

    0000 0000                                  COUNT :


Table 6.05 Machine code created from assembly code

Some points to note are as follows.

e     Most of the instructions have an operand which is a 16-bit binary number.
e     Usually this represents an address but for the SUB and LDM instructions the operand is
      used as a value.

e     There isno operand for the IN and END instructions.

e     The INC instruction is a special case. There is an operand in the assembly language code
      but this just identifies a register. In the machine code the register is identified within the
      opcode so no operand is needed.

e     The machine code has been coded with the first instruction occupying address zero.
e     This code is not executable in this form but it is valid output from the assembler.
e     Changes will be needed for the addresses when the program is loaded into memory
      ready for it to be executed.

e     Three memory locations following the program code have been allocated a value zero to
      ensure that they are available for use by the program when it is executed.


6.05 Addressing modes
When an instruction requires a value to be loaded into a register there are different ways of
identifying
         the value. Each one is known as an addressing mode. In Section 6.01, it was stated
that, for our simple processor, two bits of the opcode in a machine code instruction would be used
to define the addressing mode. This allows four different modes which are described in Table 6.06.


f KEY TERM
      Ad Araccima madlas   ail   1 |   1   4             a,   a   4    f   @   |   wan thle   ny     th     7
      Addr essing mode: when the INStFUCTION USES a value this        defines how the « perand must be used to
      find the   value
Cambridge International AS & A Level Computer Science




    Addressing mode              | Use of the operand
                                   The operand is the value to be used in the instruction;

    Immediate                      SUB #48

                                   isan example.

                                   The operand is the address which holds the value to be used in
                                   the instruction;

    Direct                         ADD TOTAL
                                   isan example.

                                   The operand is an address that holds the address which has the
    Indirect                       value to be used in theinstruction.
                                   The operand is an address to which must be added the value
    Indexed                        currently in the index register (IX) to get the address which holds
                                   the value to be used in the instruction.


Table 6.06 Addressing modes


For immediate addressing there are three options for defining the value:

e     #48 specifies
                 the denary value 48

e     #B00110000 specifies the binary equivalent

e     #8&30 specifies the hexadecimal equivalent


6.06 Assembly language instructions
We continue to consider a simple processor with a limited instruction set. The examples
described here do not correspond directly to those found in the assembly language for any
specific processor. Individual instructions will have a match in more than one real-life set. The
important point is that these examples are representative. In particular, there are examples
of the most common categories of instruction.



Data movement
These types of instruction can involve loading data into a register or storing data in memory.
Table 6.07 contains a few examples of the format of the instructions with explanations.


    Instruction opcode | Instruction operand | Explanation
    LDM                  #n                           Immediate addressing. Load the number n to ACC.

    LDR                  #n                           Immediate addressing. Load the number
                                                                                         n to IX.

    LDD                  <address>                    Direct addressing. Load the contents at the given
                                                      address to ACC.

    LDI                  <address>                    Indirect addressing. The address to be used is
                                                      at the given address. Load the contents of this
                                                      second address to ACC.

    LDX                  <address>                    Indexed addressing. Form the address from
                                                      <address> + the contents of the index register. Copy
                                                      the contents of this calculated address to ACC.

    MOV                  <register>                   Move the contents of the accumulator
                                                                                        to the given
                                                      register (IX).
    STO                  <address>                    Store the contents of ACC at the given address.



Table 6.07 Some instruction formats for data movement
                                                                        Part 1: Chapter 6: Assembly language programming




The important point to note is that the mnemonic defines the instruction type including
which register is involved and, where appropriate, the addressing mode. It is important to
read the mnemonic carefully! The instruction will have an actual address where <address>
is shown, a register abbreviation where <register> is shown and a denary value forn
where #n is shown. The explanations use ACC to indicate the accumulator. For explanations
of LDD, LDI and LDX, refer back to Table 6.07.


                                                Memory         Memory
                                                address         content

                                                   100            234

                                                   101            208

                                                   102            201

              Accumulator                          103            110
|                                    |             104            108
                                                   105            206

              Index register                       106            101

|                                    |             107            102
                                              INDEXVALUE:          3


Figure 6.02 Example of some data stored in memory


The following shows some examples of the effect of an instruction or a sequence of
instructions based on the memory content shown in Figure 6.02.

    LDD 103                    the value 110 is loaded into the accumulator

    LDI 106                    the value 208 from address 101 is loaded into the accumulator

STO 106                        the value 208 Is stored in address 106

    LDD INDEXVALUE             the value 3 is loaded into the accumulator

    MOV IX                     the value 3 from the accumulator is loaded into the index register

    LDX 102                    the value 206 from address 105 is loaded into the accumulator



    Input and output
There are two instructions provided for input or output. In each case the instruction has only
an opcode; there is no operand.

e      The instruction with opcode IN is used to store in the ACC the ASCII value ofa character
       typed at the keyboard.

e      The instruction with opcode OUT is used to display on the screen the character for which
       the ASCII code is stored in the ACC.


Comparisons and jumps
A program might need an unconditional
                                  jump or might need a jump if a condition is met.
    In the second case, a compare instruction is executed first. Table 6.08 shows the format for
these types of instruction.
Cambridge International AS & A Level Computer Science




    Instruction opcode       Instruction         Explanation
                             operand

    JMP                      <address>           Jump
                                                    to the given address

    CMP                      <address>           Compare the contents of ACC with the contents of
                                                 <address>

    CMP                      #n                  Compare the contents of ACC with the number n

    CMI                      <address>           Indirect addressing. The address
                                                                                to be used is at the

                                                 given address. Compare the contents of ACC with the
                                                 contents of this second address

    JPE                      <address>           Followinga compare instruction,
                                                                           jump to <address>
                                                 if the compare was True
    JPN                      <address>           Followinga compare instruction,
                                                                           jump to <address>
                                                 ifthe compare was False


Table 6.08 Jump and compare instruction formats


Note that the comparison is restricted to asking if two values are equal.

The result of the comparison is recorded by a flag in the status register. The execution ofthe
conditional jump instruction begins by checking whether or not the flag bit has been set.
This jump instruction does not cause an immediate jump. This is because a new value has
to be supplied to the program counter so that the next instruction is fetched from this newly
specified address. The incrementing of the program counter that took place automatically
when the instruction was fetched is overwritten.



Arithmetic operations
There are no instructions for general-purpose multiplication or division. General-purpose
addition and subtraction are catered for. Table 6.09 contains the instruction formats used for
arithmetic operations.


    Instruction opcode | Instruction operand | Explanation

    ADD                     <address>                 Add the contents of the given address to the ACC

    ADD                     #n                        Add the denary number
                                                                         n to the ACC

    SUB                     <address>                 Subtract the contents of the given address from
                                                      the ACC
    SUB                     #n                        Subtract
                                                            the denary number
                                                                          n from the ACC

    INC                     <register>                Add 1 to the contents of the register (ACC or IX)

    DEC                     <register>                Subtract 1 from the contents of the register (ACC
                                                      or IX)


Table 6.09 Instruction formats for arithmetic operations

Figure 6.03 shows a program to find out how many times 5 divides into 75.

The following should be noted concerning
                                      the program.

e    The first three instructions initialise the count and the sum.

e    The instruction in address 103 is the one that is returned to in each iteration of the loop;
      in the first iteration it is loading the value 0 into the accumulator when this value is already
     stored but this cannot be avoided.
                                                                 Part 1: Chapter 6: Assembly language programming




Memory address               Memory content

          100            LDD    200

          101            STO 202

          102            STO    203

          103            LDD    202

          104            INC ACC

          105            STO    202

          106            LDD    203

          107            ADD    201

          108            STO    203

          109            CMP    204

          110            JPN    103

          111            LDD    202

          112            OUT

          113            END




          200

          201            5

          202

          203

          204            75


Figure 6.03 A program to calculate the result
of dividing 75 by5


e   Thenext three instructions are increasing the count by 1 and storing the new value.

e   Instructions 106 to 108 add 5 to the sum.

e   Instructions 109 and 110 check to see if the sum has reached 75 and if it has not the
    program begins the next iteration of the loop.

e   |nstructions 111 to 113 are only used when the sum has reached 75 which causes the
    value 15 stored for the count to be output.


Shift operations
There are two shift instructions available:

e   LSL         #n

    where the bits in the accumulator are shifted logically n places to the left

e   LSR         #n

    where the bits are shifted to the right.

in a logical shift no consideration is given as to what the binary code in the accumulator
represents. Because a shift operation moves a bit from the accumulator into the carry bit


    KEY TERM
   Cambridge International AS & A Level Computer Science




   in the status register this can be used to examine individual bits. For a left logical shift, the
   most significant bit is moved to the carry bit, the remaining bits are shifted left and a zero is
   entered for the least significant bit. For a right logical shift, it is the least significant bit that is
   moved to the carry bit and a zero is entered for the most significant bit.

   lf the accumulator content represents an unsigned integer, the left shift operation is a fast way
   to multiply by two. However, this only gives a correct result if the most significant bit is a zero.
   For an unsigned integer the right shift represents integer division by two. For example, consider:

                 00110001 (denary 49)            gives if right shifted       00011000 (denary 24)

   The remainder from the division can be found in the carry bit. Again, the division will not
   always give a correct result; continuing right shifts will eventually produce a zero for every bit.
   It should be apparent that a logical shift cannot be used for multiplication or division by two
   when a signed integer is stored. This is because the operation may produce a result where
   the sign of the number has changed.

   As indicated earlier, only the two logical shifts are available for the simple processor
   considered here. However, in more complex processors there is likely to be a cyclic shift
   capability. Here a bit moves off one end into the carry bit then one step later moves in at the
   other end. All bit values in the original code are retained. Left and right arithmetic shifts
   are also likely to be available. These work in a similar way to logical shifts, but are provided
   for the multiplication or division ofa signed integer by two. The sign bit is always retained
   following
          the shift.



102 Q   Cyclic shift: similar
                            to a logical shift but bits shifted from one end reappear at the other end
        Arithmetic shift: Uses the shift to carry out multiplication or division of a signed integer stored in the
        accumulator




   Bitwise logic operation
   The options for this are described in Table 6.10.


    Instruction            Instruction           Explanation
    opcode                 operand
    AND                    #Bn                   Bitwise AND operation of the contents of ACC with the
                                                 binary number n

    AND                    <address>             Bitwise AND operation of the contents of ACC with the
                                                 contents of <address>
    XOR                    #Bn                   Bitwise XOR operation of the contents of ACC with the binary
                                                 number n

    XOR                    <address>             Bitwise XOR operation of the contents of ACC with the
                                                 contents of <address>

    OR                     #Bn                   Bitwise OR operation of the contents of ACC with the binary
                                                 number n

    OR                     <address>             Bitwise OR operation of the contents of ACC with the
                                                 contents of <address>


   Table 6.10 Bitwise logical operation instructions


   The operand for a bitwise logic operation instruction is referred to as a mask because it can
   effectively cover some of the bits and only affect specific bits. Some examples of their use are
   given in Chapter 7 (Section 7.03).
                                                                    Part 1: Chapter 6: Assembly language programming




6.07 Further consideration of assembly
language instructions
Register transfer notation
Section 6.01 introduced an extension to register transfer notation. We can use this to
describe the execution of an instruction. For example, the LDD instruction is described by:

                                      Acc <     [[CIR(15:0)]]

The instruction is in the CIR and only the 16-bit address needs to be examined to identify
the location of the data in memory. The contents of that location are transferred into the
accumulator.



    TASK 6.02

    Use register transfer notation to describe the execution of an LDI instruction.



Computer arithmetic
In Chapter 1 (Section 1.03) we saw that computer arithmetic could lead to an incorrect
answer if overflow occurred. In Chapter 5 (Section 5.02) we saw the possible uses of the
Status Register. The following worked example illustrates how the values stored in the Status
Register can identify a specific overflow condition.

The use of the following three flags is required:

e   thecarry flag, identified as C, which is set to 1 if there is a carry
e   the negative flag, identified as N, which is set to 1 if a result is negative
e   the overflow flag, identified as V, which is set to 1 if overflow is detected.


    WORKED EXAMPLE 6.01


    Using the status register during an arithmetic operation

    1   Consider
              the addition of two positive values where the sum of the two produces an answer that is too
        large to be correctly identified with the limited number of bits used to represent the values. For example,
        Figure 6.04 shows what happens if we use an eight-bit binary integer representation and attempt to add
        denary 66 to denary 68.

                  0100 0010

        +         0100 0100



                                     Flags:    NVC
                                              110
                  1000 0110

        Figure 6.04 An attempted addition of denary 66 to denary 68


        The answer produced is denary -122. Two positive numbers have been added to get a negative number.
        This impossibility is detected by the combination ofthe negative flag and the overflow flag being set to 1.
        The processor examines the flags, identifies the problem and generates an interrupt.


                                                                                                                      (Continued)
Cambridge International AS & A Level Computer Science




  2   Consider using the same eight-bit binary integer representation but this time we add two negative
      numbers (-66 and -68 in denary). The result is shown in Figure 6.05.

                   10111100

       +           10111110




                                  Flags:    NVC

                (1)0111 1010               oid
      Figure 6.05 An attempted addition of denary -66 to denary -68


      We get the answer +122. This impossibility is detected by the combination ofthe negative flag not being
      set and both the overflow and the carry flag being set to 1.



Extension Question 6.01
Carry out a comparable calculation for the addition in binary of -66 to +68. What do you think
the processor should do with the carry bit?



Tracing an assembly language program
One way of checking to see if an assembly language program has errors is to carry out a dry
(practice) run. The main feature ofthis will be to check how the contents of the accumulator
change as the program runs. The following two worked examples illustrate the process.


   WORKED EXAMPLE 6.02


  Tracing an assembly language program
  For this example the trace table needs a column for the accumulator, two for memory locations and one for
  the output.

  The tracing is based on an initial user input of 15, a second input of 27 and a final input of 31.

  The program is shown in Figure 6.06.


      100               IN

      101            STO 200

      102               IN

      103            STO 201

      104               IN

      105            ADD 200

      106            STO 200

      107            ADD 201

      108            INC ACC

      109              OUT

      110              END


  Figure 6.06 The assembly language program

                                                                                                                (Continued)
                                                              Part 1: Chapter 6: Assembly language programming




The completed trace table is shown in Figure 6.07

        Accumulator        Memory location 200 | Memory location 201                   Output
            15

                                     15

            27

                                                               27

            31

            46

                                     46

            73

            74

                                                                                         74


Figure 6.07 The trace table showing the execution of the program

Note that in this presentation the decision has been made to use a new row in the trace table for each
instruction in the program. This helps with checking. However, an alternative correct method is to enter a
value in a column in the first available position. For example in the Memory location 200 column the first two
rows could contain the 15 and 46. The other point to note is that if an instruction does not change an entry
ina column it is not necessary to enter the value stored again. The trace table only needs to show activity; it
does not have to record a complete set of values at each stage in the program execution.




WORKED EXAMPLE 6.03


Tracing an assembly language program

Some instructions for part ofa program are contained in memory locations 100 upwards. Some 4-bit binary
data values are stored in locations 200 upwards. For illustrative purposes the instructions are shown in
assembly language form. At the start of a part of the program, the memory contents are as shown in Figure 6.08.

Address            Contents                     Address             Contents
  100              LDD   200                       200                0001

  101              INC ACC                         201                0011

  102              ADD   201                       202                0101

  103              CMP   202                       203

  104              JPE   106

  105              DEC ACC

  106              INC ACC

  107              STO   203


Figure 6.08 The contents of memory addresses before execution of the program begins


The completed trace table for this example is shown in Figure 6.09. Because the program contains a jump
instruction it is necessary to record the values for the program counter as well as for the accumulator.


                                                                                                                  (Continued)
Cambridge International AS & A Level Computer Science




      Program counter PC | Accumulator ACC              Memory location 203

              100                     1000

              101                     0001

              102                     0010

              103                     0101

              104

              106

              107                     0110

              108                                                0110


  Figure 6.09 The contents of the program counter and accumulator during program execution


  The entries in the table can be explained as follows.

  e    The first row shows the stored value before execution ofthis part of the program.
       There will be a value in the accumulator resulting from an earlier instruction.

  e    Thesecond row shows the result of the execution of the instruction in location
       100 which loads a value into ACC; this is followed by the PC being automatically
       incremented.

  e    The next two rows show the value being changed in the ACC by the instructions in 101
       and 102 and the automatic incrementing of the PC each time.

  e    The fifth row has no new value in ACC because only a comparison is being done but
       there is an automatic increment of the PC.

  e    Thesixth row shows a new value in the PC which has resulted from the execution of
       the jump instruction which tested for equality and found it to be True.

  e    Theseventh row shows the result of the instruction in location 106 which has
       incremented the ACC.

  e    The final row shows the value stored in location 203.



Question 6.01
Can you follow through the changes in the trace table for Worked Example 6.03? Could it
be possible for the program to change the content in one of the memory locations 100-107
during execution?



  TASK 6.03

  Without looking at the explanations provided, trace the assembly language program
  show in Table 6.01. Use a value of 3 for MAX and then 7, 8 and 9 as input values.
                                                                   Part 1: Chapter 6: Assembly language programming




Reflection Point:
There are several references in this chapter to the content in earlier chapters. Have you
checked that you understand how the topics are related by revising the content in the earlier
chapters?




    Summary




Exam-style Questions

1   Three instructions for a processor with an accumulator as the single general purpose register are:

    LDD <addresss
               for direct addressing

    LDI       <addresss
                 for indirect addressing

    LDX <address> for indexed addressing

    In the diagrams below, the instruction operands, the register content, memory addresses and the
    memory contents are all shown as denary values.

    a     Consider
             the instruction LDD 103.

          i      Draw arrows on acopy of the diagram below to explain execution of the instruction.      [2]


                                                        Memory         Memory
                                                         address       content

                                                           100            116

                                                           101            114

                                                           102            112

                         Accumulator                       103            110
                 |                            |            104            108
                                                           105            106

                         Index register                    106            104

                 |              3             |            107            102

          ii     Give the contents of the accumulator as a denary value after execution of
                 the instruction.                                                                        [1]
Cambridge International AS & A Level Computer Science




    b = Consider
           the instruction LDI           107.

          i    Draw arrows on acopy of the diagram below to explain execution of the instruction.   [3]

                                                      Memory         Memory
                                                       address       content

                                                         100            116

                                                         101            114

                                                         102            112

                       Accumulator                       103            110
               |                            |            104            108
                                                         105            106

                       Index register                    106            104

               |              3             |            107            102

          ii   Give the contents of the accumulator as a denary value after execution of
               the instruction.                                                                     [1]

    c¢    i    Drawarrows on acopy of the diagram below to explain the execution of the
               instruction LDX 103.                                                                 [3]

                                                       Memory        Memory
                                                       address       content

                                                         100            116

                                                         101            114

                                                         102            112

                        Accumulator                      103            110
               |                            |            104            108
                                                         105            106

                       Index register                    106            104

               |              3             |            107            102

          ii   Give the contents of the accumulator as a denary value after the execution.          [1]

2   Every machine code instruction has an equivalent in assembly language. An assembly
    language program will contain assembly language instructions. An assembly language
    program also contains components not directly transformed into machine code
    instructions when the program is assembled.

    a__   Describe the use ofthree types of component of an assembly language program that
          are not intended to be directly transformed into machine code by the assembler.           [6]
    b     Complete the trace table for the following assembly language program. Note that the
          LDI instruction uses indirect addressing.                                                 [6]
                                                                Part 1: Chapter 6: Assembly language programming




                  Assembly language program
             Memory address              Memory content

                    100              LDD    201

                    101              INC ACC

                    102              STO    202

                    103              LDI    203

                    104              DEC ACC

                    105              STO    201

                    105              ADD    204

                    107              STO    201

                    108              END


                                f
                    201              10

                    202              0

                    203              204

                    204              5




                                                                     Memory addresses
                Accumulator
                                                          201         202       203       204

                      0                                   10           0        204        5




3   Consider the following assembly language program:

    <code>                IN

                          STO   CHARACTER

                          IN

                          SUB   #48

    START:                CMP   #0

                          JPN   OUTPUT

                          END

    OUTPUT:               OUT   CHARACTER

                          DEC   ACC

                          JMP   START

    CHARACTER:
Cambridge International AS & A Level Computer Science




    a         Explain what the program takes as input.                                                             [4]

              Explain what the program outputs.                                                                    [3]

    ¢         Complete the symbol table shown below which would be obtained from the first pass of a two-
              pass assembler. You can use denary numbers for addresses and you can assume that the first
              instruction is stored in address 0.


                        Label                                        Address




                                                                                                                   [4]
4   The table shows assembly language instructions for a processor which has one general purpose
    register, the Accumulator (ACC) and an index register (IX).

        Instruction                                   .
                                              Explanation
        Op code             Operand
        LDD                 <address>         Direct addressing. Load the contents of the given address to ACC.

        LDX                 <address>         Indexed addressing. Form the address from <address> + the
                                              contents ofthe index register. Copy the contents ofthis calculated
                                              address to ACC.
        STO                 <address>         Store contents of ACC at the given address.

    ADD                     <address>         Add the contents of the given address to ACC.

        INC                 <register>        Add 1 to the contents ofthe register (ACC or IX),

        DEC                 <register>        Subtract 1 from the contents of the register (ACC or IX).
        CMP                 <address>         Compare contents of ACC with contents of <address>.

        JPE                 <address>         Following a compare instruction,
                                                                          jump to <address> if the compare
                                              was True.

        JPN                 <address>         Following a compare instruction,
                                                                          jump to <address> if the compare
                                              was False.
        JMP                 <address>         Jump
                                                 to the given address.

        OUT                                   Output to screen the character whose ASCII value is stored in ACC.
        END                                   Return control to the operating system.


    a         The diagram shows the current contents of a section of main memory and the index register:

                  60   0011 0010

                  61   0101 1101

                  62   0000 0100

                  63   1111 1001

                  64   0101 0101

                  65   1101 1111

                  66   0000 1101

                  6/   0100 1101

                  68   0100 0101

                  69   0100 0011
                            J
               1000    0110 1001


              index register:} 0 |o0]o]o}]1]o]o]o|
                                                                        Part 1: Chapter 6: Assembly language programming




Show the contents of the Accumulator after the execution ofthe instruction:

                                              LDX 60

Accumulator}      |       |       |       |       |       of    |   |
Show how you obtained your answer.                                                                       [2|

Show the contents of the index register after the execution ofthe instruction:

                                              DEC IX

Indexregister:}       |       |       |       |       |        [||                                       [1]

                          Cambridge International
                                               AS &A Level Computer Science 9608 paper 11 Q9a June 2016
Chapter 7:
Monitoring and control systems

By the end of this chapter you should be able to:

m=   show anunderstanding of monitoring and control systems
m show understanding of how bit manipulation can be used to monitor/control a device.
                                                                   Part 1: Chapter 7: Monitoring and control systems




7.01 Monitoring systems
A monitoring system can be used to create a record of the condition ofa system over a
period of time. A monitoring system is used more often to detect when a particular physical
property ofa system goes outside a desired range; for example, if the CPU is too hot.


Discussion Point:
Set yourself a time limit of one minute. During this minute, by considering what measurement
will be involved, ask yourself how many different types of monitoring system you can identify.


Let’s consider temperature as an example. If this was being monitored under human control,
the measurement could be made with a standard mercury thermometer. However, in this
chapter we are interested in systems where a computer or microprocessor is being used.
These systems require a measuring device that records a value which can be transmitted
to the computer. Such a measuring device is a called a sensor. An example ofa sensor for
measuring temperature is a thermocouple, which outputs an electrical voltage that changes
with temperature.

It is important to understand that in a monitoring system, a sensor does not have any built-in
intelligence, so it cannot take any action if there is a problem. If the temperature measured
becomes dangerously high it is the computer that sounds an alarm.

There are a wide variety of sensors available. For some the name indicates the property
being measured such as pressure, humidity, carbon monoxide, pH or sound. For others
such as an infrared sensor there are different methods of use. A passive infrared sensor just
measures the level of infrared light received. In other cases, there is transmission of infrared
light with the sensor possibly measuring the level of the light that is reflected back. Other
sensors are given a generic name such as a motion sensor, for which different examples will
be measuring different physical properties.


Question 7.01
How many different types of motion sensor are you aware of?



7.02 Control systems
A control system has the monitoring activity plus the capability to control a system. The
control element ofa monitoring and control system needs a device called an actuator. An
actuator is an electric motor that is connected to a controlling device. It might be used for
switching on or off or for adjusting a setting.


   KEY TERMS




Discussion Point:
Refer back to the examples you identified as monitoring systems. How many were actually
control systems? If they were monitoring systems could they be modified to become control
systems?
Cambridge International AS & A Level Computer Science




 Figure 7.01 shows a schematic diagram of a computer-controlled environment.

 Note that Figure 7.01 includes an analogue-to-digital converter (ADC) and a digital-to-
analogue converter (DAC) as separate components. In a real system they are likely to be
 integral to the sensor or actuator device.

 For the system shown in Figure 7.01 there is a continuing process where the computer at
 regularly timed intervals signals the sensor to provide a measurement. If the measurement
value received by the computer is not in the desired range the computer initiates a control
 action. The next timed measurement will happen after this control action has taken place. In
 effect this next measurement provides feedback to the computer on the effect ofthe control
 action. Feedback is essential in a control system.


            Computer                     Digital control signal
                 or                                                     y|     DAC

       microprocessor


            -                                                       Analogue
                                                                     control
                                                                     signal

                   _                                                           Vv
                 Digital
                measured                                              Actuator

                  value                                                  and
                                                                     controlling
                                                                        device
                                                    Controlled
                                                   environment
                                    Analogue
                                    measured
                                     value
           ADC    \«                                   Sensor



 Figure 7.01 Computer-controlled environment



Oo   TIP

     You need to remember that a sensor does not have any built-in intelligence so it cannot itself take
     any action if a problem occurs.



 A closed-loop feedback control system is a special type of monitoring and control system
 where the feedback directly controls the operation. Figure 7.02 shows a schematic diagram of
 such a system. A microprocessor functions as the controller. This compares the value for the
 actual output, as read by the sensor, with the desired output. It then transmits a value to the
 actuator which depends on the difference calculated.

  Desired
 value for                                                                           Actual
  output              Controller         > A ctuator              > Process          output
                                                                                        ,

                          A




                       Sensor \«€



 Figure 7.02 Closed-loop feedback control system
                                                                            Part 1: Chapter 7: Monitoring and control systems




Question 7.02
Where would you be likely to find a closed-loop feedback control system?



7.03 Bit manipulation to control devices
The controlling computer or microprocessor has to have a real-time program running
continuously. The program can set values for Boolean variables subject to what the sensors
detect. For instance, ifa controlled environment had two properties to be monitored
and controlled, four Boolean variables could be used. Values could be set by assignment
statements such as:

IF    SensorDifferencel         >    0    THEN   SensorlHighFlag < TRUE


IF    SensorDifferencel         <    0    THEN   SensorlLowFlag < TRUE


IF    SensorDifference2          >   0    THEN   Sensor2HighFlag < TRUE


IF    SensorDifference2         <    0    THEN   Sensor2LowFlag < TRUE


Another part of the monitoring and control program would then be checking whether any of
the four flags were set. The machine code for running such a program could use individual
bits to represent each flag. The way that flags could be set and read are illustrated by the
following assembly language code fragments. In these code fragments the three least
significant bits (positions 0, 1 and 2) of the byte are used as flags.



 The following illustrates the setting of all bits to zero which might be used when the system is
 switched on.

 LDD    0034                  Loads a byte into the accumulator
                                                            from an address.

                              Uses a bitwise AND operation of the contents of the accumulator with the
 AND    #B00000000
                              operand to convert each bit to 0.

 STO    0034                  Stores the altered byte in the original address.

 The following illustrates the toggling of the value for one bit. This changes the value of the flag it
 represents. It might be needed because a problem has been encountered or alternatively because a
 problem has been solved.

 LDD    0034                  Loads a byte into the accumulator
                                                            from an address.

                              Uses a bitwise XOR operation of the contents of the accumulator with the
 XOR    #B00000001
                              operand to toggle the value of the bit stored in position 0.
 STO    0034                  Stores the altered byte in the original address.

 The following illustrates the setting of a bit to have value 1 irrespective of its existing value. This would be
 a simple way of just reporting a condition repetitively.
 LDD    0034                  Loads a byte into the accumulator
                                                            from an address,

                              Uses a bitwise OR operation of the contents of the accumulator with the
 OR    #B00000100             operand to set the flag represented by the bit in position 2. All other bit
                              positions remain unchanged.

 STO    0034                  Stores the altered byte in the original address.

 The following illustrates setting all bits to zero except one bit which is of interest. Following this operation,
 a comparison can be made with a binary value to checkif the bit is set. In this example the value would
 be compared to the binary equivalent of denary 2.
 LDD    0034                  Loads a byte into the accumulator
                                                            from an address.

                              Uses a bitwise AND operation of the contents of the accumulator with the
 AND    #B00000010            operand to leave the value in position 1 unchanged but to convert every other
                              bit to 0.

 STO    0034                  Stores the altered byte in the original address.
Cambridge International AS & A Level Computer Science




Reflection Point:
Are you clear that a bitwise logic operation acts on every bit individually; in effect all bits in
the accumulator are processed simultaneously?




         A monitoring system requires sensors.

         Asensor measures a physical quantity; there are many examples, such as temperature, humidity, pH,
         infrared, pressure, sound and carbon monoxide.

    =    Amonitoring and control system requires sensors and actuators.

         A program used for a monitoring and control system has to operate in real time with an infinite loop that
         accepts input from the sensors at timed intervals.

    m    The program transmits signals to the actuators if the values received from the sensors indicate a need
         for control measures to be taken.

    m=   Bit manipulation can be used within an assembly language program to monitor or control devices.




1    A farmer has a large barn to house poultry for the purpose of collecting the eggs that are
     laid. The environment inside the barn affects the egg-laying performance of the poultry.
     Traditionally, the farmer had routinely entered the barn to check that all was well with the
     environment. If there was a concern, the barn had facilities for correcting the problem.

     a     More recently a computer-based system has been installed. This allows the farmer
                                                                                          to
           observe data on a computer screen. If any of the data is of concern the system has
           been programmed to showa flashing red sign on the screen.

           i     _ Identify the type of system that the farmer has had installed.




                                                                                                                  —


                                                                                                                       a)
                                                                                                                   i
           ii      —|dentify the type of devices that have been installed inside the barn.                        [1


                                                                                                                       a)
           iii     Describe two examples of this type of device that could be used and explain what
                   their purpose is with respect to the functioning of the computer-based system.                 [6]

     b     The farmer has been told that there is no need for someone to be watching a screen
           all of the time. A different type of computer-based system could be installed.

           i     _ Identify the type of this new computer-based system.                                           (1)

           ii      Identify the new type of device that would need to be installed inside the barn.
                   (There would be more than one needed).                                                         [1]

           iii     Describe how the new computer-based system would interact with these devices.                  [2]

2    Anassembly language program has been written fora monitoring and control system.
     The program uses a byte stored in a register in which the bits can be individually set or
     cleared. An example is:

     ee
     Bits 0-3 are set to 0 initially but if one of the two sensors in the system sends a
     measurement
             that indicates a problem (measurement is too high or too low) the
     appropriate bit is set to value 1. Bits 4-7 are also set to 0 initially but if an actuator has to
     be switched on or off the appropriate bit is set to 1.

     a     Allof the bits in the register need to be set to 0. State which logical bitwise operation is
           required to be performed on the register content and give the operand that would be
           used for this. Complete your answer by filling in the boxes.
                                                                   Part 1: Chapter 7: Monitoring and control systems




          Logical bitwise operation is:


          |               _|
          Performed with the operand:


          Poot                                                                                             2
    b     Asensor has recorded a value that is too high so bit 2 must be set to 1 but the other bits
          must remain unaltered. State which logical bitwise operation is required to be performed
          on the register content and give the operand that would be used for this. Complete your
          answer by filling in the boxes.

               Logical bitwise operation is:



               Performed with the operand:


          Pot               ft     |                                                                       0
    c     Bit 4is set to 1 and bit 5 set to 0 but the sensor reading now indicates that there has been
          an over-reaction so the action of the actuator has to be reversed. This requires bits 4 and
          5 to have their values toggled. State which logical bitwise operation is required to be
          performed on the register content and give the operand that would be used for this.
          Complete your answer by filling in the boxes:

           Logical bitwise operation is:


          |               |
           Performed with the operand:


          P|         |      |      |      tt                                                               3
3   A gardener grows vegetables in a greenhouse. For the vegetables to grow well, the temperature needs
    to always be within a particular range.
    The gardener is not sure about the actual temperatures in the greenhouse during the growing season. The
    gardener installs some equipment. This records the temperature every hour during the growing season.
    a__   Identify the type of system described.                                                           (1]
    b     Identify three items of hardware that would be needed to acquire and record the temperature
          data. Justify your choice for each.                                                              [6]

          Item 1

          Justification

           Item 2

          Justification

           Item 3

          Justification
Cambridge International AS & A Level Computer Science




    c    The equipment records temperatures in the greenhouse. It does this for seven locations.
         Each recording is stored as two successive bytes. The format is shown below:

                         Greenhouse location                                   Temperature reading

              ~     6      5     4    3   2       41   0



                                 Byte 1                                              Byte 2

         The location is indicated by the setting of one of the seven bits in byte 1. For example, location 4
         is indicated by setting bit 4.

         Bit 0 of byte 1 acts as a flag:

         e        theinitial
                        value is zero

         e        when the reading has been processed it is set to 1

         Byte 2 contains the temperature reading (two’s complement integer).

         i         Explain the data in byte 1 shown below:

                     ~     6     5    4   3       2    #421   0


                   Fofolifofojo}oli]}                                    |fofofofi}ij}o}o]o|
                                      Byte 1                                              Byte 2                         [2|

         ii        Thesystem receives a temperature reading of
                                                             -5 degrees from sensor 6.

                   Complete the boxes below to show the two bytes for this recording. The reading has not yet
                   been processed.




                                      Byte 1                                              Byte 2                         [2|

    d    i         Theaccumulator is loaded with the value of byte 1 from location 106.

                   Write the assembly language instruction to check whether the reading in byte 2 came from
                   location 4.

                   LDD     106                                     //   data    loaded   from address          106       [4]

         ii        Write the assembly language instruction to set the flag (bit 0) of the byte contained in the
                   accumulator
                            to 1.                                                                                        [2]

                                               Cambridge International
                                                                    AS & A Level Computer Science 9608 Paper 31 Q5 June 2015

4   Anintruder detection system for a large house has four sensors. An 8-bit memory location
    stores the output from each sensor in its own bit position.

    The bit value for each sensor shows:

    e   1-thesensor has been triggered

    e   Q-thesensor has not been triggered

    The bit positions are used as follows:

                               Not used                           Sensor4      Sensor3   Sensor2     Sensorl
                               _A__




    The output from the intruder detection system is aloud alarm.

    a    i         Statethename of the type of system to which intruder detection systems belong.
                                                                                                                         —


                                                                                                                             a
                                                                                                                          i




         ii        Justify your answer to part (a)(i).
                                                                                                                         —


                                                                                                                             a
                                                                                                                          i
                                                                  Part 1: Chapter 7: Monitoring and control systems




b   Identify two sensors that could be used in this intruder detection system. Give a reason
    for your choice.                                                                                            [4]
    The intruder system is set up so that the alarm will only sound if two or more sensors
    have been triggered.

    An assembly language program has been written to process the contents of the
    memory location.

    The table shows part ofthe instruction set for the processor used.

     Instruction                                   .
                                           Explanation
     Op code           Operand
     LDD               <address>           Direct addressing. Load the contents of the given address to ACC.

     STO               <address>           Store the contents of ACC at the given address.

     INC               <register> | Add1to the contents ofthe register (ACC or IX).
     ADD               <address>     | Add the contents of the given address to the contents of ACC.

    AND                <address>           Bitwise AND operation of the contents of ACC with the contents of
                                        <address>.
     CMP               #n                  Compare the contents of ACC with the number n.

     JMP               <address>        Jump
                                           to the given address.

     JPE               <address>           Followinga compare instruction,
                                                                     jump to <address> if the compare
                                           was True.

     JGT               <address>           Followinga compare instruction, jump to <address> if the content
                                           of ACC is greater than the number used in the compare instruction,

     END                                   End the program and return to the operating system.


c   Part of the assembly
                     code is:

                                 Op code                 Operand
            SENSORS :                              B00001010
               COUNT :                             0

               VALUE :                             1
                   LOOP:                LDD      | SENSORS

                                       AND       | VALUE

                                        CMP | #0

                                        JPE      | ZERO

                                        LDD      | COUNT

                                           INC   | Acc

                                        STO      | COUNT

                   ZERO:                LDD      | VALUE

                                        CMP      | #8

                                        JPE      | EXIT

                                       ADD       | VALUE

                                        STO      | VALUE

                                        JMP      | LOOP

                   EXIT:                LDD      | COUNT

                   TEST:                CMP

                                        JGT      | ALARM
Cambridge International AS & A Level Computer Science




          Dry run the assembly language code. Start at LOOP and finish when EXIT is reached.

                     BITREG                                COUNT                                 VALUE                                   ACC

                BO00001010                                      0                                     1




                                                                                                                                                                            [4]
          The operand for the instruction labelled TEST is missing.

          State the missing operand.

          seveuesuesuessesscussuesnssnesessesnesussnssecuesnesvesssuesuesnessssssussuesussnessssesuesusenesscsesuesusssssessessesesessessessesessssessesssessesecaseeeseese® [1]

          The intruder detection system is improved and now has eight sensors.

          One instruction in the assembly language code will need to be amended.

          ICLentify this INStFUCTION oo. eeeecseesseecstecstessesssesssesseesssessecsssessscssecssscssecstessessuesssesssesseesssssesssecssesssecssesssesses

          Write the AMENdE INSEFUCTION                              ee ceeceeeccesecesesescsnscsvsvecevsvevscevscavscscscsenevsnevavevavavavavavavavstavatavasscscsesevenees [2|

                                                 Cambridge International
                                                                      AS & A Level Computer Science 9608 paper 31 Q6 June 2016
           ‘o/s


=e8 Dd So “4




    Chapter 8:
    System software

    By the end of this chapter you should be able to:

       explain why a computer system requires an Operating System (OS)
       explain the key management tasks carried out by the Operating System
       show understanding of the need for typical utility software provided with an Operating System
       show understanding of program libraries
       show understanding ofthe need for:
       «   assembler software for the translation of an assembly language program
       *   acompiler for the translation ofa high-level language program
       *   aninterpreter for translation and execution of a high-level language program
       explain the benefits and drawbacks of using either a compiler or an interpreter and justify the use of each
       show awareness that high-level language programs may be partially compiled and partially interpreted, such as Java
       describe features found in a typical Integrated Development Environment (IDE).
   Cambridge International AS & A Level Computer Science




   8.01 System software
   In the 1960s, the likely arrangement for using a computer would be something like this.

        Enter machine room with deck of punched cards and a punched paper tape                  reel.

        Switch on computer.
   N




        Put deck of cards into card reader and press button.
   W
   fb




        Put paper tape into tape reader and press button.
   ow




        Press button to run the program entered into memory from the punched cards using the
        data entered into memory from the paper tape.

        Press button to get output printed on the line-printer.

        Switch off computer.

        Leave machine room with deck of cards, paper tape and line-printer output.

   The user controlled the computer hardware by pressing buttons. Just try to imagine how
   many buttons would be needed if you had to control a computer in the same way today.

   The missing component from the 1960s computer was, of course, an operating system; in
   other words, some software to control the hardware and interact with application software.
   An operating system is an example of a type of software called ‘system software’. This
   distinguishes it from application software, which is created to perform a specific task fora
   computer user rather than just helping to run the system.



122 Q   Operating system: a software platform that provides facilities for programs to be run which are of
        benefit to a user




   8.02 Operating system activities
   Operating systems are extremely complex and it is not possible to give a full description
   here of what an operating system is. However, what an operating system generally does is to
   provide an environment where programs can be run that are of benefit to a user.

   The activities of an operating system can be sub-divided into different categories, some
   of which overlap with each other. We are going to look at each of the various tasks carried
   out by the operating system. Details of how some of them are carried out are discussed in
   Chapter 20 (Sections 20.01 to 20.05).



   User-system interface
   A user interface is needed to allow the user to get the software and hardware to do
   something useful. An operating system should provide at least the following for user input
   and output:

   e    acommand-line interface
   e    agraphical user interface (GU)).


   Discussion Point:
   Have you any experience of using a command-line interface?
                                                                                   Part 1: Chapter 8: System software




Program-hardware interface
Programmers write software and users run this software. The software uses the hardware.
The operating system has to ensure that the hardware does what the software wants it to do.
Program development tools associated with a programming language allow a programmer
to write a program without needing to know the details of how the hardware, particularly
the processor, actually works. The operating system then has to provide the mechanism for
running the developed program.



Resource management
When a program has started to run it is described as a process. In a modern computer
system, a process will not be able to run to completion without interruption. At any time
there will be many processes running on the computer system. Each process needs access to
the resources provided by the computer system.


    KEY TERM




The resource management provided by the operating system aims to achieve the best
possible efficiency in computer system use. The two most important aspects of this are:

e   scheduling
         of processes

e   resolution of conflicts when two processes require the same resource.


Memory management
There are three important aspects of memory management.

e   Memory protection ensures that one program does not try to use the same memory
    locations as another program.

e   Thememory organisation scheme is chosen to achieve the best usage of limited memory
    size, for example, virtual memory involving paging or segmentation.

e   Memory usage optimisation involves decisions about which processes should be in main
    memory at any one time and where they are stored in this memory.


Device management
Every computer system has a variety of components that are categorised as ‘devices’.
Examples include the monitor screen, the keyboard, the printer and the webcam. The
management of these requires:

e   installation of the appropriate device driver software
e   control of usage by processes.


File management
Three major features here are the provision of:

e   file naming conventions

e   directory (folder) structures

e   access control mechanisms.
Cambridge International AS & A Level Computer Science




Security management
Chapter 9 (Sections 9.02, 9.03 & 9.04) and Chapter 21 contain extensive accounts of security
issues and measures used to prevent problems. For the operating system the many aspects
of security management include:

e   provision for recovery when data is lost

e   prevention of intrusion

e   ensuring data privacy.


Error detection and recovery
Errors can arise in the execution ofa program either because it was badly written or because
it has been supplied with inappropriate data. Other errors are associated with devices not
working correctly. Whatever the cause of an error, the operating system should have the
capability to interrupt a running process and provide error diagnostics where appropriate.
In extreme cases, the operating system needs to be able to shut down the system in an
organised fashion without loss of data.



    TASK 8.01

    For each of the above categories of operating system task, each point could be
    placed in a different category. Make an abbreviated list of these categories and add
    arrows to show different categories where each point could be placed.



Question 8.01
It is useful to describe the management tasks carried out by an operating system as being
primarily one ofthe following types:

e   those assisting the user of the system

e   those concerned with the running of the system.

Considering the management tasks that have already been categorised, can you identify
them as belonging to one or other of the above types? Are there any problems in doing this?



8.03 Utility software
A utility program can be provided by the operating system or it can be installed separately.
It is a program that is not executed as part of the normal running of the operating system.
Instead it is a program that the user or the operating system can decide to run when needed.
For example, some utility programs manage hard disks.



Hard disk formatter and checker
A disk formatter will typically carry out the following tasks:

e   removing existing data from a disk that has been used previously

e   setting up the file system on the disk, based on a table of contents that allows a file
    recognised by the operating system to be associated with a specific physical part of
    the disk

e   partitioning the disk into logical drives if this is required.
                                                                                          Part 1: Chapter 8: System software




Another utility program, which can be a component of a disk formatter, performs disk
contents analysis and, if possible, disk repair when needed. The program first checks for
errors on the disk. Some errors arise from a physical defect resulting in what is called a ‘bad
sector’. There are a number of possible causes of bad sectors. However, they usually arise
either during manufacture or from mishandling of the system. An example is moving the
computer without ensuring that the disk heads are secured away from the disk surface.

Other errors arise from an event such as a loss of power or an error causing sudden system
shutdown. As a result some of the files stored on the disk might no longer be useable. A disk
repair utility program can mark bad sectors and ensure that the file system no longer tries to
use them. When the integrity of files has been affected, the utility might be able to recover
some of the data but otherwise it has to delete the files.



Hard disk defragmenter
A disk defragmenter utility also can be part of a disk repair utility program but it is not primarily
concerned with errors. A perfectly functioning disk will, while in use, gradually become
less efficient because the constant creation, editing and deletion of files leaves them in a
fragmented state. The cause of this is the logical arrangement of data in sectors as discussed in
Chapter
      3 (Section 3.04), which does not allow a file to be stored as a single block ofdata.

A simple illustration of the problem is shown in Figure 8.01. Initially file A occupies three
sectors fully and part ofa fourth one. File B is small so occupies only part ofa sector.
File C occupies two sectors fully and part of a third. When File B is deleted, the sector
remains unfilled because it would require too much system CPU time to rearrange the file
organisation every time there is a change. When File Ais extended it completely fills the first
four sectors and the remainder of the extended file is stored in all of Sector 8 and part of
Sector 9. Sector
               4 will only be used again if a small file is created or if the disk fills up, when it
might store the first part of a longer file.


                            Sectors 0-3            Sector 4     Sectors 5-7           Sectors 8-9
Initlial position            FileA        |        File B|          Filec     |


FileBis deleted     |        FileA                                  FileC     |   |                |

File Ais extended |             File A         |                    Filec     |   |    FileA   |    |

Figure 8.01 File fragmentation on a hard disk


A defragmenter utility program reorganises the file storage to return it to a state where all
files are stored in one block across a sequence of sectors. For a large disk this will take some
time. It will be impossible if the disk is too full because of the lack of working space for the
rearrangement.




  TASK 8.02

   If you have never used a disk defragmenter or disk repair utility program, can you get
   access to a system where you can use one? If so, note the changes that are carried
   out and recorded by the utility program.
                                                                                                                                              |
It is quite likely that you perform a manual backup of your own files every now end then using
a flash memory stick. However, an easier way to perform backup is to use a backup utility
program. Such a program   wilh

®            establish a schedule for backups
®            only create a new backup file when there has been a change



    ey   ort          Poway                             ga       Th             yey ns          as   myo       Voce?    SESE               i)       my   tet
    ‘     uy          Poa             XL                me       ay        XN     me           ay     CEES        7     aed                ret we   MS         y

     pa      ‘           z       =e                              5                              4
                                                                                             sont    tty
                                                                                                     clas                        4hyoe a
     a           WALES Waele      LN       AS                ‘        %   KES       x   XR     uh    PANE    CED   SA   Aa       vil:




meee
Be bik STE            Pe
                       PS RN RS
Pye CEP
      PS SSs aes
                             g




A file compression utility propram can be used regularly by an operating system to minimise
hard disk storage requirements. Whether or not the operating system does this, a user
can stil choose toinstall a suitable program, However, as was discussed in Chapter 1
(Section1.07) compression is most important when transmitting data. In particular, it makes
    ense to compress(or ‘Zip’} a file before attaching
                                                     it to an email.




A sus checking program shouldbe installed as a permanent fac lity to protect a computer
system. In an ideal world, it would only need to beused to scan a fle whenthe file initially
entered the system. Unfortunately, this ideal state can never
                                                            be realised. When a new virus
comes along there is a delay before it is recognised and a further delay before a virus checker
         3         been updated to deal with it. As a result, it is necessaryfor
                                                                               a virus checker to be repularly
updated and for itto scan all files on a cornputer system as a rnatter of routine
So       Se           Bee             eee        » SPB
                                                    >
                                                                     neon nee
                                                                            oe oe
BS ASS   ere Reese REESE RGESE es Poe
   REESE RRS SS ee BE ae Tees gs
                                  Select




The ‘programs’ in a programiibrary are usually subroutines createdto carryout particular
tasks. A programmer can use these within their ownprograms.

Allnewly developed programs
                         are likely to contain errors, which only become apparent as
theprograms are tes ted or used, ii savesa prograrnmer
                                                     a totof time and trouble to be able to
include alreacytriec                            and tested subroutines taken fram@ program library.

The most obvious examples of library routines are the built-in functions available for use
when programming in a particular language. Exampies of these are discussed in Chapter 14
(Section 14.07). Another example is the collection of over 1600 procedures for mathematical
and statistics processing available fromm the Numerical Algorithms Group (NAG) library. This
organisation has been creating routinessince 1971 and they are universally accepted as
being as reliable as software ever can be.

In Section 8.05, we will discuss the methods available for translation of source code, For now,
                                                                                                                             £




we simply need an overview of what happens, The source code is written in a programming
language
       of choice. ifa compiler is usec for thetranslation and no errors are found, the compiler
producesobject code imachinec
                           2 Code), This cade cannot be executed by itself. Insteadit has
to be linked with the code for any subroutines used by it.it is possible tocarry out thelinking
before loadingthe full code into memoryand runningth,
                  PH                                                                                                              _.
There is a major disadvantage in linking tibrary routines into the executable code. This is
because every program using a routine has to nave its own copy. This increases the storage
space requirernent for tne executable file. It also increases memory usage when more than
one process uses the routine.

The alternative is to use a routine from a dynamic linked library (DLL). When a DLL routine Is
available the executable code just requires a small piece of code to be included. This allows it
to link to the routine, which is stored separately in rnemory, when execution of the program
needs it. Many processes can be linked to the same routine. This has the advantage that
the executable files for all programs need less storage space. Memory requirement is aiso
minimised, Another advantage is                                   that if a new version of the routine becomes available it can
be loaced into mernary so that any program using it is automatically upgraded.

The main disadvantage of using a DLL is that the program is relying on the routine being
available and performing the expected function. If for sorne reason the DLL becomes


erroneous result. The user running the program will tind it difficult to establish what needs to
be done to get the program to run without error,

                                                                  ;




Set ak ae     a SE Sey      os ea               IS     SMS Sa GS ae
                       aa         Setacet




discussed in Chapter 6 (Sections 6.02, 6.03 & 6.04). This chapter will introduce the transiators
that are used to translate a program written in a nigh-level procedural language.


     _        »                                        .
FP ow RESS
SS    ees Sessa
           we  et es   Soy kt   Seats
                                 PSP            kyOT   Seon ae,
                                                       Ps
GOPMOHEPS SNC (MST                                     SISyYS




For an interpreter the following steps apply.

L        The interpreter program, the source code file and the data to be used by the source code


2

3        The first line of the source code is read,

4

&        (fan error is found, this is reported anc tne interpreter program halts execution.

6        if no error is found, the line of source code is converted to an intermediate code.

ri       The interpreter programm uses this intermediate code to execute the required action.
                                            &



8


Fora camp*piler the tcliowing steps apply.

4        The compiler program anc the source code file are made available but no data is needed.

2        The compiler program begins execution,




8        ivan error is found this is recorded,
                                                                               |
6   lfnoerroris found the line of source code is convertedto an intermediate code.

7   The next line of source code is reac andSteps4-7 are repeated.

    When the whole of the source code hasbeen deait with one of the following happens.

    e   (if noerroris found in the whole source code the complete intermediate code is
        converted into object code.

    e   ff any errors are found a list of these is output and no object code is produced

Execution oftheprogramcan only begin when the compilation has shown neo errors. This
can take place automatically under the contro! ofthe compiler program if data for the
program is available, Alternatively,the object code is stored and the program is executed
later withno involvement of the compile




The advantagesand cisadvantages to a programmer         of creating interpreted or compiled
programs.


»   Aninterpreter has advantapes when
                                    a program is being developed because errors can be
    identifiedas theyoccur and corrected immeciatel'y without| h havingto wait for the whole
    of the source code to be reac and analysed.

»   An interpreter has a disacvartage in that during a particular execution of the program,
    parts of the code which contain syntax errors may not be accessed soif errors are still
    present, they are not discovered until later,
«   Aninterpreter has a disadvantage when a program is error tree andis distributed        to users
    because the source code has to be sent to each user,

®   Acompiler has the advantage that an executabie file can be distributed to users, so the
    users have no accessto the source code.


The advantages and disadvantasa es to the user of interpreted or compiled programs.
                                  Oo




e   Foran interpreted program, the interpreter anc the source code have to be available each
    time that an error-free program is run.

«   Foracompiled program, only the object code has to be available each time that an error




    program.


«   Compiled object code is less secure because it couldcontain
                                                            a virus.


Whether an interpreter or a cornpiler isused, a program can only be run on a particular
computer with a particular processor if the interpreter or compiler program has been written
for that processor.


Ifthere is an optionavailable the choice of an interpreter
                                                         is justified when @ program is being
developed because:

e   oneerrorina program can lead to several other errors occurring

®   ar Herpreter can detect and correct an ea
                                           maryerror so
                                                      oesubsequent ones
                                                                                      Part 1: Chapter 8: System software




The choice of a compiler is justified when the programmer is confident that the program is as
near error-free as possible because:

e         an executable file can be created
e         this can be distributed for general use

e         execution of the program will be faster than if an interpreter were used.


Java
When the programming language Java was created, a different philosophy was applied to
how it should be used. Each different type of computer has to have a Java Virtual Machine
created for it. Then when a programmer writes a Java program this is compiled first ofall to
create what is called Java Byte Code. When the program is run, this code is interpreted by the
Java Virtual Machine. The Java Byte Code can be transferred to any computer that has a Java
Virtual Machine installed.



8.06 Features found in a typical Integrated Development
Environment (IDE)
Whatever language is used for writing source code and whatever compiler or interpreter is
being used there will be one or more IDEs available to assist the programmer. This section
discusses the types offeature that should be provided by an IDE.


Prettyprinting
Prettyprint refers to the presentation of the program code typed into an editor. For example,
the Python IDLE (see Figure 8.02) automatically colour-codes keywords, built-in function
calls, comments, strings and the identifier in a function header. In addition, indentation is
automatic.




    def       OutputSymbols (NumberOfSymbols,              Symbol):
            for    Count    in    range (NumberOfSymbols):
                  print (Symbol,      end='')
            print
                ()


    5 3    RRR RRR         main   program     starts   here   RRR REE RRR REE

    OutputSymbols(5,               '*')




Figure 8.02 Prettyprint in the Python IDLE


Context-sensitive prompts
This feature displays hints (or a choice of keywords) and available identifiers that might be
appropriate at the current insertion point of the program code. Figure 8.03 shows an example
of the Visual Studio editor responding to text typed in by the programmer.
Cambridge International AS & A Level Computer Science




                     — ConsoleApplicationi - Microsoft Visual Basic 2010 Express                                                                                            -(o)x|
                     File   Edit   View       Project      Debug    Data       Tools   Window   Help


                     PIG a-d@|sadlals2l9-¢-|> uo aeslQaeg 20.

                                                                                                       ~|    9 OutputChar
                            =       Sub SetValues(ByRef Symbol, ByRef MaxSymbols, ByRef Spaces, ByRef Symbols)                                                                    +=
                                                      ole.Write("“What symbol do you want to use? ")
   1 When you type ‘f’, a pop-up                           = Console.ReadLine()
                                                          jaxNumberOfSymbols(MaxSymbols)
     list appears, displaying all
                                                           =    (MaxSymbols + 1)         \ 2
     possible keywords and                                s=il
     identifiers starting with ‘F’

                                          OutputChar(ByVal Number,                      ByVal Symbol)
                                              Dim Count As Integer
                                                                           s                                          2 Choose the
                                                 Fineveckorvens                                                          required keyword
                                    End               .
                                               ® Fix
                                              &$ FlagsAttribute
                                              = For                                                                  For statement
                                              =] For EachTM                                                          Introduces a loop that is iterated a specified number of times.
                            =       sub       |% ForeignKeyConstraint                                                Note: Tab twice to insert the 'For) snippet.

                                               ® Format                                                          2rOfSpaces, Numberosy/fs)
                                               % FormatCurrency
                                               © FormatNateTime                                               ie               3 An explanation of the chosen
                    ee                                                                                                           construct appears. Pressing
                                                                                                                                 the TAB key twice will put the
                                                                                                                                 FOR loop construct into the code



Figure 8.03 Context-sensitive prompts in the Visual Studio editor


Dynamic syntax checks
When a line has been typed, some editors perform syntax checks and alert the programmer
to errors,

Figure 8.04 shows an example of the Visual Studio editor responding to a syntax error.


Ef ConsoleApplication1 - Microsoft Visual Basic 2010 Express
 File Edit View Project Debug Data                             Tools Window Help


EG a-d # is
         dials 2/9                                                                 -0           |p a                             |e lg
  i Module1
      ElModule Module
              Const Space          :=" "          '       constant to give a space a name
              Dim aed End of statement expected. F As Integer
              Dim MaxNumb                 ;                                ~                                                           The blue underline shows that there is a syntax error.
              Dim Symbol As Char

                                                                                                                                       As you move the mouse pointer over different parts of
                                                                                                                                       the line of code, the editor will display explanations.
 Error List

 Pr                                =                                             =# i                              |
                                                                                                                                        Here the mouse pointer hovered under the := symbol.
 Ready                                                                             Ln 42                    Col 56




Figure 8.04 Dynamic syntax check in the Visual Studio editor


Expanding and collapsing code blocks
When working on program code consisting of many lines of code, it saves excessive scrolling
if you can collapse blocks of statements.



Debugging
An IDE often contains features to help with debugging.


   KEY TERM
Ifa Debugger feature has been switched on it is possible to select a breakpoint. When the
program starts running it will stop when it reaches the breakpoint. The program can then be
stepped through, one instruction at a time. Figure 8.05 shows the windows presented to the
user in the Python IDLE when this feature is being used.



                                                                                                b
a
               debugging.py - G\Users\Sylvi                       vi                    -|0)
                                                                                           x}                                                            - (oO)
                                                                                                                                                              x!
        File     Edit       Format           Run       Options         Windows   Help                                                     I~ Stack J” Source
                                                                                                        Go | step | over { out | quit |
        Total           =    0                                                                                                            IV Locals J” Globals
        Numbers              =       0                                                                  debugging.py:4: <module>()

        NewNumber                    =       int (input())

                                                                                                    |                              Locals                         |
                NewNumber                    =   int (input())                                          NewNumber 8                                              iS
                Numbers                  =   Numbers          +        1                                Numbers        1
                Total            =       Total         +    NewNumber                                   Total          8
        Average             =        Total         /       Numbers                                        builtins     <module ‘builtins’ (built-in) >
        print (Total,                        Average)
                                                                                                        _doc_ None
                                                                                                        —_name_      9 —main_

                                                                                                        —Package__ one                                           z|

Figure 8.05 (a) A Python program showing a breakpoint; (b) the Debug Control window



    TASK 8.03

    Investigate the facilities in the editors you have available. If you have a choice of
    editors, you may like to use the editor with the most helpful facilities.



Reflection Point:
Much of the discussion in this chapter only summarises what an operating system does. Do
you think it would be helpful to move on immediately to have a look at some of the content in
sections 20.01 to 20.05 of Chapter 20?




    =   Operating system tasks can be categorised in more than one way, for example, some are for helping the
        user, others are for running the system.
    =   Utility programs include hard disk utilities, backup programs, virus checkers and file compression
        utilities.
    =   Library programs, including Dynamic Link Library (DLL) files, are available to be incorporated into
        programs; they are usually subroutines and are very reliable.

        A high-level language can be translated using an interpreter or a compiler.

        A Java compiler produces Java Byte Code which is interpreted by a Java Virtual Machine.

        An integrated Development Environment (IDE) contains many features that provide support for a
        programmer when a program is being written and when it is being corrected.
         Z   a         Oneofthe reasons for having an operating system is to provide a user interface to a
                       computer system.

                   i       identify two cifferent types of interface that an operating system should provide.                  2|

                   ii     = identify for each type of interface a device that could be used to enter data,                     2|

             ®    = Identity and explain briefly three other management tasks carried out by an


         2   @     APC operating system will make available to a user a number of utility programs.

                   i       identify twe utility prograrns that might be used to deal with a hard disk problem.                 2|

                   fi     = For each of these utility programs explain why it might be needed and explain




                                                                                                                                 eel
                                                                                                                               an
                   ii      identify twe other utility programs for a PC user.                                                  2|

             b         Library programs are mace available for programmers.

                   i       Explain why a prograrnmer should use library programs.                                             3

                   ii     = identify twe examples of a library program.                                                       2|

         3   Assemblers, compilers and interpreters are examples of translation programs.

             a     State the difference between an assembler
                                                          and a compiler or interpreter.                                       [1]

             b     Aprogrammercan choose to use an interpreter or a compiler.

    <x             i       State three differences between how an interpreter works and how a compiler works.                 3]

_                  i     = Discuss the advantages and disadvantages of an interpreter compared to a compiler.                 Al

                   iii     if a programmer choases Java, a special agproach is used. identify one feature of
                           this special approach,                                                                             [1]

         &   @     explain the meaning of the following terms:

                   Prettyprinting

                   Context-sensitive prompt

                   Dynamic syntax check

                   Debugging                                                                                                  8]
             ®     Describe the features you would expect a          debugger to provide.                                     Al

         §   Before it is used, a hard disk is formatted using disk formatter software.

             @     Explain why formatting is needed.                                                                          2]

             &     Eventually, the performance of the hard disk deteriorates.

                   Name three other utility programs that might be required. State why each is needed.                        6]

                                            Cambridge international AS & A Level Computer Science 9608 paper 12 O10 November 2015

         6   Aprogrammier is writing a program that includes code from a program             library.

             a     Describe two benefits to the programmier of using one or more library routines.                            ‘Al

             ®&    The programmer decides to use a Dynamic Link Library (DLL) file.

                   i       Describe twe benefits of using DLL files.                                                          iA]

                   ii      «State one drawback of using DLL files.                                                            :2|

                                             Cambriage international AS & A Level Computer Science 9608 paper 12 O8 November 2016
         ’       |        Die          SUS UPLA        ff


    (4       ;       CS         ff   plies                                     9



                                ‘ZL See                   ‘|                   0.
                                                                                9
                     (                  =r



                                                        rar
                          fb           2 m5 oa |||
                                               =            Gauaval

                                                            PUN                  eo.9 ®
                                       tS                                        Pav a


Security, privacy and data integrity

Learning objectives
By the end of this chapter you should be able to:

   explain the difference between the terms security, privacy and integrity of data
   show appreciation of the need for both the security of data and the security of the computer system
   describe security measures designed to protect computer systems, ranging from the stand-alone PC to a
   network of computers

   show understanding of the threats to computer and data security posed by networks and the Internet
   describe methods that can be used to restrict the risks posed by threats
   describe security measures designed to protect the security of data
   describe how data validation and data verification help protect the integrity of data
   describe and use methods of data validation
   describe and use methods of data verification during data entry and data transfer.
 Cambridge International AS & A Level Computer Science




 9.01 Definitions of data integrity, privacy and security
 Data integrity
 it is easy to define integrity of data but far less easy to ensure it. Only accurate and up-to-
 date data has data integrity. Any person or organisation that stores data needs it to have
 integrity. We will discuss ways to achieve data integrity in this chapter, and also in Chapter 11
 (Sections 11.01 & 11.02).


Qo
     Data integrity: a requirement for data to be accurate and up to date

     Data privacy: a requirement for data to be available only to authorised users




 Data privacy
 Data privacy is about keeping data private rather than allowing it to be available in the
 public domain. The term may be applied to a person or an organisation. Every individual
 has an almost limitless amount of data associated with their existence. Assuming that an
 individual is not engaged in criminal or subversive activities, he or she should be in control
 of which data about himself
                           or herself is made public and which data remains private.
 An organisation can have data that is private to the organisation, such as the minutes of
 management meetings, but we will not discuss this here.

 For an individual there is little chance of data privacy if there is not a legal framework in
 place to penalise offenders who breach this privacy. This framework is provided by a data
 protection law. The following aspects should be noted about such laws.

 e   The major focus relates to personal, therefore private, data that an individual supplies to
     an organisation.

 e   The data is supplied to allow the organisation to use it but only for purposes understood
     and agreed by the individual.

 e   Data protection laws oblige organisations to ensure the privacy and the integrity of
     this data.

 e   Unfortunately, having laws does not guarantee adherence to them but they do act as a
     deterrent if wrong-doers can be subject to legal proceedings.


CB eve
     Data protection law: a law that relates to data privacy




 Discussion Point:
 What data protection laws are in place in your country? Are you familiar with any details of
 these laws?


 Data protection normally applies to data stored in computer systems with the consent ofthe
 individual. Should these laws be extended to cover storage of data obtained from telephone
 calls or search engine usage?


 Data security
 Data are secure if they are available for use when needed and the data made available are
 the data that were stored originally. The security of data has been breached if any data have
 been lost or corrupted.
                                                                       Part 1: Chapter 9: Security, privacy and data integrity




Data security must be achieved before either data integrity or data privacy can be achieved,
but data security does not by itself guarantee either data integrity or data privacy. One of the
requirements for protection of data is the security of the system used to store the data. System
security does not just protect data. There are two primary aims of system security measures:

¢   to ensure that the system continues to carry out the tasks users need
e   to ensure that only authorised users have access to the system.




9.02 Threats to the security of a computer system and of
the data stored in it
The threats to the security of a system include the following types:

e   individual user not taking appropriate care
e   internal mismanagement
¢   natural disasters
e   unauthorised intrusion into the system by an individual
e   malicious software entering the system.




    TIP

    Try to keep a perspective with relation to hacking; it is only one of many security issues.




Threats to computer and data security posed by networks and the Internet
We are all continuously at risk from security threats to systems we use ourselves and to
all of the systems used by organisations upon which we rely. The dominant factor is that
none of these systems are stand-alone; all are connected to networks and through these
networks to the Internet. One cause of concern is the hacker who is someone intent on
gaining unauthorised access to a computer system. A hacker who achieves this aim might
gain access to private data. Alternatively, a hacker might cause problems by deleting files
or causing problems with the running of the system. The other major cause of concern is
malicious software entering the system.




Types of malware
Malware is the everyday name for malicious software. It is software that is introduced into a
system for a harmful purpose. One category of malware is where program code is introduced
to asystem. The various types of malware-containing program code are:

¢   virus: tries to replicate itself inside other executable code
¢   worm: runs independently and transfers itself
                                                to other network hosts
e   logic bomb: stays inactive until some condition is met
                                                                                                                           |
        ®         Trojan horse: replaces all or part of a previously useful program
        ® spyware:clect information and transmits it to another system
        e         bot: takes control of another computer
                                                      anc uses
                                                            it te launch attacks.

        The differences between the different types are not large andsome examples come into
        more than one ofthese categories. They
                                             virus category isoften subdivided according to the
                                                                            he   Ey




        software that the virus attaches itself to. Examples are boot sector viruses and macroviruses.

        Malware can also be classified in terms of the activity involved:

        ®         pnishing: sending an email or electronic message from an apparently legitimate source
                  requesting confidential inforrnation
        «         pharming: setting up a bogus website whichappears to be a legitimate site
        e         keylogger: recording keyboard usage by
                                                       the legitirnate user
                                                                          of the system,




                                     Soe               CORSO        Gyan [> ar                  DPS    HPS   Ary:     Be       i




        ae            =        3      gy   Oe 8    o    ~       x     .               5.   sa
        ALEER OWS BSE PP OR RRR sd ba
        SYSTOMN
              ~
                  WAY                 Sere ee
                               ELY GSES      or Beers Ge Re Ree ey
                                                POY USey ACV EY
        Many system            vulnerabilitiesare associated directly with the activities of legitimate users of a
        system, Two examples which do not involve maiware are as follows.

        «         The use of weak passwords and particularly thosewhich have a direct connection to the
    —             eeApoor anew
                             ot peTe abetoetewen “ bepeeraSHORE
                                                              @ chance of guessing
_                 :       pa:Sssword anc us eing able “ gain unau iorisec access.                                          7            7
=       » Altegitimate user not recognisinga phishing or pharming attack and, as a result, giving
                  away sensitive information.


        is introduced accidentally by the user. Typical examples of actions that might introduce



        »         attachinga portable
                                    storage device
        e         opening an email attachment


        ®         cowrloading a file from the Internet,


        RFy ebay « & web as        ror aay oy Bare een ga vadties soe maa ow ee reece hs          as
        WASP SHOAL Y GSES PPE! WSS S28 SYSESN ASSES
        fag  -    -                      Ay et                                    H
        Systems themselves often have security weaknesses.The foliowing are examples ofLat;
                                                                                                                               ;    -




                                                                                        this,

        1         Operating systems often lack good security. Over |Hime, there is a tendency                                  for operating
                  systems to increase in complexity, which leads                  to more opportunities for weaksecurity.
                  Operating systems have regular updates, often becaL se ofa newly ciscoverec security
                  vulnerability,

        2         Inthe past, commonly used application packages allowed macro viruses to spread, but
                  this particularproblem is now largely under control.
        3         Avery specific vulnerability         is buffer overflow, Programs written in the C programming
                  languape,
                         of which there are very many, do not automatically
                                                                         carry oult arraybound checks.
                  A program can bewritten to deliberately write code to the part of                                 memorythat is outside
                                                                                                                                       the
                  address range cetined for the                array, set up as
                                                                              a buffer. The programm overwrites
                                                                                                           what is stored
                  there so when a tater program reads this overwritten section it wil nat execute as an
                  Sometimes this only causes minor disruption,but a cleverlydesigned program can perm!
                  anattacker
                          to gain             unauthorised access to the system and cause serious problems.
                                                                Part 1: Chapter 9: Security, privacy and data integrity




9.03 Security measures for protecting computer systems
Disaster recovery
Continuity of operation is vital for large computer installations that are an integral part of the
day-to-day operations of an organisation. Measures are needed to ensure that the system
continues working whatever event occurs or, if there has to be a system shut-down, at the
very least to guarantee that the service will start again within a very short time.

Such measures come under the general heading of disaster recovery contingency planning.
The contingency plan should be based on a risk assessment. The plan will have provision for
an alternative system to be brought into action. If an organisation has a full system always
ready to replace the normally operational one, it is referred to as a ‘hot site’. By definition,
such a system has to be remote from the original system to allow recovery from natural
disasters such as earthquake or flood.


Safe system update
A special case of system vulnerability arises when there is a major update of hardware and/
or software. Traditionally, organisations had the luxury of installing and testing a new system
over a weekend when no service was being provided. In the modern era, it is more usual to
have systems that can be accessed at any time and (often) from any location. A company is
never closed for business. As a result, organisations may need to have the original system
and its replacement running in parallel for a period to ensure continuity ofservice.


Discussion Point:
Major failings of large computer systems are well documented. You could carry out research
to find some examples. Find an example of where the crisis was caused by technology failure
and a different example where some natural disaster was the cause.



User authentication
Even ifa PC is used by only one person there should be a user account set up. User accounts
are, of course, essential for a multi-user (timesharing) system. The main security feature
ofa user account is the authentication of the user. The normal method is to associate a
password with each account. In order
                                 for this to be effective the password needs a large
number of characters including a variety of those provided in the ASCII scheme.


   KEY TERM


                On:   Verilicatlon OT a USEFS   | ler IUILY




  TASK 9.01

  1   Create an example of a secure password using eight characters (but not one you
      are going to use).

  2   Assuming that each character is taken from the ASCII set of graphic characters,
      how many different possible passwords could be defined by eight characters?
  3   Do you think this is a sufficient number of characters to assume that the password
      would not be encountered by someone trying all possible passwords in turn to
      access the system?
      Cambridge International AS & A Level Computer Science




      Alternative methods of authentication include biometric methods and security tokens. A
      biometric method might require examination of a fingerprint or the face or the eye. A security
      token can be a small item of hardware provided for each individual user that confirms their
      identity. Similar protection can be provided by software with the user required to provide
      further input after the password has been entered. Normal practice is to combine one of
      these alternative methods with the password system.



      Good practice
      General good practice that helps to keep a personal computer secure includes not leaving
      the computer switched on when unattended, not allowing someone else to observe you
      accessing the computer and not writing down details of how you access it.

      Users may attach portable storage devices to a system, but this increases the risk of
      transferring malware into the system. This risk is reduced by an organisation having a policy
      banning the use of such devices or at least limiting their use. Unfortunately, this is difficult if
      normal business processes require portability of data.



      Firewall
      The primary defence to malware entering a system through a network connection is to
      install a firewall. Ideally a firewall will be a hardware device that acts like a security gate at
      an international airport. Nothing is allowed through without it being inspected. Alternatively,
      a firewall can run as software. Data must enter the system, but it can be inspected
      immediately. A firewall can inspect the system addresses identified in the transmission
138   of data, but can sometimes also inspect the data itself
                                                            to check for anything unusual or
      inappropriate.



      — Ere
         Firewall: hardware or software that monitors and controls network traffic




      Digital signature
      If an incoming transmission is an email, you might want to check the identity of the sender.
      The solution is to insist that the sender attaches a digital signature to the email. Some details
      of this are discussed in Chapter 21 (Section 21.02).



      Anti-virus software and intrusion detection
      Security measures restricting access to a system do not guarantee success in removing all
      threats. It is therefore necessary to have, in addition, programs running on a system to check
      for problems. One option is to install what is normally referred to as anti-virus software but
      which is usually aimed at combating any type of malware. This carries out regular scans to
      detect any malware and to remove or deactivate it. Possibly special-purpose anti-spyware
      software might be installed. Another option is to install an intrusion detection system that
      will take as input an audit record of system use and look for examples that do not match
      expected system activity.

      Unfortunately, people intent on causing damage to systems are using methods that are
      becoming ever more sophisticated. The defence methods have to be improved continually to
      counter these threats.
                                                                    Part 1: Chapter 9: Security, privacy and data integrity




9.04 Security measures for protecting data
Recovering from data loss
In addition to problems arising from malicious activity there are a variety of reasons for
accidental loss ofdata:

e   adisk or tape gets corrupted

e   adisk or tape is destroyed

e   thesystem crashes

e   the file is erased or overwritten by mistake

e   the location ofthe file is forgotten.

For these reasons, every system should have a backup procedure to recover lost data.
The system administrator decides on the details of the procedure. The principles for the
procedure traditionally followed are straightforward:

e   afull backup is made at regular intervals, perhaps weekly

e   atleast two generations of full backup are kept in storage

e   incremental backups are made on a daily basis.

For maximum security the backup disks or tapes are stored away from the system in a fire-
proof and flood-proof location.

This works well when an incremental backup occurs done overnight with the full backup
handled at the weekend. With systems running 24/7, data in the system might be changing at
any time, and a simple approach to backup would leave data in an inconsistent state.

One solution is to have a backup program that effectively freezes the file store while data is
being copied. At the same time changes that are happening due to system use are recorded
elsewhere within the system. The changes can then be implemented once the backup copy
has been stored.

An alternative approach is to use a disk-mirroring strategy. In this case, data is simultaneously
stored on two disk systems during the normal operation of the system. The individual disk
systems might be at remote locations as part of a disaster recovery plan.



Restricting access to data
Ifa user has logged in, they have been authorised to use the computer system but not
necessarily all of it. In particular, the system administrator may identify different categories
of user with different needs with respect to the data they are allowed to see and use. A
typical example is that one employee should be able to use the system to look up another
employee's internal phone number. This should not allow the employee at the same time to
check the salary paid to the other employee.

The solution is to have an authorisation policy which gives different access rights to different
files for different individuals. Fora particular file, a particular individual might have no access
at all or possibly read access but not write access. In another case, an individual might have
read access but not unrestricted write access.


— Ere
    Authorisation: definition of a user’s access rights to system components
                                                                                                               i
Py  e
Re RSS  aa SS SEset
       EE        SS            Re   vad                     dene
                                                       SSE SS               S:
Poe   a     ae   S   oof       AS         ahS     oS   PALS SARS
P'S RELROAL
        LEE RS ARSE LSS LAS SRA EES




accessed by someone who overcomes security to break into the system. This type of access



(Sections 21,01, 21.03, 21.04, 21.05 & 24.96),


oy FES.
Be
   PRE PEERS
        Be oe SS SSSR
                 wat s Bo  ated oun da Dee shoeMitte SL ML Mia Mgt
                       EE SS CES ERS SR EEE Goeth She Soh Seoes he
                                                                   ere eg Bhs Bete: see



Data integrity can never be guaranteed, but the chances are improved if appropriate rneasures are
taken when data originally enters a system or when itis transmitted from one system to another,
                                                              fry,




                                                                   3c
                           £              slats        os
                                                                        a
                                                                            a




                           EASELS ALES
                                                                        ‘tee




                              HEA  .   A
                                                                        3




The term validation is a somewhat misleading one. It seems to imply that data is accurate
if it has been validated. This is far frorn the truth. For example, if entry ofa name is expected
but the wrong riame is entered, it will still be recognised as a name and therefore accepted as
valid. Validation can only prevent incorrect data if there is an attempt to input data that is of
the wrong type, in the wrong format or out of range.

Data validation is implemented by software associated with a data entry interface. There are
a number of different types of check that can be made. Typical exarnples are:




»         aleneth check, for example with a telepnone number

*         arange check, for exarmpie the month ina date must not exceed 12

«         alimit check, for example a maximum number ofyears for a person's age
«         atype check, for example only a numeric vaiue for the rnonth in a date

«         ar existence check, for example that a file exists with the filenarne referred to in the
          cata entry.


Sf  es   reg dy oy oe ak a eda oe    By
VFA TELE APIS OOF SET R Grete wy
PAPE EE SALSSRRRSESE Ged Leases SPs eee Oy


When data is entered into a system, verification means getting the user toe confirm that
the data entered was what was intended to be entered. Unfortunately, this still does not
mean that the data entered is correct. Double entry is one method of verification. The most
common example is when a user is asked to supply a new password. There will usually be a
request for the password to be re-entered.                                       Asecond method is to use a visual check of what


entered before sending the form off to its destination.




 method of verification. There are many different options here but they all require a calculation
to be made with the numbers that have been enterec, The final part of                                       the calculation
 involves an integer division frorn which the remainder is added as an extra one or two digits
at the end of the series of numbers. In one scheme where only a single check digit is alowed,
 the letter Xis used when the remainder is calculated as 16. When the data is subsequently
 read the same calculation is carried out and the result is compared to the check digit that nad
 been stored. This technique is used for a bar code or for the ISBN for a book.
                                                                       Part 1: Chapter 9: Security, privacy and data integrity




f KEY TERMS




Verification during data transfer
Itis possible for data to be corrupted during transmission. Often, this happens when an
individual bitis flipped from 1 to 0 or from 0 to 1. Verification techniques need to check on
some property associated with the bit pattern.

The simplest approach is to use a simple one-bit parity check. This is particularly easy to
do if data is transferred in bytes using a seven-bit code. Either even or odd parity can be
implemented in the eighth bit of the byte. Assuming even parity, this is the procedure.

1     Atthe transmitting end, the number of 1s in the seven-bit code is counted.

      If the count gives an even number, the parity bit is set to 0.
FWN




      Ifthe count gives an odd number, the parity bit is set to 1.

      This is repeated for every byte in the transmission,
un




      At the receiving end, the number of 1s in the eight-bit code is counted.
ao




      If the count gives an even number, the byte is accepted.

7     This is repeated for every byte in the transmission.

If no errors are found, the transmission is accepted. However, we cannot guarantee that
the transmission is error free. It is possible for two bits to be flipped in an individual byte,
which would mean that the transmission is incorrect but the parity check is passed.
Fortunately, this is rather unlikely so it is sensible to assume no error. The limitation of the
method is that it can only detect the presence of an error. It cannot identify the actual bit
that is in error. If an error is detected, re-transmission has to be requested.

An alternative approach is to use the checksum method. At the transmitting end a block is
defined as a number of bytes. Then, no matter what the bytes represent, the bits in each byte
are interpreted as a binary number. The sum ofthese binary numbers in a block is calculated
and supplied as a checksum value in the transmission. This is repeated for each block. The
receiver does the same calculation and checks the sum of the numbers with the checksum
value transmitted for each block in turn. Once again, an error can be detected but its position
in the transmission cannot be determined.




      TIP

      Don’t confuse a check digit with a checksum. A check digit is used for stored data; a checksum is
      only used for transmitted data.



Detecting the exact position of an error so as to correct it is considerably more complex.
One approach is to use the parity block check method. Like the checksum method this is a
longitudinal parity meaning that it is used to check a sequence of binary digits contained ina
number of bytes.
Cambridge International AS & A Level Computer Science




  WORKED EXAMPLE 9.01


  Using a parity block check

  At the transmitting end, a program reads a group of seven bytes as illustrated in Figure 9.01. The data is
  represented by seven bits for each byte. The most significant bit in each byte, bit 7, is undefined so we have
  left it blank.



                                   Seven-bit codes
                   1       0       1       0       0       1        1
                  0        1       1       0       0       0        1
                   1       0       1       1       0       0        0

                  0        0       1       1       1       0        0
                  0        1       1       0       0       1        0

                  0        1       1       0       0       0        1
                  0        1       1       0       0       0        1


  Figure 9.01 Seven bytes to be transmitted


  The parity bit is set for each of the bytes, as in Figure 9.02. The most significant bit is set to achieve even parity.


   Parity
    bits                           Seven-bit codes
      0           1        0       1       0       0       1       1
      1           0        1       1       0       0       0       1
      1           1        0       1       1       0       0       0

      1           0        0       1       1       1       0       0
      1           0        1       1       0       0       1       0

      1           0        1       1       0       0       0       1
      1           0        1       1       0       0       0       1


  Figure 9.02 Bytes with the parity bit set


  An additional byte is then created and each bit is set as a parity bit for the bits at that bit position. This
  includes counting the parity bits in the seven bytes containing data. This is illustrated in Figure 9.03.


  Parity
   bits                        Seven-bit codes
     0        1        0       1       0       0       1       1
     1        0        1       1       0       0       0       1
     1        1        0       1       1       0       0       0

     1        0        0       1       1       1       0       0
     1        0        1       1       0       0       1       0

     1        0        1       1       0       0       0       1
     1        0        1       1       0       0       0       1

     0        0        0       1       0       1       0       0   |< Parity byte

  Figure 9.03 Parity byte added


  The program then transmits the eight bytes in sequence.

                                                                                                                            (Continued)
                                                                  Part 1: Chapter 9: Security, privacy and data integrity




     At the receiving end, a program takes the eight bytes as input and checks the parity sums for the individual
     bytes and for the bit positions.

     Note that the method is handling a serial transmission so it includes longitudinal checking, but the checking
     algorithm is working on a matrix of bit values. If there is just one error in the seven bytes this method will
     allow the program at the receiving end to identify the position ofthe error. It can therefore correct the error
     so the transmission can be accepted.



Question 9.02
Assume that the seven bytes shown in Figure 9.04 contain data.


| 01001000 |       | 01000101 |     | 01110010 |     | 01100011 |

           | 00101100 |     | 01010101 |     | 00110010 |

Figure 9.04 Seven bytes to be transmitted


The most significant bit is set to 0 but it is undefined at this stage because a seven-bit ASCII
code represents character data. Choose a parity and change the value stored in the most
significant bit to match this parity for each byte. Then create the eighth byte that would be
used for transmission in a parity block check method.


Question 9.03
The eight bytes shown in Figure 9.05 have been received in a transmission using the parity
block method. The first seven bytes contain the data and the last byte contains the parity
check bits.


| 01001000 |       | 11000101 |     | 11110001 |     | 01100011 |

| 01001010 |       | 01010101 |     | 01110010 |     | 01110010 |

Figure 9.05 Eight bytes received in a transmission


a_    identify what has gone wrong during the transmission.

b    What would happen after the transmission is checked?


Reflection Point:
This chapter contains a lot of terminology. It is very easy to get confused about the definitions
of the different terms used. Have you considered how you are going to attempt to remember
all of the definitions and not get confused?
Cambridge International AS & A Level Computer Science




    Summary




Exam-style Questions

1   a   It is important that data has integrity.

        i      _ Identify the missing word in the sentence ‘Concerns about the integrity of data
                 are concerns about its

        ii      Validation and verification are techniques that help to ensure data integrity
                when data is entered into a system.

                 Explain the difference between validation and verification.

        iii.     Define a type of validation and give an example.

        iv       Even after validation has been correctly applied data may lack integrity when it
                 comes to be used. Explain why that might happen.

        Data should be protected from being read by unauthorised individuals.

        Explain two policies that can be used to provide the protection.

        Security of data is an important concern for a system administrator.

        i        Identify three reasons why data might not be available when a user needs it.
                                                                                                    WwW
        ii       Describe what could be features of
                                                  a policy for ensuring data security.

        It is important for mission-critical systems that there is a disaster recovery
        contingency plan in place.

        i        Define what type of disaster is under consideration here.
                                                                                                    NON




        ii       Define what will be a major feature of the contingency plan.

        Measures to ensure security ofa computer system need to be in place on a daily
        basis if the system is connected to the Internet.

        Describe two measures that could be taken to ensure security of the system.

        When data is transmitted measures need to be applied to check whether the data
        has been transmitted correctly.

        i‘       |f data consists of seven-bit codes transmitted in bytes, describe how a simple
                 parity check system would be used. Your account should include a description
                 of what happens at the transmitting end and what happens at the receiving end.
                                                                                                    wo




        ii      Analternative approach is to use a checksum method. Describe how this works.

        For either of these two methods there are limitations as to what can be achieved
        by them. Identify two of these limitations.
                                                                               Part 1: Chapter 9: Security, privacy and data integrity




    c    Adifferent method which does not have all of these limitations is the parity block
         check method.

         The following diagram represents eight bytes received where the parity block method has
         been applied at the transmitting end. The first seven bytes contain the data and the last byte
         contains parity bits.


         Bytel    {|   0   |    1   |   Oo     |   12   |   oO   |   oO   [|    1    ]    1   |

         Byte2    {    1   |    0   |   1      |   1    |   O    |   O    |     Of        1   |

         Byte3    {    1   |    1   |   o      |   1    |   oO   |   oO   |     oO   |    0   |

         Byte4    |    1   {|   0   |   o      |   1    |   2    |   1    |     0    |    ©   |

         Byte5    |    1   {|   0   |   1      |   1    |   Oo   |   O    [|    1    |]   0   |

         Byte6    |    1   {|   0   |   1      |   1    |   oO   |   oO   [|    oO   |]   1   |
         Byte7    |    1   {|   0   |   1      |   12   |   oO   |   oO   [|    oO   |]   1   |

         Bytes    |    o   |    o   |   o      |   1    |   o    |   1    [|    0    |    ©   |


         Identify the problem with this received data and what would be done with it by the
         program used bythe receiver.                                                                                 [4]

4   a_   Give the definition of the terms firewall and authentication. Explain how they can help
         with the security of data.                                                                                   [3]

    b    Describe two differences between data integrity and data security.                                           [2]

    c    Data integrity is required at the input stage and also during transfer of the data.

         i    State two ways of maintaining data integrity at the input stage. Use examples to
              help explain your answer.                                                                               [3]

         ii   State two ways of maintaining data integrity during data transmission. Use examples
              to help explain your answer.                                                                            [3]

                                             Cambridge International
                                                                  AS &A Level Computer Science 9608 paper 13 Q3 June 2015

5   Verification and validation can be applied during data entry.

    Describe what is meant by these terms. For each method, explain why it is needed.                                 [4]

                                    Cambridge International
                                                         AS &A Level Computer Science 9608 paper 12 Q8 November 2015
146




      Ethics and ownership

      Learning objectives
      By the end of this chapter you should be able to:

         show understanding of the need for and purpose of ethics as a computing professional

         show understanding ofthe need to act ethically and the impact of acting ethically or unethically for a given situation

         show understanding of the need for copyright legislation

         show understanding ofthe different types of software licencing and justify the use of a licence for a given situation

         show understandingof Artificial Intelligence (Al).
                                                                                          _ _ris—Cisisse— -_
See      ghee    Be    eB   Ty
he
 he oho os       Bae SS BE


                  of definitions of ‘ethics’.
You can find a nurnber                                          The following three sentences are examples
e       Ethics is the field of moral science.
e       Ethics are the moral principles by which any person is guided.
e       Ethics are the rules of conduct recognised in a particular profession or area of human life.

In this book, we will not use the first definition. The third definition isthe focus of thischapte
However, therules of conduct ofcomputer scientists and developers must reflect the mor‘al
prhreiples oF the se con definition. Here are some observations that core to mind when


Moral principles concern right or wrong. The concept of virtue is often linked to what Is
considered to be right. What is right and wrong can be considered from one of the following
viewpoints: philosophical, religious, legal or pragmatic.

Philosophical debate has been going on for well over 2000 years. Early thinkers frequently
cuoted in this context are Aristotle and Confucius but there are any more, Religions have
sormetimes incorporated philosaphies alreacly existing or have introduced their own. Laws
should reflect what is right and wrong. Pragmatism could be defined as applying common sense,

rhis chapter is not an appropriate olace to discuss religious beliefs, but we should remember
that religious beliefs do have to be considered in the working environment. LegalIssues
clearly impact on   working practices but they are rarely the primary focus in rules of conduct,
What remains as the foundation for rules of conduct are the philosophical viewsof right and
wrong and the pragmatic views of what is commion sense. These will constitute a frame of
reference forwhat follows in this chapter.


    ere Shey AEG,            it   nettoh   Bohsoe GN By             sate woeEESE
                                                          Eee oo gePERSE
EEE FSP PRPS) SSSR
Bui                            GP SS sah
                  PRL EYE RSEY Fae rare
        | PRS CO UES
No matter what their particular specialism is, any professional person is expected to act
ethically. A professional can receive guidance on ethical behaviour byjoining an appropriate
professional organisation. Such an organisation will have ¢ code of conduct that willincluce
reference to ethical practice,

For exarnpie, the BritishComputer Society (BCS) has a code of conduct that gives guidance
under four neadings:

%       Public Interest

2       Professional Competence and integrity

3       Duty to Relevant Authority
4       Duty to the Profession

TheAssociation for Computing Machinery (ACM) and the Institute of Electrical anc
                                                                 a global perspective anc
    Electronics Engineers (IEEE) are both based inthe USA but have
                                                                 Coce of Ethics
giobalinfluence. The IEEE- aeM Joint Task Force Software Engineering
    defines eight orinciples defined as follows.

    2   PUBLIC ~ Software engineers shall act consistently with the public interest.
    %   CLIENT                   - Software engineers shall act in a manner that is in the best
                      AND EMPLOYER
        vtoroste oftheir client and employer consistent with the public interest.
    3   PRODUCT - Software engineers shall ensure that their products and related modifications
        meet the highestprofessional standards possibie,
Cambridge International AS & A Level Computer Science




4    JUDGEMENT - Software engineers shall maintain integrity and independence in their
        professional judgement.

5       MANAGEMENT - Software engineering managers and leaders shall subscribe to and
        promote an ethical approach to the management of software development and
        maintenance.

6       PROFESSION - Software engineers shall advance the integrity and reputation of the
        profession consistent with the public interest.

     COLLEAGUES - Software engineers shall be fair to and supportive oftheir colleagues.

     SELF - Software engineers shall participate in lifelong learning regarding the practice of
     their profession and shall promote an ethical approach to the practice of the profession.

Despite the differences in the detail the codes are consistent with regard to the following:

e    the public interest or public good is a key concern

e    thecodes present fundamental principles

e    the professional is expected to exercise their own judgement

e    the professional should seek advice if unsure.



    WORKED EXAMPLE 10.01


    Applying ethics to a software engineering scenario

    In a real-life scenario there might be many individual clauses that should be considered when a judgement is
    to be made. For example, let’s consider the following scenario.

    You are employed by a company that develops software. You are working on a software engineering project
    to be delivered to a client. One day the project manager states that the project is running behind schedule.
    As a result, the time allocated for testing of the software will be limited to one week rather than the one
    month that was stated in the project plan.

    As a professional you could be guided in your thinking by referring to the eight principles listed above from
    the IEEE-CS/ACM Joint Task Force Software Engineering Code of Ethics.

    Considering them in turn your thinking might be as follows:

    1     You could probably rule out any immediate need to consider public interest.

    2     You would recognise that the end result might be the client being delivered a sub-standard product that
          would reflect badly on the reputation of your employer.

    3     You would identify the primary cause of concern as being the likely poor quality product likely to be
          delivered.

    4     You would realise that you needed to make a judgement as to what action, if any, you should take.

    5     You might identify the secondary cause of concern as being one of poor management.

    6     You would have some concern concerning how delivering a product with many errors would cause your
          profession to be judged badly but this would not be a primary concern.

    7     You would be concerned about your colleagues being put under pressure to deliver in an unrealistically
          short timescale.

    8     You would recognise that this was not an issue relating to your professional development.

                                                                                                                    (Continued)
                                                                                Part 1: Chapter 10: Ethics and ownership




    You would now consider what action to take. This is where you would need to make a judgement. You might
    consider four possible scenarios:
    1     You decide that this unprofessional behaviour by the project manager must be challenged. Following this
          challenge the decision is reversed.

    2     You decide that this unprofessional behaviour by the project manager must be challenged. However, your
          protests are ignored.

    3     You decide that no challenge is needed because although the testing will not be properly completed
          there will always be the opportunity to remedy the remaining errors in the code through routine
          maintenance following product installation.

    4     You decide that an immediate protest would be useless but you intend to raise the matter at a later time
          when the errors in the product have become evident.

    The first scenario is the ideal one where the appropriate ethical action leads to a fully-tested product. In the
    second scenario the professional has acted ethically but this has had no effect. The question is now whether
    anything else ought to be done. The remaining two scenarios are where unethical behaviour leaves the
    outcome of an unsatisfactory product being provided for the client.



Discussion Point:
Search the clauses for all eight principles of the IEEE-CS/ACM Joint Task Force Software
Engineering Code of Ethics code and identify the ones that mention documentation.

Why is documentation mentioned so many times?



10.03 The public good
In different parts of the IEEE-CS/ACM Joint Task Force Software Engineering Code of Ethics
code there is reference to:

e       the health, safety and welfare of the public

e       the public interest

e       the public good

e       public concern.

The BCS code has the statement that the professional should:

‘have due regard for public health, privacy, security and wellbeing of others and the environment’.

There is no further indication of how these should be interpreted. We can look at some
individual cases to illustrate what might be considered.

Fortunately, there are very few examples which have involved loss of life and certainly none
where large numbers of deaths were caused. However, there have been a number of incidents
where extremely large sums of money were wasted because of rather simplistic errors.

The first example is the Ariane 5 rocket which exploded 40 seconds after blast-off in 1996.
Approximately 500 million dollars’ worth of investment in development, scientific equipment
and launch costs were wasted. The problem was caused by a line of code that tried to
convert a 64-bit floating point number into a 16-bit integer. The resulting overflow crashed
the program and as a result also the rocket.

The second example also relates to space exploration. The NASA Mars Climate Orbiter
project centred on a space probe that was due to orbit Mars to study the climate. The probe
reached Mars but unfortunately failed to get into orbit. The cause of the problem was that all
                                                                                 |
of the software was supposed to use the S| system of units for all calculations. One group of
software engineers used the imperial system of units. This mismatch only caused a problem
at the stage wnen the calculations concerned with achieving orbit arcund Mars were
executed. This time the loss to the public purse was 125 million collars.

These examples illustrate the public interest in successful software engineering. There
is a strong argument that the correct application of the code of ethics with respect to
specification, development and testing of software could have saved a lot of money.




been commissioned in 2002. The project failed to produce a workable system. The estimated
amount spent on the program was 12 billion pounds, The initial estimated cost was less than
three billlon pounds. In exarnples like this the software engineers are not to blame, but if


wouid not have allowed this type of failure to occur.

In the three exarnples outlined above, the public concern was solely related to the costs
associated with a failed project. There was no public concern relating to the ethics of the
endeavour itself. in contrast there are many areas associated with computer-based systems
where there is       public concern about the nature of the endeavour or at least about what it has
lec to, Here are some exampies:

e®   powerful commercial companies being able to exert pressure on less powerful
     companies to ensure that the powerful company’s products are usec when alternatives
     mignt be more suitable or tess costly

     companies providing systems that do not guarantee security against unauthorised access
2




«    organisations that try to conceal information about a security breach that has occurred in
     their systems

®    private data transmitted by individuals to other incividuais being stored and mace
     available to security services



®    search engines providing search results with no concern about the quality of the content.

There is by no means a consistent public attitude te concerns tike this. This makes it difficult
for an individual software engineer
                                  to rake a judgement with respect to public good, Even if
the judgernent is that a carmpany is not acting in the public good, it will always be difficult for
an individual to exert any influence. There are recent exampies where individuals have ta KEN
action which has resulted in their life being severely affected.




           .                so              x                          x
 Sh
 BES   SR SFShan
       FESR      cen SAYS
              PLASER eyuece de cen    oe  ed SOLS
                                      GES SE aoe en gen
                                                     ER or bende
                                                         ees
See sh         BSS SEES bees SSESSS Bolt Be
                                 ri               “   a
                                                          = B Baye BAS
                                                             ‘Sapte!




Copyright is a formal recognition of ownership. If an individual creates and publishes some
work that has an element of originality, the incividual becornes the owner and can therefore
claim copyright, An exception is if the individual is working for an organisation. An organisation
can claim copyright for a published work if itis created by one or more individuals that work
for the organisation. Copyright cannot apply to an idea anc it cannot be claimed on any part
of a published work that was previously published by a different individual or organisation,
                                                                               Part 1: Chapter 10: Ethics and ownership




    KEY TERM




Copyright can apply to any of:

e   aliterary (written) work
e   amusical composition
e   afilm
*   amusic recording
e   aradio or TV broadcast
e   aworkofart
e   acomputer program.


Thejustification for the existence of copyright has two components. The first is that the
creation takes time and effort and requires original thinking, so the copyright holder should
have the opportunity to earn money for it. The second is that it is unfair for some other
individual or organisation to reproduce the work and to make money from it without any
payment to the original creator.

As with the case of data protection discussed in Chapter 9 (Section 9.01), laws are needed
to protect copyright. Different countries have different details in their laws but there is an
international agreement that copyright laws cannot be avoided, for example by someone
publishing the work in another country without the original copyright holder’s permission.

Typical copyright laws will include:

°   arequirement for registration recording the date of creation of the work
e   adefined period when copyright will apply
¢   apolicy to be applied if an individual holding copyright dies
*   anagreed method for indicating the copyright, for example the use of the © symbol.

When copyright is in place there will be implications for how the work can be used. The
copyright owner can include a statement concerning how the work might be used. For instance,
the ACM has the following statement relating to the code of ethics discussed in Section 10.02:

This Code may be published without permission as long as it is not changed in any way and it
carries the copyright notice. Copyright © 1999 by the Association for Computing Machinery,
Inc. and the Institute for Electrical and Electronics Engineers, Inc.

This is one of several possible variations referring to permissions that are granted when the work
has not been sold. If someone has bought a copy ofa copyrighted product there is no restriction
on copies being made provided that these are solely for the use of the individual. A general
regulation relates to books in a library, where a library user can photocopy part ofa book.



10.05 Software licensing
Commercial software
In one respect commercial software is no different to any other commercial product. It is
created and made available for sale by a company that is aiming
                                                              to make a profit. There is,
however, a significant difference. If you buy a computer you become the owner but if you buy
software you do not become the owner. The ownership remains with the vendor. As a buyer
you have paid for an end-user licence that allows you to use the software. It is normal that
                                                                                  |
the software license has to be paid for but there are a number of diferent options that might
be available:

e   A fee is paid for each individual copy of the software.
e   Acompany might have the aption of buying a site licence which allows a defined number
    of copies to be running at any one time.

®   Special rates right be available for educational use.

A company that normally sells the software licence may sometimes provide a license free
of charge. There are two possibilities. Shareware is commercial software which is mace


or a timited version of it. A beta test version of new software might be considered to come in
the shareware category. Freeware might be a limited version of a full package or possibly an
earlier version, The difference is that there is no time limit for the licence.

Whatever license is obtained by the user of the software the source code will not be provided
and the license will define limitations on the use of the software,

Examples of when using commercial software can bejustified include:

»   The software is available for immediate use and provides the functionality required
»   Thesoftware has been created to be used in conjunction with already installed software

»   There will be continuous maintenance anc support orovided

»   Taking advantage of a shareware offer might allow suggestions to be made as to how the
    software could be improved

e        ~
    Freeware      An
             can often   Ath,
                       offer      At
                              sufficient fometiarmalit    oar;
                                         functionality to serve a wreare
                                                                  user’s timitad maarle
                                                                         limited needs.




organisations. They are very similar in what they provide but there is a difference in their
underlying philosophies.

The Open Source Initiative makes open source software available. The philosophy here is
that the use of open source software will allow collaborative      development of software to take
place. The software is normally made available free of charge. The source code is provided.
The user of the software is free to use it, modify it, copy it or distribute it in accordance with
the terms defined by the license.



be free to use software in any way they wish. The software is not provided entirely free
of charge; there is a small fee to cover distribution costs. The free software is still open
source. However, there is a special feature of the license which is called ‘copyleft’, This is the
condition that if the software is modified the source code for the modified version must be
made available to other users under the same conditions of usage.

Examples of when using open source software can be justified include:

«   The full functionality needed can be provided for at most a nominal cost

«   Thesoftware could provide the required functionality with just a few modifications to the
    source code

»   Aconsortium of     developers are collaborating in producing a new software suite

»   The future    development of the software or the continuous provision of the existing
                                                                             Part 1: Chapter 10: Ethics and ownership




Discussion Point:
How often do you think that open licence software is being used? Should it be used more often?


  TASK 10.01

  Carry out a search to investigate some of the software available under an open
  licence.




   KEY TERMS




10.06 Artificial intelligence (Al)
Artificial intelligence (Al) depends on and draws from many other disciplines including:
philosophy, psychology, neuroscience, mathematics, linguistics and control engineering. The
only definitions of Al that are acceptable are at the same time so generalised that they are
not very practical. The following is a typical example:

Al concerns the use ofa computer or computer-controlled device to perform tasks normally
associated with intelligent behaviour by humans.

We will consider five aspects of intelligent human behaviour and discuss some applications
of Al that mimic this human behaviour.


Problem solving
One example is the development of a system that can play chess. This can be considered as
displaying artificial intelligence but this is only demonstrated because the rules of chess are
limited. A computer with sufficient storage capacity and processing power can investigate so
many options for a possible sequence of moves that a human cannot compete.

A second example is the traditional form of expert system that, for example, has been
developed to aid medical diagnosis. This is supplied with data and rules from living medical
experts. The expert system contains more knowledge than is possible for an individual
doctor to have. However, if the expert system is given a new situation that is not covered by
the data and rules it has been given, it cannot attempt a new or creative approach — unlike
a human.


Linguistics
Voice recognition and voice synthesis techniques are already developed and in use. One
example is if you phone a help line where you might be answered by a computer. Provided
that you answer questions clearly the computer might be able to identify your needs and
pass you on to an appropriate human who can help. However, this is a long way away from
the computer itself creating new questions based on your answers and providing the help
you need.
                                                                                                  Li
      Tracitiorsnalily robotshave been used in manufacturingprocesses, Here the robot is
      programmed to perform repetitivetasks. The action ofthe robot each time is triggered YO
      some mechanism. However, if anything                     unexpected happens the robot continues to opera
      as normal, regardless of any darnage being caused,

      There is now much research focussed onvihe development of autonomous rebots.These
      have to be fitted with sensors to enable the robot to take appropriate action depending on
      the information received tram thesensors. This is an example of perception in Al,

      Acevelopment ofthisconcept is the driveriess car. There are several examples available
                                                                                         or in
      developmentbut sofarthey have only been able to perform limited tasks. An exampleis the
      capability fora carto park itself
                                      in a vacant parking space.
      ny




                   VERE        SVS
            BASR    LER   RTS SS
       fe




            SME SES


      There are examples ofthe application of
                                            Al wherea program has been able to craw
      inferences (reach conciusions based on evidence) whichis a requirement for reasoning. The
      best examplesconcern the proving of mathematical theorems. Attempts have also been
      made todevelop techniques that can verify that software that has been created does indeed
      correctly ane“fully match the documented specification.

      Thisiscurrentlya very active area for the application of Al techniques. Machine learning is
                                           a task to performis seen to improve its performance as
      said to take placief a system that has
                                             to ‘experience’
oo it gains experience. TheAl systemhas access                    in the forrn ofa massive set of
      data. Bythe use                 of appropriate statisticalalgorithms the system learns from this data.

      One example is v                      he actions of users visiting websites to buy products arestored. The Al
      system then attempts to identify appropriate products to be acvertised when a user returns
      tothewebsite. if salesprogressively increase there is evidence that learning is taking place.

      Another example is the program that investigates incoming emails and rnakes decisions as to
      whether thesecan be classified as sparn and therefore shouldbe refused entry to the user inbox.




      The use of the Internet dominatesthe lives of a largeproportion of the wartd’s population.
      Global organisations that provide the systems underpinning this user activity are collecting
      and storing massive amounts of data concerning how the Internetis being used. if this data
      is only being used to enabie the organisation to increase its profits, this couldbe seen as
      normai business practice. However, if the data snot being> Securely stored if could get inte
      the wrong hands and be used for criminal or subversive activity.

      There are different concerns with respect to the introduction of autonomous mechanical
      products such as robots, robotic devices and criverless vehicles into our daily lives, There
      are arguments that technological cevelooments lead to emp oyrnent of more people to
      manufacture, service andinstall the new products. There is a further argument that more
      technology leads to less manual labour and therefore to increased leisure time. One counter
      argument is that more technology leadsto fewer jobs because machines are doing
                                                                                 the work,
      Anatheris that such developments simply make the rich richer and the poor poorer.

      Some people                    are excited by the introduction of driverlessvehicles, but other people believe
      that the notentia lfor accidents will be increased and that there are not enough measures to
      prevent accidents.
                                                                                                                        Part 1: Chapter 10: Ethics and ownership




Robots can be used in environments that would be dangerous for humans to enter.
Giving the robot the capability to act autonomously would make it more useful in such
environments.

The environmental impact of robot manufacture and disposal is probably the most
significant issue. Robots are manufactured and require materials for their construction. There
is only a limited supply of the raw materials needed. Also, all mechanical and electronic
devices eventually end up on the scrap heap contributing to the already serious problem of
waste products harming the environment and creatures living in this environment.

The use of improved expert systems to aid practising doctors and nurses is clearly a benefit.
However, if these systems came to replace doctors and nurses the social consequences are
difficult to predict.


Discussion Point:
Have you seen any recent information about new developments in Al?


Reflection Point:
is there an organisation in your country for professional computer scientists? If so, does it
encourage young people to join?




    Summary




Exam-style Questions

1   a    Complete the following sentences:

         i     Asacomputer professional your primary concern when faced with an issue should be



         ii    IF an issue arises YOU SHOU EXEFCISE YOUP ceecceccscsseesessessessessesesscssessessessesessessessssussessessestsecans

               ANC POSSIDY SCOK oe eeeeseeseeessecsessesesseeseesesnesesscsessecsesnesessessessesseseesessessessssessssuestesessessessestesessesses

         iii   You havea responsibility to act in accordance with the welfare Of wc cccccccesesesesesseeees



         iv    You are expected to act in the interests Of YOUP ..eccccccccsssesessessestestesssessesessessessessssseseseesees

               ANC OF YOUN veececcccccsesesecsessecsesnesecsessesscsussussssssssesvssussesscsseessssssessssnesessesscsessussutessussessetsessesiveseecteetaes
Cambridge International AS & A Level Computer Science




    b     Explain two reasons why documentation is mentioned so often in the ACM/IEEE code of
         conduct.                                                                                                     [4]
2   a     Copyright is an important consideration when something is created.

          i    = State what copyright primarily defines.                                                              [1]

         ii     When copyright is registered, some data will be recorded. Identify two examples of
                the type of data that would be recorded.                                                              [2]

         iii    Copyright legislation defines two conditions that will apply to the copyrighted work.
                identify one ofthese.                                                                                 [1]

         iv     When copyright has been established there are options for how usage will be controlled.
                Give two alternatives for the instructions that could be included in the copyright
                statement for the created item.                                                                       [2]

    b    When software is obtained there will be an associated licence defining how it can be used.

         i     | Forcommercial software, describe two different ways in which the licence might be
                applied and explain the benefits to the customer of one of these.                                     [4]

         ii     Define the difference between freeware and shareware.                                                 [2

3   Identify two applications of artificial intelligence. For each one identify an aspect of human
    intelligence that the application mimics. Either explain how the application will be a benefit
    or explain why there would be concern about its use.                                                              [8]

4   Bobby isa senior programmer at a software house which produces intruder detection software.
    He also runs his own software company which develops and sells various computer applications.

    The following table shows seven activities which Bobby carries out.

    Put a tick (W) in the appropriate column to identify if the activity is ethical or unethical.

     Activity                                                              Ethical             Unethical
     Gives away passwords used in the intruder detection
     software

     Uses source code developed at the software house for the
     software he develops for his own company

     Insists that staff work to deadlines

     Turns down training opportunities offered by his
     employer

     Writes and sells software that reads confidential data from
     client computers

     Fakes test results of safety-critical software

     Has the software applications developed overseas for sale
     in his own country                                                                                               [7]


                                    Cambridge International
                                                         AS & A Level Computer Science 9608 paper 12 Q5 November 2015

5   Ateam of software engineers is developing a new e-commerce program for a client.

    State three of the principles of the ACM/IEEE Software Engineering Code of Ethics. Illustrate
    each one, with an example, describing how it will influence their working practices.                              [6|

                                            Cambridge International
                                                                 AS & A Level Computer Science 9608 paper 11 Q6 June 2016
Chapter 11:
Databases


By the end of this chapter you should be able to:

   show understanding of the limitations of using a file-based   show understanding of how software tools found within a
   approach for the storage and retrieval of data                DBMS are used in practice

   describe the features of a relational database which          show understanding that DBMS carries out all creation/
   address the limitations of a file-based approach              modification of the database structure using its Data

   show understanding of and use the terminology associated      Definition Language (DDL)

   with a relational database model                              show understanding that the DBMS carries out all queries

   use an entity-relationship (E-R) diagram to document a        and maintenance of data using its DML

   database design                                               show understanding
                                                                                that the industry standard for both

   show understanding of the normalisation process               DDL and DML is Structured Query Language (SQL)

   explain why a given set of database tables are, or are not,   Understand given SQL (DDL) commands and be able to
   in 3NF                                                        write simple SQL (DDL) commands using a sub-set of

   produce a normalised database design for a description of     commands

   a database, a given set of data, or a given set of tables     write an SQL script to query or modify data (DML) which are

   show understanding ofthe features provided by a Database      stored in (at most two) database tables.

   Management System (DBMS) that address the issues of a
   file based approach
                                                                                                                            _..



                     simple scenario, A theatrical agencymakesbookingsfor bands arnd is setting
spa computerised system. Text files areto be usec. Oneof these text files is to store data
about individual band members. Each line of                          the fileis to contain the following data for one
band member:

«    Name

«    Contact details

e    Banking details

e    Band name

e®   Banc age        name


e    Band agent contact details

The intention is that this file could be used if the agency needed to contact the band member
directlyothrough the band’s agent. it‘could also beused attera gig when the band member
has te be paid. ignoring what would constitute contact details or banking details, we can
look at a snapshot of some of the data that might be stored for the rnember’s given name,
the rmember's family name and the band name. The file might have a thousand or more lines
of text. The following is a selection of some o of the data that might be containedin various
lines in the file:

Xiangfei         Tha           ComputerKidz

Mahesh           Ravuru        LITWL2ZZ

Dylan            Stoddart

Graham           Vandana       ITWLizz

Vandana          Graham        ITWiZz

Mahesh           Ravuru        ITWL2s

Precious         Olsen         ComputerkKidz

Precious         Olsen         ITWiZz

Itis clear that thereare problems with this data. lt wouldappear
                                                             that when the ¢
Vandana Graham was first entered, her names were insertedin the wrong order Alater
                                                                                                         A   ~t   y




correct entry was made without deletion of the original incorrect data. This type of problem
isnot uniqueto a file-based system. There is no validation techniquethatcould cetect the
original error. By contrast, validation should have ted to the correction of the mi ssing band
name for Dylan Stoddart. The Precious Olsen data are examples of duplication of data and
inconsistent cata.

There              anVerror that is riot evident from looking at the file contents. A bana
    is alseo possibly
nameCc ould     be entered here whenthat band doesn’tt ONESst.

The above discussicon shows how a file-based approach canlead to cata integBrity presblems in
an individual!   “le The reason is the lackof in-built control when¢                   lata is enterec The database

approach can prevent such problems or, at least, minimise the ch

                                       oad             .    a S28



                               A RYERSSP aS SES, ie FHS
                               oh   VASES   SS   Oe   LER   S oh   Pees




A differant srobler isiSalack of data privacy.The file above was designed so that the finance
section couldfind banking details anc the recruitment section could find contact details.
                                                                                                                      The




problem is that there cannot be any control of access to part
                                                            of a file, sofor example, staff
                                                                                          in
the recruitment section would be able to ac cess the banking details of band members. Data
privacy would be properly handled by a database
                                              system.
                                                                                                   Part 1: Chapter 11: Databases




Data redundancy and possible inconsistency in multiple files
Mindful of this privacy problem, the agency decides to store data in different files for different
departments ofthe organisation. Table 11.01 summarises the main data to be stored in each
department's file.


 vepa        E                              Vata   E         e   Sse   0


 Contract              Member names                    Band name_| Gig details
 Finance               Member names | Bank details                         Gig details

 Publicity                                             Band name_| Gig details
 Recruitment           Member names                    Band name                         Agent details


Table 11.01 Data to be held in the department files

There is now data duplication across the files. This is commonly referred to as data
redundancy. This does not mean that the data is no longer of use. Rather, it is a recognition
that once data has been stored in one file there should be no need for it to be stored again
in a different file. Unfortunately, some data redundancy cannot be avoided in file-based
systems. This can lead to data inconsistency, either because of errors in the original entry or
because of errors in subsequent editing. This is a different cause of data lacking integrity. One
of the primary aims of the database approach is the elimination of data redundancy.


   KEY TERM




Data dependency concerns
The above account has focused on the problems associated with storing the data in the files.
We now need to consider
                     the problems that might occur when programs access the files.

Traditionally a programmer wrote a program and at the same time defined the data files that
the program would need. For the agency, each department would have its own programs
that would access the department’s data files. When a programmer creates a program fora
department, the programmer has to know how the data is organised in these files, for example,
that the fourth item on a line in the file is a band name. This is an example of ‘data dependency’.

It is very likely that the files used by one department might have some data which is the same
as the data in the files of other departments. However, in the scenario presented above there
is no plan for file sharing.

A further issue is that the agency might decide that there is a need for a change in the data
stored. For instance, they might see an increasing trend for bands to perform with additional
session musicians. Their data will need to be entered into some files. This will require the
existing files to be re-written. In turn, this will require the programs to be re-written so that
the new files are read correctly. In a database scenario the existing programs could still be
run even though additional data was added. The only programming change needed would
be the writing of additional programs to use this additional data.

The other aspect of data dependency is that when file structures have been defined to suit
specific programs, they may not be suited to supporting new applications. The agency might
feel the need for an information system to analyse the success or otherwise ofthe gigs they
have organised over a number of years. Extracting the data for this from the sort of file-based
system described here would be a complex task that would take considerable time to complete.
Cambridge International AS & A Level Computer Science




11.02 The relational database
In the relational database model, each item of data is stored in a relation which is a special
type oftable. The strange choice of name comes from a mathematical theory. A relational
database is a collection of relational tables.

When a table is created in a relational database it is first given a name and then the attributes
are named. In a database design, a table would be given a name with the attribute names
listed in brackets after the table name. For example, the design for a database for the
theatrical agency might contain the table definitions shown in Figure 11.01.


        Member(MemberlD, MemberGivenName, MemberFamilyName, BandName., ...)

                                  Band(BandName, AgentID, ...)


Figure 11.01 Two tables in a database design for the theatrical agency


A logical view of some data stored in these tables is given in Table 11.02 and Table 11.03. Each
attribute is associated with one column in the table and is in effect a column header. The
entries in the rows beneath this column header are attribute values.


 MemberID         MemberGivenName                MemberFamilyName                 BandName
 0005             Xiangfei                       Jha                              Computerkidz
 0009             Mahesh                         Ravuru                           ITWizz

 0001             Dylan                          Stoddart                         Computerkidz
 0025             Vandana                        Graham                           ITWizz


Table 11.02 Logical view of the Member table           in a relational database


 BandName                                       | AgentID                       | ae
 Computerkidz                                    01
 ITWizz                                          O7


Table 11.03 Logical view of the Band table in a relational database

This is described as a logical view because an underlying principle for a relational database
is that there is no ordering defined for the attribute columns. At least one database product
does allow a view of a table and its contents. However, this is not in keeping with the
fundamental relational database concept that a query should be used to inspect the data in
a table. Queries are discussed later in the chapter.


— arr
   Relation: the special type of table which is used in a relational database

   Attribute: a column ina    relation that contains values

   Tuple: a row ina   relation storing data for one instance of the relation



Arow ina relation should be referred to as a tuple but this formal name is not always used.
Often a row is called a ‘record’ and the attribute values ‘fields’. The tuple is the collection
of data stored for one ‘instance’ of the relation. In Table 11.02, each tuple relates to one
individual band member. A fundamental principle ofa relational database is that a tuple is a
set of ‘atomic’ values; each attribute has one value or no value.
                                                                                            Part 1: Chapter 11: Databases




The most important feature of the relational database concept is the primary key. A primary
key may be a single attribute or a combination of attributes. Every table must have a primary
key and each tuple in the table must have a value for the primary key and that value must be
unique.

Once a table and its attributes have been defined, the next task is to choose the primary key.
In some cases there may be more than one attribute for which unique values are guaranteed.
In this case, each one is a candidate key and one will be selected as the primary key. A
candidate key that is not selected as the primary key is then referred to as a secondary
key. Often there is no candidate key and so a primary key has to be created. The design in
Figure 11.01 illustrates this with the introduction of the attribute MemberID as the primary
key for the Member table. Note that the primary key is underlined in the database design.

The primary key ensures integrity within the table. The DBMS will not allow an attempt
to insert a value for a primary key when that value already exists. Therefore, each tuple
automatically becomes unique. This is one ofthe features of the relational model that helps
to ensure data integrity. The primary key also provides a unique reference to any attribute
value that a query selects.

A database can contain stand-alone tables, but it is more usual for each table to have some
relationship to another table. This relationship is implemented by using a foreign key.


f KEY TERMS




Let’s discuss the use of a foreign key using the database design shown in Figure 11.01. When
the database is being created, the Band table is created first. BandName is chosen as the
primary key because unique names for bands can be guaranteed. Then the Member table is
created. MemberID is defined as the primary key and the attribute BandName is identified
as a foreign key referencing the primary key in the Band table. Once this relationship
between primary and foreign keys has been established, the DBMS will prevent any entry for
BandName in the Member table being madeif the corresponding value does not exist in the
Band table. This provides referential integrity which is another reason why the relational
database model helps to ensure data integrity.


Question 11.01
BandName is a primary key for the Band table. Does this mean that as a foreign key in the
Member table it must have unique values? Explain your reasoning.


   KEY TERM
Cambridge International AS & A Level Computer Science




11.03 Entity-relationship modelling
We can use a top-down method called stepwise refinement to break down the process of
database design into simple steps (see also Chapter 12, Section 12.08). At each step more
detail is added to the design. In database design this approach uses an entity-relationship
(E-R) diagram. Typically, this can be created either by a database designer or a systems analyst
working with the designer. We introduced the term ‘relationship’ earlier in connection with
the use of a foreign key. An entity (strictly speaking an entity type) could be a thing, a type of
person, an event, a transaction or an organisation. Most importantly, there must be a number of
‘instances’ of the entity. An entity is something that will become a table in a relational database.


   WORKED EXAMPLE 11.01


  Creating an entity-relationship diagram for the theatrical agency

  Let’s consider a scenario for the theatrical agency which will be sufficient to model a part ofthe final
  database they would need. The starting point for a top-down design is a statement of the requirement:

  The agency needs a database to handle bookings for bands. Each band has a number of members. Each
  booking is for a venue. Each booking might be for one or more bands.

  Step 1: Choose the entities

  You look for the nouns. You ignore ‘agency’ because there is only the one. You choose Booking, Band,
   Member and Venue. For each ofthese there will be more than one instance. You are aware that each booking
  is fora gig at a venue but you ignore this because you think that the Booking entity will be sufficient
                                                                                                       to hold
  the required data about a gig.

  Step 2: Identify the relationships

  This requires experience, but the aim is not to define too many. You choose the following three:
  e    Booking with Venue

  e    Booking with Band

  e    Band with Member.

  You ignore the fact that there will be, for example, a relationship between Member and Venue because you
  think that this will be handled through the other relationships that indirectly link them. You can now draw a
   preliminary E-R diagram as shown in Figure 11.02.


      Member                       Band                        Booking                        Venue


   Figure 11.02 A preliminary entity-relationship diagram


  Step 3: Decide the cardinalities of the relationships

   Now comes the crucial stage of deciding on what are known as the ‘cardinalities’ of the relationships. At
   present we have a single line connecting each pair of entities. This line actually defines two relationships
  which might be described as the ‘forward’ one and the ‘backward’ one on the diagram as drawn. However,
  this only becomes apparent at the final stage of drawing the relationship. First, we have to choose one of the
  following descriptions for the cardinality of each relation:
  e    one-to-one or 1:1

  *    one-to-many or 1:M

  e    many-to-one or M:1

  e    many-to-many or M:M.

                                                                                                                   (Continued)
                                                                                             Part 1: Chapter 11: Databases




Let’s consider the relationship between Member and Band. We argue that one Member is a member of only
one Band. (This needs to be confirmed as a fact by the agency.) We then argue that one Band has more than
one Member so it has many. Therefore, the relationship between Member and Band is M:1. In its simplest
form, this relationship can be drawn as shown in Figure 11.03.

        ,
 Member =                       Band



Figure 11.03 The M:1 relationship between Member and Band


This can be given more detail by including
                                        the fact that a member must belong
                                                                         to a Band and a Band must
have more than one Member. To reflect this, the relationship can be drawn as shown in Figure 11.04.


 Member ——
        >                 111   Band


Figure 11.04 The M:1 relationship with more detail


At each end ofthe relationship there are two symbols. One of the symbols shows the minimum cardinality
and the other the maximum cardinality. In this particular case, the minimum and maximum values just
happen to be the same. However, using the diagram to document that a Member must belong to a Band is
important. It indicates that when the database is created it must not be possible to create a new entry in the
Member table unless there is a valid entry for BandName in that table.

For the relationship between Booking and Venue we argue that one Booking is for one Venue (there must
be avenue and there cannot be more than one) and that one Venue can be used for many Bookings so the
relationship between Booking and Venue is M:1. However, a Venue might exist that has so far never had a
booking so the relationship can be drawn as shown in Figure 11.05.


           Py
 Booking   La                     Venue


Figure 11.05 The M:1 relationship between Booking and Venue


Finally for the relationship between Band and Booking we argue that one Booking can be for many Bands
and that one Band has many Bookings (hopefully!) so the relationship is M:M. However, a new band might
not yet have a booking. Also, there might be only one Band for a booking so the relationship can be drawn as
shown in Figure 11.06.


  Band     |
           >             o< Booking


Figure 11.06 The M:M relationship between Band and Booking


Step 4: Create the full E-R diagram

At this stage we should name each relationship. The full E-R diagram for the limited scenario that has been
considered is as shown in Figure 11.07.

            belongs to                    is booked for              is made at
  Member    >              H    Band        }              o< Booking Bo              t    Venue
                         has                              is for           is booked for


Figure 11.07 The E-R diagram for the theatrical agency’s booking database


To illustrate how the information should be read from such a diagram we can look at the part shown in
Figure 11.08. Despite the fact that there is a many-to-many relationship, a reading of a relationship always
considers just one entity to begin the sentence. So, reading forwards and then backwards, we say that:
                                                                                                                 (Continued)
Cambridge International AS & A Level Computer Science




                                         One Band is booked for zero or many Bookings

                                             One Booking is for one or many Bands

              is booked
                     for

                           is for


  Figure 11.08 Part of the annotated E-R diagram



Question 11.02
If you are deciding on the cardinality of the relationship between two entities does it matter
which one is put on the left and which on the right?



0   TIP

    Be careful not to confuse the two completely different terms relation and relationship.




11.04 A logical entity-relationship model
A fully annotated E-R diagram of the type developed in Section 11.03 holds all of the
information about the relationships that exist for the data that is to be stored in a system.
It can be defined as a conceptual model because it does not relate to any specific way of
implementing a system. If the system is to be implemented as a relational database, the E-R
diagram has to be converted to a logical model. To do this we can start with a simplified E-R
diagram that just identifies cardinalities.

Ifa relationship is 1:M, no further refinement is needed. The relationship shows that the entity at
the many end needs to have a foreign key referencing
                                                  the primary key of the entity at the one end.

lf there were a 1:1 relationship there are options for implementation. However, such
relationships are extremely rare and we do not need to consider them here.

The problem relationship is the M:M, where a foreign key cannot be used. A foreign key
attribute can only have a single value, so it cannot handle the many references required.
Another way of looking at this problem is to argue that a foreign key is required in each
entity but neither table could be created first because the other table needed to exist for the
foreign key to be defined. The solution for the M:M relationship is to create a link entity. For
Band and Booking, the logical entity model will contain the link entity shown in Figure 11.09.


    Band                            <<       Band-Booking        —                            Booking

Figure 11.09 A link entity inserted to resolve a M:M relationship

Extension Question 11.01
Is it possible to annotate these relationships?

With the link entity in the model it is now possible to have two foreign keys in the link entity;
one referencing the primary key of Band and one referencing the primary key of Booking.

Each entity in the logical E-R diagram will become a table in the relational database. It is
therefore possible to choose primary keys and foreign keys for the tables. These can be
summarised in a key table. Table 11.04 shows sensible choices for the theatrical agency’s
booking database.
                                                                                                        Part 1: Chapter 11: Databases




 Member                             MemberID                           BandName
 Band                              BandName

 Band-Booking                      BandName
                                          & BookingID                  BandName, BookingID
 Booking                           BookinglD                          VenueName
 Venue                             VenueName


Table 11.04 A key table for the agency booking database


The decisions about the primary keys are determined by the uniqueness requirement. The
link entity cannot use either BandName or Booking|D alone but the combination of the two
in acompound primary key will work.



  TASK 11.01

   Consider the following scenario. An organisation books cruises for passengers. Each
  cruise visits a number of ports. Create a conceptual E-R diagram and convert it
                                                                                  to a
  logical E-R diagram. Create a key table for the database that could be implemented
  from the design.




11.05 Normalisation
Normalisation is a design technique for constructing a set of table designs from a list of data
items. It can also be used to improve on existing table designs.




   TIP

   Unfortunately, you will be coming across a completely different use of the term normalisation
                                                                                                   in
   Chapter 16.




  WORKED EXAMPLE 11.02


  Normalising data for the theatrical agency

  To illustrate the technique, let’s consider the document shown in Figure 11.10. This is a booking
                                                                                                               data sheet
  that the theatrical company might use.

   Booking data sheet: 2016/023
  Venue:
      Cambridge International Theatre
      Camside
      CA1
  Booking date: 23.06.2016

    Bands booked              Number of band members                      Headlining
    Computerkidz                            5                                   Y
         ITWizz                             3                                  N
        DeadlyDuo                           2                                  N

 Figure 11.10 Example booking data sheet


                                                                                                                            (Continued)
     Cambridge International AS & A Level Computer Science




      The data items on this sheet (ignoring headings) can be listed as a set of attributes:

                                   (BookinglD, VenueName, VenueAddress1, VenueAddress2, Date,

                                             (BandName, NumberOfMembers, Headlining))

      The list is put inside brackets because we are starting a process oftable design. The extra set of brackets
      around BandName, NumberOfMembers, Headlining is because they represent a repeating group. |f there
      is a repeating group, the attributes cannot sensibly be put into one relational table. A table must have single
      rows and atomic attribute values so the only possibility would be to include tuples such as those shown
      in Table 11.05. There is now data redundancy here with the duplication of the BookinglD, venue data and
      the date.


       Booking | Venue Name                 Venue        Venue        Date          Band         Number           Headlining
       ID                                   Address1 | Address2                     Name         Of Members

       2016/023 | Cambridge                 Camside      CA1          23.06.2016   | Computer    5                Y
                   International Theatre                                            Kidz

       2016/023 | Cambridge                 Camside      CA1          23.06.2016    ITWizz       3                N
                   International Theatre

       2016/023   | Cambridge               Camside      CA1          23.06.2016   | DeadlyDuo | 2                N
                   International Theatre


      Table 11.05 Data stored in an unnormalised table


      Step 1: Conversion to first normal form (1NF)

ms    The conversion to first normal form (INF) requires splitting the data into two groups. At this stage we
      represent the data as table definitions. Therefore, we have to choose table names and identify a primary
      key for each table. One table contains the non-repeating group attributes, the other the repeating group
      attributes. For the first table a sensible design is:

                          Booking(Booking|D, VenueName, VenueAddress1, VenueAddress2, Date)

      The table with the repeating group is not so straightforward. It needs a compound primary key and a foreign
      key to give a reference to the first table. The sensible design is:

                        Band-Booking(BandName, Booking|D(fk), NumberOfMembers, Headlining)

      Again, the primary key is underlined but also the foreign key has been identified, with (fk). Because the
      repeating groups have been moved to a second table, these two tables could be implemented with no
      data redundancy in either. This is one aspect of INF. Also, we can say that for each table the attributes are
      dependent on the primary key.

      Step 2: Conversion to second normal form (2NF)

      For conversion to second normal form (2NF), the process is to examine each non-key attribute and ask if
      itis dependent on both parts of the compound key. Any attributes that are dependent on only one ofthe
      attributes in the compound key must be moved out into a new table. In this case, NumberOfMembers is only
      dependent on BandName. In 2NF there are now three table definitions:

                          Booking(BookingID, VenueName, VenueAddress1, VenueAddress2, Date)

                                  Band-Booking(BandName(fk), Booking|D(fk), Headlining)

                                            Band(BandName, NumberOfMembers)


                                                                                                                        (Continued)
                                                                                                    Part 1: Chapter 11: Databases




  Note that the Booking table is unchanged from INF. The Booking table is automatically in 2NF; only tables
  with repeating group attributes have to be converted. The Band-Booking table now has two foreign keys to
  provide reference to data in the other two tables. The characteristics of a table in 2NF is that it either has a single
  primary key or it has a compound primary key with any non-key attribute dependent on both components.

  Step 3: Conversion to third normal form (3NF)

  For conversion to third normal form (3NF) each table has to be examined to see if there are any non-key
  dependencies; that means we must look for any non-key attribute that is dependent on another non-key
  attribute. If there is, a new table must be defined.

  In our example, VenueAddress1 and VenueAddress2 are dependent on VenueName. With the addition of the
  fourth table we have the following 3NF definitions:

                                           Band(BandName, NumberOfMembers)

                                  Band-Booking(BandName(fk), Booking|D(fk), Headlining)

                                          Booking(Booking|D, Date, VenueName(fk))

                                    Venue(VenueName, VenueAddress1, VenueAddress2)

  Note that once again a new foreign key has been identified to keep a reference to data in the newly created
  table. These four table definitions match four of the entities in the logical E-R model for which the keys were
  identified in Table 11.04. This will not always happen. A logical E-R diagram will describe a 2NF set of entities
  but not necessarily a 3NF set.




———
   Repeating group: a set of attributes that have more than one set of values when the other attributes each
   have a single value




To summarise, if a set of tables are in 3NF it can be said that each non-key attribute is
dependent on the key, the whole key and nothing but the key.


Question 11.03
In Step 2 of Worked Example 11.02, why is the Headlining attribute not placed in the Band table?



  TASK 11.02

  Normalise the data shown in Figure 11.11.



      Order no:                                                                        Date:
         07845                                                                      25-06-2016
    Customer no:                     Customer name:              CUP

          056                            Address:         Cambridge square           Cambridge
    Sales rep no:          2         Sales Repname:       Dylan Stoddart

     Product                           a                             .      Price
                                                                                /
         no                       escriptio
                                 Description                Quantity         unit
                                                                                .           Total

        327                    Inkjet cartridges                24            $30           $720
        563                      Laser toner                    5             $25           $125
                                                                    Total Price             $835


  Figure 11.11 An order form
Cambridge International AS & A Level Computer Science




11.06 The Database Management System (DBMS)
The database approach
It is vital to understand that a database is not just a collection of data. A database is an
implementation according to the rules of a theoretical model. The basic concept was
proposed some 40 years ago by ANSI (American National Standards Institute) in its three-
level model. The three levels are:

e    the external level

e    the conceptual
                level

e    the internal level.

The architecture is illustrated in Figure 11.12 in the context ofa database to be set up for our
theatrical agency.


                                             External level

    | Program| | Program | | Program | | Program|        | Program |    | Program | | Program |
         NN                       NT
           Contract                  Publicity                Finance        Recruitment
             view                     view                     view              view

                ee           Ss
                                        TM..              eee

                                             Conceptual level



                                              Internal level




                                   | Physical storage |
Figure 11.12 The ANSI three-level architecture for the theatrical agency database


The physical storage of the data is represented here as being on disk. The details of the
storage (the internal schema) are known only at the internal level, the lowest level in the ANSI
architecture. This is controlled by the database management system (DBMS) software.

The programmers who wrote this software are the only ones who know the structure for
the storage of the data on disk. The software will accommodate any changes that might be
needed in the storage medium.

At the next level, the conceptual level, there is a single universal view of the database. This is
controlled by the database administrator (DBA) who has access to the DBMS. In the ANSI
architecture the conceptual level has a conceptual schema describing the organisation ofthe
data as perceived by a user or programmer. This may also be described as a logical schema.

At the external level there are individual user and programmer views. Each view has an
external schema describing which parts of the database are accessible. A view can support a
number of user programs.

An important aspect of the provision of views is that they can be used by the DBA as
a mechanism for ensuring security. Individual users or groups of users can be given
appropriate access rights to control what actions are allowed for that view. For example,
                                                                                                Part 1: Chapter 11: Databases




    a user may be allowed to read data but not to amend data. Alternatively, there may only be
    access to a limited number of the tables in the database.


f KEY TERMS




    The facilities provided by a DBMS
    You need to remember that databases come in a variety of forms ranging from a
    simple system created for one individual through to the central database for some
    large organisation. Some of the facilities provided by a DBMS are only relevant for large
    organisations, when their use will be controlled by a DBA.

    Whatever the size of the database, one option for its creation is to use the special-purpose
    language SQL which is discussed in the next section of this chapter. There are alternatives
    to SQL for most types of DBMS. The DBMS provides software tools through a developer
    interface. These allow for tables to be created and attributes to be defined together with
    their data types. In addition, the DBMS provides facilities for a programmer
                                                                               to develop a
    user interface. It also provides a query processor that allows a query to be created and
    processed. The query is the mechanism for extracting and manipulating data from the
    database. The other feature likely to be provided by the DBMS is the capability for creating
    a report to present formatted output. A programmer can incorporate access to queries and
    reports in the user interface.


»      KEY TERMS




    DBMS functions likely to be used by a DBA
    The DBA is responsible for setting up the user and programmer views and for defining the
    appropriate, specific access rights.

    An important feature of the DBMS is the data dictionary which is part of the database that
    is hidden from view from everyone except the DBA. It contains metadata about the data.
    This includes details ofall the definitions oftables, attributes and so on but also of how the
    physical storage is organised.

    There are a number of features that can improve performance. Of special note is the
    capability to create an index for a table. This is needed if the table contains a large number of
    attributes and a large number of tuples. An index is a secondary table that is associated with
    an attribute that has unique values. The index table contains the attribute values and pointers
    to the corresponding tuples in the original table. The index can be on the primary key or ona
    secondary key. Searching an index table is much quicker than searching the full table.


f KEY TERM
                                                                                                           —_
                                                                                                                ee          a
The integrity of the data in the database is a key concern. One potential cause of problems
occurs whena transaction is started buta syisterm problem prevents its completion.The
esull would be a database in an undefinedstate. The DBMS should have a built-in feature
that prevents this fromhappening. As with all systems, regular backup is a requirement. The
DBA will be responsiblefor backup of thestored data,




Bee    PaOP Bobecs gaocdee sacs
                              ed Fag oneene 2 seg eye soe ees Fee RE |
                                                oe             a          as      Ais        “   :



SQL
  is the programming language provided bya DBMS tosupportail
                                                           of the operations
associated witha relational database. Even when a database ackage offers high-level
software tools for user interaction, they create an implementation using SQL

Soak    PR  ada y   oe     5
Pea Pey PREMSoee eh eee es EF   ake eaye gears
                                                     fearsbe
                                                     ress
                                                               48
Rea Lad LSI E RS SERSAIE     § LS ES RRP RAF

Data Definition Language(DDL)
                            is                                      tof SOL providedfor creating or altering tables.
These commands only create the structure. They do not put any data into the database.

The following are some examples of DDL thatcould be usedin creating the database
designed in Worked example 11.02 for the theatrical agency:

          CREATE DATABASE BandBooking;

          CREATE           TABLE   Band     (




          ALTER TABLE Band ADD                        PRIMARY KEY              (BandName);

          ALTER TABLE Band-Booking ADD                                FOREIGN     KEY   (BandName REFERENCES

          Band(BandName);


These examples illustrate a number of general points regarding the writing of SQL.

e     The SQL consists of a sequence of commands.
e     Each command is terminated by ;

e     Acommand can occupy more than one line.
e     There isno case sensitivity,

»     Therehas been a decision mace here to use uppercase for the cammands and lower
         se for table nares, attribute names and catatypes.


e     Forthe CREATE TABLE comrnand this list is enclasedin parentheses
These examples show that once the catabase has been created, the tables can be created
and the attributes defined. itis possible to definea primary key and a foreignkey within the
CREATE TABLE command but the ALPER TABLE command can be used as shown Gi can
also be used        toadd extra attributes).

When an attribute
                is defined, its data type must bespecified. As with procedural languages
there can be different data types or different names for data types depending on which DBMS
is being used. One feature common to all databases
                                                 is that the number                                  ofcharacters allowed
for an attributecan be defined by inciuding
                                         the nurnberin brackets. In the above example
BandName varchar(25)                   allows upto 25 characters for the band name.
                                                                                              Part 1: Chapter 11: Databases




The following list shows some of the names that might be used to define a data type:
character, varchar, boolean, integer, real, date, time. In this chapter these will be written in
lower case, but you might see them written in upper case in other sources.



     TASK 11.03

     For the database defined in Worked Example 11.02, complete the DDL for creating
     the four tables. Use varchar(8) for BookingID, integer for NumberOfMembers, date
     for Date, character for Headlining and varchar(25) for all other data.



Data Manipulation Language (DML)
There are three categories of use for Data Manipulation Language (DML)

e    The insertion of data into the tables when the database is created

e    The modification or removal of data in the database

e    The reading of data stored in the database

The following illustrate the two possible ways that SQL can be written to populate a table
with data:

         INSERT   INTO   Band    (‘ComputerKidz’,       5);

         INSERT   INTO   Band-Booking      (BandName,         BookingID)

         VALUES   (‘ComputerKidz’,       ‘2016/023’);

The first example shows a simpler version that can be used if the order of the attributes is
known. The second shows the safer method; the attributes are defined then the values are
listed. The following are some points to note.

e    Parentheses are used in both versions.

e    Aseparate INSERT command has to be used for each tuple in the table.

e    There is an order defined for the attributes.

e    Although the SQL will have a list of INSERT commands the subsequent use of the table
     has no concept ofthe tuples being ordered.

The main use of DML is to obtain data from a database using a query. A query always starts
with the SELECT command. Two examples are:

The simplest form for a query has the attributes for which values are to be listed as output
identified after SELECT and the table name identified after FROM. For example:

         SELECT   BandName      FROM   Band;

Note that the components ofthe query are separated by spaces.

The Band table only has two attributes. To list the values for both there are two options:

         SELECT   BandName,     NumberOfMembers

         FROM   Band;

or

         SELECT   *   FROM   Band;

which uses * to indicate all attributes. Note that in the first example the attributes are
separated by commas but no parentheses are needed.

it is possible to include instructions in the SQL to control the presentation of the output. The
following uses ORDER BY to ensure that the output is sorted to show the data with the band
names in alphabetical order.
                                                                              mt
                                                                                                  =—_§é._ss




       SELECT    BandName,    NumberOfMembers

       FROM    Band

      ORDER     BY    BandName;

In this query there is no question of duplicate entries because BandName is the primary
keyof the BandName table. However,   in theBand-Booking table an individualvalue for
BandName will occur many times. if a query were being used to find which bands already
had a booking there would be repeated names in the output. This can be prevented bythe
use af GROUP BY as Ss! Own here:

       SELECT    BandName

       FROM Band-Booking

       GROUP    BY    BandName;

An extension of the control of the output from a query is to include a condition to limit the


       SELECT    BandName

       FROM Band-Booking
       WHERE    Head. ining   =    ‘Y¥’

       GROUP    BY    BandName;

which produces 4 single output for each band that has heaclined. Note how 2 query can have
several component parts which arebest presented on separate tines.
       SELECT BandName,       NumberofMembers
       FROM    Band

       WHERE    NumberOfMembers           >   2

       CRDBR    BY    BandName;

which excludesany duo bands.

It is possibleto qualify the SELECT statement by using a function. SUM, COUNTand AVG
are examples of functions that workon data held in several tupies es particularattribute
and return one vaiue. Forthisreason, these functions are called
                                                              aggregate functions. As an
example,thefoilowing code displays the number of membersin a band:
       SELECT    Count(*)

       FROM    Band;


This is a special case because there is no need to specify the attribute. An exampie using a
specific attribute would be
       SELECT AVG (NumberOfiMemb ers)
       FROM    Banda;


another example is:

       SELECT    SUM(NumberOfMembers)
       FROM    Bard;


                            a ‘join condition’ between data in two tables, Th emost frequently
used iS an inner join which is illustrated by:
       SELECT    VenueName,       Date

       FROM Booking

       WHERE Band-Booking.BookingID= Booking. BookingID
       AND Band-Booking.BandName = Lcomputerkide’;
The SOL uses the full definitive name for each attribute with the table name and attribute name
separated by a dot. The query contains two conditions. The way that the query works
                                                                                  is asfollows.

e   The Band-Booking
                 table is searched for instances where theBandNameis CamputerKidz.
®   Foreach instance the BookingiD is noted.
e    Then there is a search of the Booking table to find the examples oftuples having this value
     for BookingiD.

e    For each one found the VenueName and Date are presented in the output.

Some versions of SQL require the explicit use of INNER JOIN. The following is a possible
generic syntax:

          SELECT    tablel.columnl,        table2.column2...

          FROM    tablel

          INNER    JOIN    table2

         ON     tablel.common       field      =   table2.common
                                                            _ field;


The other use of DML is to modify the data stored in the database. The UPDATE command is
used to change the data. If the band ComputerkKidz recruited an extra member
                                                                          the following
SQL would make the change needed.

         UPDATE     Band

          SET   NumberOfMembers        =   6

         WHERE     BandName    =    ‘ComputerKidz’;

Note the use of the WHERE clause. If you forgot to include this the UPDATE command would
change the number of band members to 6 for all of the bands.

The DELETE command is used to remove data from the database. This has to be done with
care. If the ITWizz band decided to disband the following SQL would remove the name from
the database.

         DELETE     FROM    Band-Booking

         WHERE     BandName    =    ‘ITWizz’;

         DELETE     FROM    Band

         WHERE     BandName    =    ‘ITWizz’;

Note that if an attempt was made to carry out the deletion from Band first there would be an
error. This is because BandName is a foreign key in Band-Booking. Any entry for BandName
in Band-Booking must have a corresponding value in Band.


Reflection Point:
Did you find normalisation difficult? It would be surprising if you didn’t. Are you going to get
as much practice as possible? There are many questions from previous exam papers that
contain examples to try.




         A database offers improved methods for ensuring data integrity compared to a file-based approach.

    m    Arelational database comprises tables of a special type; each table has a primary key and may contain
         foreign keys.

         Entity-relationship modelling is a top-down approach to database design.

         Normalisation is a database design method that starts with a collection of attributes and converts them
         into first normal form then into second normal form and, finally, into third normal form.

    m=   Adatabase architecture provides, for the user, a conceptual level interface to the stored data.

    m    Features provided by a database management system (DBMS) include: a data dictionary, indexing
         capability, control of user access rights and backup procedures.

    m    Structured Query Language (SQL) includes data definition language (DDL) commands for establishing a
         database and data manipulation language (DML) commands for creating queries.
Cambridge International AS & A Level Computer Science




Exam-style Questions

1        a   Arelational database has been created to store data about subjects that students are studying.
             The following is a selection of some data stored in one of the tables. The data represents the
             student’s name, the personal tutor group, the personal tutor, the subject studied, the level of
             study and the subject teacher but there are some data missing:

                  Xiangfei                  3           MUB        Computing                A           DER

                  Xiangfei                  3           MUB        Maths                    A           BNN
                  Xiangfei                  3           MUB        Physics                  AS          DAB
                  Mahesh                    2           BAR        History                  AS          [JM

                  Mahesh                    2           BAR        Geography                AS          CAB


             i        Define the terms used to describe the components in a relational database table
                      using examples from this table.

             ii       If this represented all of the data, it would have been impossible to create this table.
                      Identify what has not been shown here and must have been defined to allow the
                      creation as a relational database table? Explain your answer and suggest a solution
                      to the problem.




                                                                                                                 NS
             iii      |s this table in first normal form (1NF)? Explain your reason.

    b        It has been suggested that the database design could be improved. The design suggested
             contains the following
                                 two tables:

                                   Student(StudentName, TutorGroup, Tutor)

                        StudentSubject(StudentName, Subject, Level, SubjectTeacher)




                                                                                                                       eee
             i      —_ Identify features of this design which are characteristic of a relational database.




                                                                                                                 NO UNO
                                                                                                                     ee
             ii       Explain why the use of StudentName here is a potential problem.

             iii.     }=Explain why the Student table is not in third normal form (3NF).

2   Consider
      the following scenario:

    A company provides catering services for clients who need special-occasion, celebratory
    dinners. For each dinner, a number ofdishes are to be offered. The dinner will be held at a
    venue. The company will provide staff to serve the meals at the venue.

    The company needs a database to store data related to this business activity.

    a        Anentity-relationship model is to be created as the first step in a database design.
             Identify a list of entities.
                                                                                                                 = SS




    b        Identify pairs of entities where there is a direct relationship between them.

    c¢       Foreach pair of entities, draw the relationship and justify the choice of cardinality
             illustrated by the representation.
                                                                                                       Part 1: Chapter 11: Databases




3   Consider
          the following booking form used by a travel agency.



                    Booking Number     00453


            Hotel:      Esplanade                                                Rating: = «+«

                        Colwyn Bay
                        North Wales


                                                                      Number of
                                Date              Room type              rooms              Room rate

                             23/06/2016        Front-facing double           2                   $80
                             23/06/2016        Rear-facing double            1                   $65
                             24/06/2016        Front-facing double           2                   $80



    a___      identify an unnormalised list of attributes using the data shown in this form. Make sure
              that you distinguish between the repeating and non-repeating attributes.                              [5]
    b         Demonstrate the conversion of the data to first normal form (INF). The design of two tables
              should be defined with the keys identified.                                                           (3]
    c — |dentify the appropriate table and demonstrate the conversion of the table to two tables in
              second normal form (2NF). Explain your choice of table to modify. Explain your identification




                                                                                                                    NG
              of the keys for these two new tables.

    d         identify which part of your design is not in Third Normal Form (3NF).
4   Asmall database is to be created with the following three tables:
           STUDENT(StudentiD, StudentName, StudentOtherName, DateOfbirth)
           SUBJECT(SubjectName, SubjectTeacher)

           TUTORIAL (StudentiD(fk), Subjectname(tk), WeekNumber, Day, PeriodNumber)

    a__       Using the appropriate datatypes from the following list:
              CHARACTER, VARCHAR2, Boolean, INTEGER, REAL, DATE

              Write the SQL scripts to create two ofthe tables using the CREATE TABLE command.
              Do not at this stage identify any keys.                                                               [5]
    b         Assuming that all three tables have been created, write the SQL scripts to assign the
              primary key in the SUBJECT table and the two foreign keys in the TUTORIAL table.                      (3]

    ¢         Write the SQL script that will list all of the student names in age order.                            (5)
              There is an aspect of the design of the tables that could cause problems. Explain
              this problem.                                                                                         [2

5   Aschoolstores a large amount of data. This includes student attendance, qualification and contact
    details. The school’s software uses a file-based approach to store this data.
    a __ The school is considering changing
                                          to a DBMS.

              i       State what DBMS stands for.                                                                   [1]
              ii      Describe two ways in which the database Administrator (DBA) could use the DBMS software
                      to ensure the security of the student data.                                                   [4]
              iii     A feature of the DBMS software is a query processor.
                      Describe how the school secretary could use this software.                                    [2]
Cambridge International AS & A Level Computer Science




         iv     TheDBMS has replaced software that used a file-based approach with a relational
                database.

                Describe how using a relational database has overcome the previous problems
                associated with a file-based approach.                                                          (3]

    b   The database design has three tables to store the classes that students attend.
                 STUDENT    (StudentID,    FirstName,     LastName,    Year,   TutorGroup)

                 CLASS   (ClassID,   Subject)

                 CLASS   -GROUP    (StudentID,   ClassID)


         Primary keys are not shown.

         There is a one-to-many relationship between CLASS and CLASS —GROUP.

         i       Describe how this relationship is implemented.                                                 [2]

         ii      Describe the relationship between CLASS —-GROUP and STUDENT.                                   [1]

         iii    }=Write an SQL script to display the Student
                                                           ID and FirstName of all students who are
                in the tutor group 10B. Display the list in alphabetical order of LastName.                     [4]
         iv     Write an SQL script to display the LastName of all students who attend the class whose
                ClasstID isCS1                                                                                  [4]

                                       Cambridge International
                                                            AS &A Level Computer Science 9608 paper 11 Q8 June 2016

6   Ahealth club offers classes to its members. A member needs to book into each class in advance.

    a    Thehealth club employs a programmer to update the class booking system. The programmer
         has to decide how to store the records. The choice is between using a relational database or a
         file-based approach.

         Give three reasons why the programmer should use a relational database.                                [6]

    b    The programmer decides to use three tables: wzmeer, Booxrne and crass.

         Complete the entity-relationship (E-R) diagram to show the relationships between
         these tables.



                   MEMBER                                   CLASS




                                      BOOKING




    c    Theclass table has primary key Class ID and stores the following data:

              ClassID | Description | StartDate | ClassTime | NoOfSessions | Adultsonly


               DAYO1     Yoga beginners | 12/01/2016        11:00              5              TRUE

               EVEO2   | Yoga beginners | 12/01/2016        19:00              5              FALSE



               DAY16 =| Circuits          30/06/2016        10:30              4              FALSE


         Write an SQL script to create the crass table.                                                         [6]

                                   Cambridge international
                                                        AS &A Level Computer Science 9608 paper 12 Q9 November 2016
      ges

                                                                                                                                                                                        7
                                         cis adh                                 halts haste’
                                                                                                                                          ddd              ees                    pom
     , ¢                         i                   {                       ]                    \                   ‘
     Let                         i                   i
                                                                                                                                                       '

       '\                        ;                   i
                                                                             {
                                                                             t
                                                                                                  1                   ¥                                e
                                                                                                                                                                                             4


       it                            '                   i                       i
                                                                                                  {
                                                                                                  {
                                                                                                                      ’                                                                 ;    a



    woPeeeeebe de cinus, |i                                                                                                                            :
                                                                                                                                                       :
                                                                                                                                                                            :
                                                                                                                                                                            8
                                                                                                                                                                                        sj   o
            ,
                                         ;
                                                             :
                                                                                 ‘
                                                                                                      ,
                                                                                                                      ee
                                                                                                                                                                                        a    *


            ,                            a                                                                                {                            :      |                  ~~~ oon
                                                                                                                                              e
                                                                                                                                                      wk
                                                                                                                                                           ely




                -                        ’                   ;                       f
                et                           '                                                                                                         ’
                     ;                                                                                .                   1
                                                                 '                   '                                                                 i
        Al                                   4
     OO         Gitte eo @ o%,
                                                                                     .
                                                                                                      :
                                                                                                      i
                                                                                                                                                       .      |
                                                 .
                                                                     :
                                                                                         ;
                                                                                                 a
                                                                                                                      e

                                                                                                                                                       '
                                                                                                                                                              |
                 ,                               j                   ;
                                                                                                          i                   ,                       em   amle
                                                                                         "
                                                                         -               :                .                                                       fis            bax
                                                                                                                                  |
                    "*   @   &       «
                                             "P9004.                                                      '
                                                                                                              ;
                                                                                                                                                                            {

       4                                                                                     }   TP eengt, |
                                                                                             ,                6                       ,
                                                                                                                                      "
                                                                                                                                                  ee       Ce i w of    a       el




                                                                                                                  ;                   :

                                                                                                                  .                       :




                                                                                                                                          i



                                                                                                                                              z

                                                                                                                                                  #




                                                                                                                                                                            =a
Chapter 12:
Algorithm design and problem-solving


By the end of this chapter you should be able to:

    show an understanding of abstraction                                                                                  write pseudocode that contains input, process and output
    describe the purpose of abstraction                                                                                   write pseudocode using the four basic constructs of
    produce an abstract model ofa system by only including                                                                assignment, sequence, selection and repetition

    essential details                                                                                                     document a simple algorithm using pseudocode
m   describe and use decomposition                                                                                        write pseudocode from a structured English description or
    break down problems into sub-problems leading to the                                                                  a flowchart
    concept of a program module                                                                                           describe and use the process of stepwise refinement to
    show understanding that an algorithm is a solution to a                                                               express an algorithm to a level of detail from which the task
    problem expressed as a sequence of defined steps                                                                      may be programmed

    use suitable identifier names for the representation of                                                               use logic statements to define parts of an algorithm
    data used by a problem and represent these using an                                                                   solution.
    identifier table
                                                        Part 2: Chapter 12: Algorithm design and problem-solving




12.01 What is computational thinking?
Computational thinking is a problem-solving process where a number ofsteps are taken
in order
       to reach a solution. It is a logical approach to analysing a problem, producing a
solution that can be understood by humans and used by computers.

Computational thinking involves four key strands: abstraction, decomposition, data
modelling, pattern recognition and algorithmic thinking.


Abstraction
Abstraction involves filtering out information that is not necessary to solve a problem. There
are many examples in everyday life where abstraction is used. Figure 12.02 shows part of
the underground map of London, UK. The purpose ofthis map is to help people plan their
journey within London. The map does not show a geographical representation of the tracks
of the underground train network nor does it show the streets above ground. It shows the
stations and which train lines connect the stations. In other words, the information that is
not necessary when planning how to get from one landmark to another is filtered out. The
essential information we need to be able to plan our route is clearly represented.

Abstraction gives us the power
                             to deal with complexity. An algorithm is an abstraction ofa
process that takes inputs, executes a sequence of steps, and produces outputs. An abstract
data type defines an abstract set of values and operations for manipulating those values.




  Use the aerial photograph in Figure 12.01 and draw a map just showing the essential
  details for finding a route from landmark
                                          A to landmark B.




Figure 12.01 Aerial photograph of part of a city
      Cambridge International AS & A Level Computer Science




      Decomposition
      Decomposition means breaking problems down into sub-problems in order to explain a
      process more clearly. Decomposition leads us to the concept of program modules and using
      procedures and functions.


      Data modelling
      Data modelling involves analysing and organising data (see Chapter 13). We can set up abstract
      data types to model real-world concepts, such as queues or stacks. When a programming
      language does not have such data types built-in, we can define our own by building them from
      existing data types. There are more ways to build data models. In Chapter 27 we cover object-
      oriented programming where we build data models by defining classes. In Chapter 29 we
      model data using facts and rules. In Chapter 26 we cover random files.


      Pattern recognition
      Pattern recognition means looking for patterns or common solutions to common problems
      and using these to complete tasks in a more efficient and effective way. There are many
      standard algorithms to solve standard problems, such as sorting (See Section 13.03 and
      23.03 ) or searching (see Section 13.02 and 23.04).


      Algorithm design
      Algorithm design involves developing step-by-step instructions to solve a problem.


      EEE
180
           Algorithm: a sequence of defined steps that can be carried out to perform a task




      12.02 What is an algorithm?
      We use algorithms in everyday life. Ifyou need to change a wheel on a car, you might need to
      follow instructions (the algorithm) from a manual.

           Take a spanner and loosen the wheel nuts.
      FE




           Position a jack in an appropriate place.
      WN




           Raise the car.
      PF




           Take off the wheel nuts and the wheel.

           Lift replacement wheel into position.
      OU




           Replace wheel nuts and tighten by hand.

           Lower the car.
      on




           Fully tighten wheel nuts.

      This might sound all very straightforward. However, if the instructions are not followed in the
      correct logical sequence, the process might become much more difficult or even impossible,
      For example, if you tried to do Step 1 after Step 3, the wheel may spin and you can’t loosen
      the wheel nuts. You can’t do Step 4 before Step 3.

      If you want to bake a cake, you follow a recipe.

      1    Measure the following ingredients: 200g sugar, 200g butter, 4 eggs, 200¢ flour, 2 teaspoons
           baking powder and 2 tablespoons of milk.

      2    Mix the ingredients together in a large bowl, until the consistency of the mixture is smooth.
                                                                                                  Part 2: Chapter 12: Algorithm design and problem-solving




           Pour the mixture into a cake tin.
WwW
fF




           Bake in the oven at 190° C for 20 minutes.
un




           Check it is fully cooked.

       Turn cake out ofthe tin and cool ona                                wire rack.
a




The recipe is an algorithm. The ingredients are the input and the cake is the output. The
process is mixing the ingredients and cooking the mixture in the oven.

Sometimes a step might need breaking down into smaller steps. For example, Step 2 can be
more detailed.

2.1             Beat the sugar and butter together until fluffy.

2.2             Add the eggs, one ata time, mixing constantly.

2.3             Sieve the flour and baking powder and stir slowly into the egg mixture.

2.4             Add milk and mix to give a creamy consistency.

Sometimes there might be different steps depending on some other conditions. For example,
consider how to get from one place to another using the map of the London Underground
system in Figure 12.02.

    parr                                oad                                           =                        .       .
                            Finchley R                                         King’s Cross               — Piccadilly
             desbury \                  Cottage                                  gt. Pancras                   .   .
Rise Bron             Foe      suisse                                                                     — Victoria
=                                                                                                         —— Jubilee



                                                                      Square
                                                                     ac euston 200"   TH square




                                                        Tottenham
                                                        Court Road


                                                  een     €                               House
                                                  —

                                                                                :




Figure 12.02 Underground map of London, UK


To travel from King’s Cross St. Pancras to Westminster, we consider two routes:

e          Route A: Take the Victoria Line to Green Park (4 stations); then take the Jubilee Line to
       Westminster (1 station)

e          Route B: Take the Piccadilly Line to Green Park (6 stations); then take the Jubilee Line to
       Westminster (1 station).

Route A looks like the best route. If there are engineering works on the Victoria Line and
trains are delayed, Route B might turn out to be the quicker route.

The directions on how to get from King’s Cross St. Pancras to Westminster can be written as:

iF there are engineering works on the Victoria Line

      THEN

            Take the Piccadilly Line to Green Park (6 stations)
            Take the Jubilee Line to Westminster (1 station)
      ELSE

            Take the Victoria Line to Green Park (4 stations)
            Take the Jubilee Line to Westminster (1 station)
          Cambridge International AS & A Level Computer Science




            TASK 12.02

            Write the steps to be followed to:

            e     make a sandwich
            ¢     walk from your school/college to the nearest shop

            e     log on to your computer.



          Many problems have more than one solution. Sometimes it is a personal preference which
      solution to choose. Sometimes one solution will be measurably better than another.



          12.03 Expressing algorithms


      0         TIP

                Computer scientists are interested in finding good solutions. A good solution gives the correct
                results, takes up as little computer memory as possible and executes as fast as possible. The
                solution should be concise, elegant and easy to understand.




      In computer science, when we design a solution to a problem we express the solution
      (the algorithm) using sequences of steps written in structured English or pseudocode.
      Structured English is a subset of the English language and consists of command statements.
      Pseudocode resembles a programming language without following the syntax of a particular
182
      programming language. A flowchart is an alternative method of representing an algorithm. A
      flowchart consists of specific shapes, linked together.


      Qe
            Structured English: a subset of the English language that consists of command statements used to
            describe an algorithm

            Pseudocode: a way of using keywords and identifiers to describe an algorithm without following
                                                                                                        the
            syntax of a particular programming language

            Flowchart: shapes linked together
                                           to represent the sequential steps of an algorithm




      An algorithm consists ofa sequence of steps. Under certain conditions we may wish not to
      perform some steps. We may wish to repeat a number ofsteps. In computer science, when
      writing algorithms, we use four basic types of construct.

      ¢     Assignment: a value is given a name (identifier) or the value associated with a given
            identifier is changed.

      e     Sequence: a number of steps are performed, one after the other.

      ¢     Selection: under certain conditions some steps are performed, otherwise different (or
            no) steps are performed.

      e     Repetition: a sequence of steps is performed a number of times. This is also known as
            iteration or looping.

      Many problems we try to solve with a computer involve data. The solution involves inputting
      data to the computer, processing the data and outputting results (as shown in Figure 12.03).
                                                           Part 2: Chapter 12: Algorithm design and problem-solving




    Input                        Process                         Output




                                                      Vv
                          Vv
Figure 12.03 Input-process-output


We therefore also need input and output statements.

We need to know the constructs so we know how detailed our design has to be. These
constructs are represented in each of the three notations as shown in Table 12.01.

In this book, algorithms and program code are typed using the Courier font.


                  Structured English              Pseudocode                   | Flowchart
Assignment        SET A TO 34                    A< 34
 Five yita-ay     LNCREMENT B                     BeBil

                                                                                  Set   A    to   34




                                                                                        Vv


                                                                                  Increment        B




                                                                                        !
 Selection        IF A IS GREATER THAN B          IF A >B
                      THEN      ...                   THEN       ...
                      ELSE      ...                   ELSE       ...
                                                  ENDIF                                                      NO




                                                                                                Yes


 Repetition       REPEAT UNTIL A IS               REPEAT                                                          Alternative construct:
                  EQUAL    TO   B                          wee

                                                  UNTIL A         =    B




                                                                                            °                            &
                                                                                        Y




                                                                                                        NO                                 NO




                                                                                             Yes                              Yes


                   INPUT A                        INPUT "Prompt:           "                           |
                                                  A




                                                                                        INPUT         "Prompt:"      A




                                                                                                       |!
      Cambridge International AS & A Level Computer Science




                              Structured English                 Pseudocode              Flowchart

                              OUTPUT   "Message"                 OUTPUT


                                                                                                            !
                                                                            "Message",

                              OUTPUT   B                         B




                                                                                               OUTPUT   "Message"   B




                                                                                                            !
      Table 12.01 Constructs for computing algorithms




      12.04 Variables
      When we input data for a process, individual values need to be stored in memory. We need
      to be able to refer to a specific memory location so that we can write statements of what to
      do with the value stored there. We refer to these named memory locations as variables. You
      can imagine these variables like boxes with name labels on them. When a value is input, it is
      stored in the box with the specified name (identifier) on it.


      Qa
         Variable: a storage location for a data value that has an identifier



184
      For example, the variable used to store a count of how many guesses have been made in
      a number guessing game might be given the identifier NumberOfGuesses               and the player’s
      name might be stored in a variable called ThisPlayer, as shown in Figure 12.04.




                    /
                     ec all                                          /*




       NumberOfGuesses                                     ThisPlayer




      Figure 12.04 Variables


      Variable identifiers should not contain spaces, only letters, digits and _ (the underscore
      symbol). To make algorithms easier to understand, the naming of
                                                                    a variable should reflect
      the variable’s use. This means often that more than one word is used as an identifier. The
      formatting convention used here is known as CamelCaps. It makes an identifier easier
                                                                                         to read.



      12.05 Assignments
      Assigning a value
      The following pseudocode stores the value that is input (for example 15) in a variable with the
      identifier Number (see Figure 12.05(a)).

      INPUT   Number


      The following pseudocode stores the value 1 in the variable with the identifier
      NumberOfGuesses
             (See Figure 12.05(b)).

      NumberOfGuesses          <   1
                                                             Part 2: Chapter 12: Algorithm design and problem-solving




                                                         NumberOfGuesses
        Number


           a                                                       b

Figure 12.05 Variables being assigned a value

       a value
Updating
The following pseudocode takes the value stored in NumberOfGuesses (see Figure 12.06 (a)),
adds 1 to that value and then stores the new value back into the variable NumberOfGuesses
(see Figure 12.06 (b)).

NumberOfGuesses < NumberOfGuesses + 1




                       /
                                                             /

 NumberOfGuesses
                                    =>            NumberOfGuesses

                   a                                         b

                   the value of a variable
Figure 12.06 Updating

Copying a value
Values can be copied from one variable to another.
The following pseudocode takes the value stored in Value1 and copiesit to Value2 (see Figure 12.07).
       Value2 < Valuel




               f                              f




        Valuel                       Value2


                                a




                       eS                 7
                                                  Ss     |
               7            |


        Valuel                       Value2


                                b


 Figure 12.07 Copying the value of a variable

 The value in value1 remains the same until it is assigned a different value.
Cambridge International AS & A Level Computer Science



Swapping two values
If we want to swap the contents oftwo variables, we need to store one of the values in
another variable temporarily. Otherwise the second value to be moved will be overwritten by
the first value to be moved.

In Figure 12.08(a), we copy the content from Value1 into a temporary variable called Temp.
Then we copy the content from value2 into Valuei Figure 12.08(b)). Finally, we can copy the
value from Temp into Value2 (Figure 12.08(c)).



        f
             s
                                 15
     Valuel                               Value2


                          Temp


                          a




                                                       ;
         :




                                 15
     Valuel                               Value2

                          Temp


                           b



         7
                                                   s
                                 1
      Valuel                              Value2

                          Temp


                           Cc



 Figure 12.08 Swapping the values of two variables

 Using pseudocode we write:
       Temp < Valuel

       Valuel    < Value2

       Value2    < Temp




    WORKED EXAMPLE 12.01


   Using input, output, assignment and sequence constructs
   The problem to be solved: Convert a distance in miles and output the equivalent
   distance in km.

   Step 1: Write the problem as a series of structured English statements:
      INPUT number of miles

      Calculate number of km

      OUTPUT calculated result as km

                                                                                              (Continued)
                                                            Part 2: Chapter 12: Algorithm design and problem-solving




  Step 2: Analyse the data values that are needed.

  We need a variable to store the original distance in miles and a variable to store the result
  of multiplying the number of miles by 1.61. It is helpful to construct an identifier table to
  list the variables.

      Identifier                       | Explanation
      Miles                             Distance as a whole number
                                                               of miles


      Km                                The result from using the given formula: Km = Miles * 1.61


  Table 12.02 Identifier table for miles to km conversion


  Step 3: Provide more detail by drawing a flowchart or writing pseudocode.

  The detail given in a flowchart should be the same as the detail given in pseudocode. It should use the basic
  constructs listed in Table 12.01.
  Figure 12.09 represents our algorithm using a flowchart and the equivalent pseudocode.

                                                                                  INPUT   "Enter miles:"   Miles
                    Start                                                        Km <—Miles * 1.61
                                                                                 OUTPUT     "km:",   Km

                      Vv

           INPUT   "Enter miles:"
                    Miles



                      Vv


            Km <-Miles      *   1.61




                      Y

               OUTPUT      "Km:"

                     Km




                      Vv

                     End



  Figure 12.09 Flowchart and pseudocode for miles to km conversion



f KEY TERM




  TASK 12.03

  Consider the following algorithm steps.
  1        Input a length in inches.

  2     Calculate the equivalent in centimetres.
  3     Output the result.
  List the variables required in an identifier table.
  Write pseudocode for the algorithm.
Cambridge International AS & A Level Computer Science




12.06 Logic statements
In Section 12.02, we looked at an algorithm with different steps depending on some other
condition:

IF there are engineering works on the Victoria Line

        THEN

          Take the Piccadilly Line to Green Park (6 stations)

          Take the Jubilee Line to Westminster (1 station)

        ELSE

          Take the Victoria Line to Green Park (4 stations)

          Take the Jubilee Line to Westminster (1 station)


The selection construct in Table 12.01 uses a condition to follow either the first group of steps
or the second group of steps (see Figure 12.10).



                 2 Simple condition
IFA<B
        THEN

           <statement
                  (s) >
        ELSE

           <statement
                  (s) >
ENDIF


Figure 12.10 Pseudocode for the selection construct


A condition consists of at least one logic proposition (see Chapter 4, Section 4.01). Logic
propositions use the relational (comparison) operators shown in Table 12.03.

    Operator                                         | Comparison
    =                                                 Is equal to

    <                                                 Is less than

    >                                                 Is greater than

    <=                                                Is less than or equal to

    >=                                                Is greater than or equal
                                                                             to

    <>                                                Is not equal to


Table 12.03 Relational operators


Conditions are either TRUE or FALSE. In pseudocode, we distinguish between the relational
operator = (which tests for equality) and the assignment symbol e.

A person is classed as a child if they are under 13 and as an adult if they are over 19. If they are
between 13 and 19 inclusive they are classed as teenagers. We can write these statements as
logic statements.

e        |fAge<13 then person is a child.

e        |fAge>19 then person is an adult.

e        |fAge >= 13 AND Age <= 19 then person is a teenager.
                                                                            Part 2: Chapter 12: Algorithm design and problem-solvin
                                                                                                                                   g




     TASK 12.04

     A town has a bus service where passengers under
                                                        the age of 12 and over the age of
     60 do not need to pay a fare. Write the logic statements
                                                              for free fares.



 A number-guessing game follows different steps dependi
                                                                             ng on certain conditions. Here is a
 description of the algorithm.

 ¢   The player inputs a numbeto
                              r guess the secret number stored.
*     Ifthe guess was correct, output a congratulations message
                                                                                      .
¢    ifthe number input was larger than the secret number, output
                                                                                          message “secret number is
     smaller”.

e    lf the number input was smaller than the secret number,
                                                                                  output message “secret number
     is greater”.

We can re-write the number-guessing game steps as
                                                                        an algorithm in pseudocode:

      SET    value       for       secret   number
      INPUT       Guess

      IF    Guess    =    SecretNumber

           THEN

             OUTPUT       "Well       done.   You    have       guessed   the    secret     number"
           ELSE

             IF    Guess       >   SecretNumber

                  THEN

                    OUTPUT          "Secret   number       is    smaller"
                  ELSE

                    OUTPUT          "secret   number       is    greater"
            ENDIF

     ENDIF



More complex conditions can be formed by using the
                                                                        logical operators AND, OR and NOT. For
example, the number-guessing game might allow the
                                                                        player multiple guesses; if the player
has not guessed the secret number after 10 guesses, a different
                                                                                      message is output.
     IF    Guess    =    SecretNumber

          THEN

            OUTPUT       "Well       done.    You    have   guessed       the    secret    number"
          ELSE

            IF
                                                                                                         complex condition
                 THEN

                   OUTPUT          "You    still    have   not    guessed       the   secret   number"
                 ELSE

                   IF    Guess       >    SecretNumber

                        THEN

                          OUTPUT          "Secret    number      is   smaller"
                        ELSE

                          OUTPUT          "Secret    number      is   greater"
                   ENDIF

            ENDIF

     ENDIF
Cambridge International AS & A Level Computer Science




  WORKED EXAMPLE 12.02


  Using selection constructs

  The problem to be solved: Take three numbers as input and output the largest number.

  There are several different methods (algorithms) to solve this problem. Here is one method.

  1    Input all three numbers at the beginning.

  2    Store each of the input values in a separate variable (the identifiers are shown in Table 12.04).

  3    Compare the first number with the second number and then compare the bigger one of these with
       the third number.

  4    The bigger number of this second comparison is output.
  See Worked Example 12.03 for another solution.



   Number1                                  The first number
                                                           to be input

   Number2                                  The second number
                                                            to be input

   Number3                                  The third number
                                                           to be input


  Table 12.04 Identifier table for biggest number problem


  The algorithm can be expressed in the following pseudocode:

  INPUT          Numberl

  INPUT          Number2

  INPUT          Number3

  IF    Numberl         >   Number2

       THEN

       //   Numberl         is bigger

            IF   Numberl      >   Number3

                 THEN

                   OUTPUT Numberl

                 ELSE

                   OUTPUT     Number3

            ENDIF

       ELSE

       //   Number2         is bigger

            IF   Number2      >   Number3

                 THEN

                   OUTPUT Number2

                 ELSE

                   OUTPUT Number3

            ENDIF

  ENDIF




When an rF statement contains another IF statement, we refer to these as nested IF
statements.



EEE
   Nested IF statements: conditional statements within conditional statements
                                                             Part 2: Chapter 12: Algorithm design and problem-solving




Question 12.01
What changes do you need to make to output the smallest number?


     WORKED EXAMPLE 12.03


    Using selection constructs (alternative method)

    The problem to be solved: Take three numbers as input and output the largest number.

    This is an alternative method to Worked Example 12.02.

          Input the first number and store itin BiggestSoFar
    FE




          Input the second number and compare it with the value in BiggestSoFar.
    NY




          If the second number is bigger, assign its value to Biggest SoFar
    WwW




          Input the third number and compare it with the value in BiggestSoFar
    Bb




          If the third number is bigger, assign its value to Biggest SoFar
    un




          The value stored in BiggestSoFar is output.
    a




    The identifiers required for this solution are shown in Table 12.05.

     Identifier                        | Explanation
     BiggestSoFar                       Stores the biggest number input so far
     NextNumber                         The next number
                                                      to be input


    Table 12.05 Identifier table for the alternative solution to the biggest number problem

    The algorithm can be expressed in the following pseudocode:

    INPUT        BiggestSoFar

    INPUT        NextNumber

    IF NextNumber        >    BiggestSoFar

          THEN

            BiggestSoFar < NextNumber

    ENDIF

    INPUT        NextNumber

    IF NextNumber        >    BiggestSoFar
          THEN

           BiggestSoFar < NextNumber
    ENDIF

    OUTPUT BiggestSoFar

    Note that when we input the third number in this method the second number gets
    overwritten as it is no longer needed.



There are several advantages of using the method in Worked Example 12.03 compared to the
method in Worked Example 12.02.

e    Only two variables are used.

e    Theconditional statements are not nested and do not have an ELSE part. This makes
     them easier
               to understand.

e    This algorithm can be adapted more easily if further numbers are to be compared (see
     Worked Example 12.04).

The disadvantage of the method in Worked Example 12.03 compared to the method in
Worked Example 12.02 is that there is more work involved with this algorithm. If the second
Cambridge International AS & A Level Computer Science




number is bigger than the first number, the value of BiggestSoFar has to be changed. If the
third number is bigger than the value in BiggestSoFar then the value of BiggestSoFar
has to be changed again. Depending on the input values, this could result in two extra
assignment instructions being carried out.



12.07 Loops
Look at the pseudocode algorithm in Worked Example 12.03. The two IF statements
are identical. To compare 10 numbers, we would need to write this statement nine times.
Moreover, if the problem changed to having
                                         to compare, for example, 100 numbers, our
algorithm would become very tedious. If we use a repetition construct (a loop) we can avoid
writing the same lines of pseudocode over and over again.


    WORKED EXAMPLE 12.04


    Repetition using REPEAT...UNTIL

    The problem to be solved: Take 10 numbers as input and output the largest number.

    We need one further variable to store a counter, so that we know when we have compared 10 numbers.

     Identifier                                    Explanation
    BiggestSoFar                                   Stores the biggest number input so far
    NextNumber                                     The next number
                                                                 to be input

     Counter                                       Stores how many numbers have been input so far

    Table 12.06 Identifier table for the biggest number problem using REPEAT. ..UNTIL


    The algorithm can be expressed in the following pseudocode:

    INPUT    BiggestSoFar

    Counter    <«   1

    REPEAT

         INPUT      NextNumber

         Counter        <   Counter        +   1

         IF NextNumber               >   BiggestSoFar

             THEN

               BiggestSoFar <« NextNumber

         ENDIF

    UNTIL    Counter        =   10

    OUTPUT    BiggestSoFar


    Note that when we input the next number in this method the previous number gets
    overwritten as it is no longer needed.



Question 12.02
What changes do you need to make to the algorithm in Worked Example 12.04:

a     to compare 100 numbers?

b     totakeas a first input the number of numbers to be compared?
There is another loop construct that does the counting for us: the FOR...NEXT loop.
                                                                Part 2: Chapter 12: Algorithm design and problem-solving




   WORKED EXAMPLE 12.05


  Repetition using FOR...NEXT

  The problem to be solved: Take 10 numbers as input and output the largest number.

  We can use the same identifiers as in Worked Example 12.04. Note that the purpose of counter has changed.



   BiggestSoFar                                     Stores the biggest number input so far
   NextNumber                                       The next number
                                                                  to be input

   Counter                                          Counts the number
                                                                  of times round the loop

  Table 12.07 Identifier table for biggest number problem using a FOR loop


  The algorithm can be expressed in the following pseudocode:
  INPUT    BiggestSoFar

  FOR    Counter   «   2   TO       10

         INPUT    NextNumber

         IF NextNumber          >    BiggestSoFar
           THEN

             BiggestSoFar < NextNumber

         ENDIF

  NEXT    Counter

  OUTPUT BiggestSoFar


  The first time round the loop, Counter is set to 2. The next time round the loop, Counter has automatically
  increased to 3, and so on. The last time round the loop, Counter has the value 10.


A rogue value is a value used to terminate a sequence of values. The rogue value is of the
same data type but outside the range of normal expected values.


———
EEE
   Rogue value: a value used to terminate a sequence of values




   WORKED EXAMPLE 12.06


  Repetition using a rogue value

  The problem to be solved: A sequence of non-zero numbers is terminated by 0. Take this sequence as input
  and output the largest number.

  Note: In this example the rogue value chosen is 0. It is very important to choose a rogue value that is of the
  same data type but outside the range of normal expected values. For example, if the input might normally
  include 0 then a negative value, such as -1, might be chosen.

  Look at Worked Example 12.05. Instead of counting the numbers input, we need to check whether the
  number input is 0 to terminate the loop. The identifiers are shown in Table 12.08.

                                                                                                                   (Continued)
Cambridge International AS & A Level Computer Science




  Identifier                                         | Explanation
  BiggestSoFar                                        Stores the biggest number input so far
  NextNumber                                          The next number
                                                                    to be input


 Table 12.08 Identifier table for biggest number problem using a rogue value


 A possible pseudocode algorithm is:

 INPUT     BiggestSoFar

 REPEAT

      INPUT       NextNumber

      IF   NextNumber        >       BiggestSoFar

           THEN

             BiggestSoFar < NextNumber

      ENDIF

 UNTIL     NextNumber    =       0

 OUTPUT     BiggestSoFar


 This algorithm works even if the sequence consists of only one non-zero input. However, it will not work if
 the only input is 0. In that case, we don’t want to perform the statements within the loop at all. We can use an
 alternative construct, the WHILE. . .ENDWHILE loop.

 INPUT     NextNumber

 BiggestSoFar < NextNumber

 WHILE NextNumber        <>          0   DO   //   sequence   terminator not      encountered

      INPUT       NextNumber

      IF   NextNumber        >       BiggestSoFar

           THEN

             BiggestSoFar < NextNumber

      ENDIF

 ENDWHILE

 OUTPUT     BiggestSoFar


 Before we enter the loop, we check whether we have a non-zero number. To make this work for the first
 number, we store itin NextNumber                  and also in BiggestSoFar. If this first number is zero, we don’t follow
 the instructions within the loop. For a non-zero first number this algorithm has the same effect as the
 algorithm using REPEAT. ..UNTIL.
                                                              Part 2: Chapter 12: Algorithm design and problem-solving




WORKED EXAMPLE 12.07


Implementing the number-guessing game with a loop

Consider the number-guessing game again, this time allowing repeated guesses.

1    The player repeatedly inputs a number
                                         to guess the secret number stored.
2    |fthe guess is correct, the number of guesses made is output and the game stops.
3    If the number input is larger than the secret number, the player is given the message
     to inputa smaller number.

4    \fthe number input is smaller than the secret number, the player is given the message
     to inputa larger number.

The algorithm is expressed in structured English, as a flowchart and in pseudocode.

Algorithm for the number-guessing game in structured English:

SET value         for   secret     number

REPEAT      the    following UNTIL          correct   guess

      INPUT    guess

      count    number        of   guesses

      COMPARE guess with             secret   number

      OUTPUT      comment

OUTPUT number           of    guesses


We need variables to store the following values:

e    thesecret number (to be set as a random number)
e    thenumber input by the player as a guess
e    the count of how many guesses the player has made so far.

We represent this information in the identifier table shown in Table 12.09.



    SecretNumber                               The number
                                                        to be guessed

    NumberOfGuesses                            The number of guesses the player has made

    Guess                                      The number
                                                       the player has input as a guess


Table 12.09 Identifier table for number-guessing game

                                                                                                             (Continued)
Cambridge International AS & A Level Computer Science




  Algorithm for the number-guessing game as a flowchart




      SET   SecretNumber
     to a   random number



                Vv
        INPUT      "Guess
         the secret
          number:"
             Guess




    SET NumberOfGuesses
              To       1




                   » A
                   —_




                   /


            Guess =             .       No   SET NumberOfGuesses
       SecretNumber                          TO NumberOfGuesses
                                                     +   1



                       Yes




                                               SecretNumber      ?




                                                                          Vv
                                               INPUT "Guess          INPUT "Guess
                                                 a smaller             a larger
                                                 number: "            number:"
                                                   Guess                Guess

                   f
      OUTPUT "You took"                                                   \
       NumberOfGuesses
            "Quesses"



                Vv




  Pseudocode for the number-guessing game with a post-condition loop
  SecretNumber < Random

  NumberOfGuesses              <    0

  REPEAT

       INPUT    Guess

       NumberOfGuesses < NumberOfGuesses                     +   1

       IF   Guess          >   SecretNumber


                                                                                    (Continued)
                                                                            Part 2: Chapter 12: Algorithm design and problem-solving




           THEN

             //   the player is given the message to input a smaller number

      ENDIF

      IF   Guess        <    SecretNumber

           THEN

             //   the player is given the message to input a larger number

      ENDIF

UNTIL      Guess    =       SecretNumber

OUTPUT NumberOfGuesses

Pseudocode for the number-guessing game with a pre-condition loop
SecretNumber < Random

INPUT      Guess

NumberOfGuesses                  <    1

WHILE      Guess    <>       SecretNumber                DO

      IF    Guess       >    SecretNumber

           THEN

             //    the player                  is given the message to          input a smaller number

      ENDIF

      IF    Guess       <    SecretNumber

           THEN

             //    the player is given the message to input a larger number

      ENDIF

      INPUT       Guess

      NumberOfGuesses                     < NumberOfGuesses         +   1

ENDWHILE

OUTPUT NumberOfGuesses




WORKED EXAMPLE 12.08


Calculating running totals and averages

The problem to be solved: Take 10 numbers as input and output the sum of these numbers and the average.



 RunningTotal                                                  Stores the sum of the numbers input so far

 Counter                                                       How many numbers have been input
 Next Number                                                   The next number input

 Average                                                       The average of the numbers input

Table 12.10 Identifier table for running total and average algorithm


The following pseudocode gives a possible algorithm:

RunningTotal             <       0

FOR    Counter      <«       1       TO   10

       INPUT      NextNumber

       RunningTotal < RunningTotal                            + NextNumber

NEXT    Counter

OUTPUT RunningTotal

Average < RunningTotal                          /   10

OUTPUT      Average

                                                                                                                           (Continued)
Cambridge International AS & A Level Computer Science




  It is very important that the value stored in RunningTotal is initialised to zero before we start adding the
  numbers being input.




0   TIP

    Which type of loop? If it is known how many repetitions are required, choose a FOR loop. If the
    statements inside the loop might never be executed, choose a WHILE loop. If the statements
    inside the loop are to be executed at least once, a REPEAT loop might be more sensible.




  TASK 12.05

  Change the algorithm in Worked Example 12.08 so that the sequence of numbers is
  terminated by a rogue value of 0.




    WORKED EXAMPLE 12.09


  Using nested loops

 The problem to be solved: Take as input two numbers and a symbol. Output a grid made up entirely of
 the chosen symbol, with the number of rows matching the first number input and the number of columns
  matching
        the second number input.
  For example the three input values 3, 7 and &, result in the output:

                                                            &&&&&&E


                                                            &&&&E&E


                                                            &&&&E&E


 We need two variables to store the number of rows and the number of columns. We also need a variable to
 store the symbol. We need a counter for the rows and a counter
                                                            for the columns.



    NumberOfRows                                                  Stores the number of rows of the grid

    NumberOfColumns                                               Stores the number of columns ofthe grid

    Symbol                                                        Stores the chosen character symbol
    RowCounter                                                    Counts the number of rows

    ColumnCounter                                                 Counts the number of columns


 Table 12.11 Identifier table for the nested loop example


 INPUT      NumberOfRows

 INPUT      NumberOfColumns

 INPUT      Symbol

 FOR      RowCounter      <   1   TO    NumberOfRows

          FOR    ColumnCounter          <«   1    TO   NumberOfColumns

                 OUTPUT   Symbol        //       without moving          to next   line

          NEXT    ColumnCounter

          OUTPUT Newline               //    move      to   the   next   line

 NEXT      RowCounter


  Each time round the outer loop (counting the number of rows) we complete the inner loop, outputting a
 symbol for each count of the number of columns. This type of construct is called a nested loop.
                                                                 Part 2: Chapter 12: Algorithm design and problem-solving




   KEY TERM


                    oop containing another loop




12.08 Stepwise refinement
Many problems that we want to solve are bigger than the ones we met so far. To make it
easierto solve a bigger problem, we break the problem down into smaller steps. These might
need breaking down further until the steps are small enough to solve easily.

For a solution to a problem to be programmable, we need to break down the steps of the solution
into the basic constructs of sequence, assignment, selection, repetition, input and output.

We can use a method called stepwise refinement to break down the steps of our outline
solution into smaller steps until itis detailed enough. In Section 12.02 we looked at a recipe fora
cake. The step of mixing together   all the ingredients was broken down into more detailed steps.

   KEY TERM


             ise refinement: breaking down   the: teps of an ot itline solution into smaller and   smaller s teps




   WORKED EXAMPLE 12.10


   Drawing a pyramid using stepwise refinement

  The problem to be solved: Take as input a chosen symbol and an odd number. Output a
  pyramid shape made up entirely of the chosen symbol, with the number of symbols in
  the final row matching
                      the number input.

   For example the two input values A and 9 result in the following output:
         A

        AAA

        AAAAA

    AAAAAAA

  AAAAAAAAA


   This problem is similarto Worked Example 12.09, but the number of symbols in each row starts with one and
   increases by two with each row. Each row starts with a decreasing number ofspaces, to create the slope effect.
   Our first attempt at solving this problem using structured English is:
   01        Set up   initial values

   02        REPEAT

   03             Output number of       spaces

   04             Output number of       symbols

   05             Adjust number of spaces and number of symbols to be output in next row
   06        UNTIL the required number of symbols have been output in one row

   The steps are numbered to make it easier to refer to them later.

   This is not enough detail to write a program in a high-level programming language. Exactly what
   values do we need to set?

                                                                                                                    (Continued)
Cambridge International AS & A Level Computer Science




 We need as input:

 e     thesymbol character from which the pyramid is to be formed

 e     thenumber of symbols in the final row (for the pyramid to look symmetrical, this needs to be an
       odd number).

 We need to calculate how many spaces we need in the first row. So that the slope of the pyramid is
 symmetrical, this number should be half
                                      of the final row’s symbols. We need to set the number of
 symbols to be output in the first row to 1. We therefore need the identifiers listed in Table 12.12.




     Symbol                                                The character symbol to form the pyramid
     MaxNumberOfSymbols                                    The number of symbols in the final row

     NumberOfSpaces                                        The number of spaces to be output in the current row

     NumberOfSymbols                                       The number of symbols to be output in the current row


 Table 12.12 Identifier table for pyramid example


  Using pseudocode, we now refine the steps of our first attempt. To show which step we are refining, a
  numbering system is used as shown.

 Step 01 can be broken down as follows:

  01       //    Set up         initial          values   expands              into:

  01.1    INPUT        Symbol

  01.2    INPUT        MaxNumberOfSymbols

  01.3    NumberOfSpaces <                      (MaxNumberOfSymbols                            -    1)   /   2

  01.4    NumberOfSymbols                   <    1


  Remember we need an odd number for MaxNumberOfSymbols. We need to make sure the input is an
 odd number. So we further refine Step 01.2:

  01.2          //   INPUT MaxNumberOfSymbols                         expands                      into:

  01.2.1    REPEAT

  01.2.2             INPUT          MaxNumberOfSymbols

  01.2.3    UNTIL          MaxNumberOfSymbols                   MOD    2       =       1

  01.2.4    //       MOD    2       gives   the       remainder       after                integer division by 2


 We can now look to refine Steps 03 and 04:

  03 //    Output          number of             spaces   expands              into:

  03.1      FOR       i<«       1   TO   NumberOfSpaces

  03.2                OUTPUT          Space      //   without moving                       to next           line

  03.3      NEXT       i



  04        //       Output         number of         symbols     expands                      into:

  04.1      FOR       i<¢       1   TO   NumberOfSymbols

  04.2                OUTPUT Symbol                  // without moving                         to next           line

  04.3      NEXT       i

  04.4      OUTPUT Newline                  //    move    to    the next                   line


  In Step 05 we need to decrease the number of spaces by 1 and increase the number of symbols by 2:

  05       // Adjust values                 for next           row expands                     into:

  05.1    NumberOfSpaces                 < NumberOfSpaces                  -       1

  05.2    NumberOfSymbols                   < NumberOfSymbols                      +       2


                                                                                                                        (Continued)
                                                                                                   Part 2: Chapter 12: Algorithm design and problem-solving




Step 06 essentially checks whether
                                the number of symbols for the next row is now greater than the value
input at the beginning.

06           UNTIL             NumberOfSymbols                         >   MaxNumberOfSymbols


We can put together all the steps and end up with a solution.

O1            //     Set Values

01.1         INPUT             Symbol

01.2         //      Input max number of                               symbols            (an odd number)

01.2.1        REPEAT

01.2.2                INPUT MaxNumberOfSymbols

01.2.3        UNTIL            MaxNumberOfSymbols                            MOD      2   =    1

01.3          NumberOfSpaces                       <«       (MaxNumberOfSymbols                         -    1)    /   2

01.4          NumberOfSymbols                           <    1

02            REPEAT

03                        //   Output number of                            spaces

03.1                  FOR       i        <   1   TO     NumberOfSpaces

03.2                            OUTPUT            Space           //       without        moving            to    next     line

03.3                  NEXT           i

04                        //   Output            number of                 symbols

04.1                  FOR        i       <   1   TO NumberOfSymbols

04.2                            OUTPUT             Symbol          //       without           moving         to next         line

04.3                  NEXT           i

04.4                  OUTPUT Newline                         //    move          to   the     next          line

05                        //   Adjust Values                      For Next            Row

05.1                  NumberOfSpaces                         < NumberOfSpaces                       -   1

05.2                  NumberOfSymbols                            <« NumberOfSymbols                     +    2

06           UNTIL             NumberOfSymbols                         >   MaxNumberOfSymbols




TASK 12.06

Use stepwise refinement to output a hollow triangle. For example the two input
values A and 9 result in the following output:
         A

         AA

     A       A

 A               A

AAAAAAAAA


A first attempt at solving this problem using structured English is:
01        Set        up    initial               values

02        REPEAT

03                   Output          leading number                        of    spaces

04                   Output          symbol,             middle            spaces,         symbol

05                   Adjust          number             of       spaces         and number              of       symbols     to be   output     in

                     next       row

06        UNTIL           the    required number                            of    symbols           have         been      output   in   one   row
      Cambridge International AS & A Level Computer Science




      12.09 Modules
      Another method of developing a solution is to decompose the problem into sub-tasks. Each
      sub-task can be considered as a ‘module’ that is refined separately. Modules are procedures
      and functions.

      A procedure groups together a number of steps and gives them a name (an identifier). We
                                                  to this group of steps. When we want to perform
      can use this identifier when we want to refer
      the steps in a procedure we call the procedure by its name.


      —
         Procedure: a sequence of steps that is given an identifier and can be called to perform a sub-task




      CALL ProcedureXYZ                         CALL ProcedureXYZ




                 a                                          b

      Figure 12.11 Representation of a procedure in (a) pseudocode and (b) a flowchart

      A function groups together a number of steps and gives them a name (an identifier). These steps
202   produce and return a value that is used in an expression. Worked Example 12.12 uses functions.



          Function: a sequence of steps that is given an identifier and returns a single value; function call is part
          of an expression



       Note: Because a function returns a value, the function definition states the data type of this
      value. See more about data types in Chapter 13.

      The rules for module identifiers are the same as for variable identifiers (see Section 12.04)

          WORKED EXAMPLE 12.11


         Drawing a pyramid using modules

         The problem is the same as in Worked Example 12.10.

         When we want to set up the initial values, we call a procedure, using the following statement:
                                                            CALL    SetValues


         We can rewrite the top-level solution to our pyramid problem using a procedure for each step, as:
         CALL    SetValues

         REPEAT

                CALL   OutputSpaces

                CALL OutputSymbols

                CALL AdjustValuesForNextRow

         UNTIL NumberOfSymbols > MaxNumberOfSymbols

                                                                                                                        (Continued)
                                                                               Part 2: Chapter 12: Algorithm design and problem-solving




This top-level solution calls four procedures. This means each procedure has to be defined. The
procedure definitions are:

PROCEDURE       SetValues

       INPUT    Symbol

       CALL    InputMaxNumberOfSymbols                        //   need            to   ensure     it   is   an   odd   number

       NumberOfSpaces <               (MaxNumberOfSymbols                      -   1)   /   2

       NumberOfSymbols            <    1

ENDPROCEDURE


PROCEDURE       InputMaxNumberOfSymbols

       REPEAT

              INPUT    MaxNumberOfSymbols

       UNTIL    MaxNumberOfSymbols                  MOD   2    =   1

ENDPROCEDURE


PROCEDURE       OutputSpaces

       FOR    Countl    <«   1   TO    NumberOfSpaces

              OUTPUT    Space         //    without moving             to next           line

       NEXT    Countl

ENDPROCEDURE


PROCEDURE       OutputSymbols

       FOR    Count2    <«   1   TO    NumberOfSymbols

              OUTPUT    Symbol         //    without      moving           to next          line

       NEXT    Count2

       OUTPUT Newline            //   move     to   the   next         line

ENDPROCEDURE


PROCEDURE AdjustValuesForNextRow

       NumberOfSpaces            <« NumberOfSpaces             -   1

       NumberOfSymbols            < NumberOfSymbols                    +   2

ENDPROCEDURE




TASK 12.07

Amend your algorithm for Task 12.05 to use modules.




WORKED EXAMPLE 12.12


Drawing a pyramid using modules

The problem is the same as in Worked Example 12.11.

We can rewrite the top-level solution to our pyramid problem using procedures and functions.

O01    CALL     SetValues

02     REPEAT

03             CALL    OutputSpaces

04             CALL    OutputSymbols

05.1          NumberOfSpaces                < AdjustedNumberOfSpaces

05.2          NumberOfSymbols                < AdjustedNumbeOfSymbols

06     UNTIL     NumberOfSymbols               >    MaxNumberOfSymbols


                                                                                                                                 (Continued)
Cambridge International AS & A Level Computer Science




  This top-level solution calls three procedures. It also makes use oftwo functions in
  lines 05.1 and 05.2.

  The procedures and functions have to be defined.

  PROCEDURE     SetValues

       INPUT    Symbol

       MaxNumberOfSymbols                   < ValidatedMaxNumberOfSymbols

       NumberOfSpaces <                (MaxNumberOfSymbols                    -   1)   /    2

       NumberOfSymbols             <    1

  ENDPROCEDURE


  FUNCTION ValidatedMaxNumberOfSymbols                            RETURNS              INTEGER

       REPEAT

              INPUT    MaxNumberOfSymbols

       UNTIL    MaxNumberOfSymbols                  MOD   2   =   1

       RETURN    MaxNumberOfSymbols

  ENDFUNCTION


  PROCEDURE     OutputSpaces

       FOR    Countl     <    1   TO    NumberOfSpaces

              OUTPUT     Space         //   without   moving          to next           line

       NEXT    Countl

  ENDPROCEDURE


  PROCEDURE     OutputSymbols

       FOR    Count2     <«   1   TO    NumberOftSymbols

             OUTPUT    Symbol          //   without moving             to next             line

       NEXT    Count2

       OUTPUT Newline             //   move    to   the   next         line

  ENDPROCEDURE


  FUNCTION AdjustedNumberOfSpaces                     RETURNS             INTEGER

       NumberOfSpaces             < NumberOfSpaces            -    1

       RETURN    NumberOfSpaces

  ENDFUNCTION


  FUNCTION AdjustedNumberOfSymbols                        RETURNS             INTEGER

       NumberOfSymbols             < NumberOfSymbols                  +   2

       RETURN    NumberOfSymbols

  ENDFUNCTION


  Note that procedure SetValues uses afunction ValidatedMaxNumberOfSymbols.



One benefit of using modules is that individual modules can be reused in other solutions.
Therefore, modules should be designed to be self-contained. That means they should not
rely on external variables. All variables that are required by a module should be passed to it
using parameters. To illustrate this, look at Worked Example 12.13
                                                                      Part 2: Chapter 12: Algorithm design and problem-solving




WORKED EXAMPLE 12.13


Drawing a pyramid using modules and parameters

The problem is the same as in Worked Example 12.12.

01     CALL     SetValues(Symbol,           MaxNumberOfSymbols,                         NumberOfSpaces,      NumberOfSymbols)

02     REPEAT

03            CALL     OutputSpaces(NumberOfSpaces)

04            CALL     OutputSymbols(NumberOfSymbols,                              Symbol)

05.1          NumberOfSpaces < AdjustedNumberOfSpaces(NumberOfSpaces)

05.2          NumberOfSymbols < AdjustedNumbeOfSymbols(NumberOfSymbols)

06     UNTIL NumberOfSymbols                >   MaxNumberOfSymbols


Module definitions:

PROCEDURE       SetValues(Symbol,           MaxNumberOfSymbols,                         NumberOfSpaces,      NumberOfSymbols)

       INPUT    Symbol

       MaxNumberOfSymbols < ValidatedMaxNumberOfSymbols

       NumberOfSpaces <               (MaxNumberOfSymbols                 -   1)    /   2

       NumberOfSymbols            <    1

ENDPROCEDURE


FUNCTION ValidatedMaxNumberOfSymbols                          RETURNS              INTEGER

       REPEAT

              INPUT    MaxNumberOfSymbols

       UNTIL    MaxNumberOfSymbols              MOD   2   =   1

       RETURN    MaxNumberOftSymbols

ENDFUNCTION


PROCEDURE       OutputSpaces(NumberOfSpaces)

       FOR    Countl    <«   1   TO   NumberOfSpaces

              OUTPUT Space            // without moving to next                      line

       NEXT    Countl

ENDPROCEDURE


PROCEDURE       OutputSymbols(NumberOfSymbols,                        Symbol)

       FOR    Count2    <«   1   TO   NumberOfSymbols

              OUTPUT Symbol            // without moving to next                        line

       NEXT    Count2

       OUTPUT Newline            // move   to the next            line

ENDPROCEDURE


FUNCTION AdjustedNumberOfSpaces(NumberOfSpaces)                                         RETURNS    INTEGER

       NumberOfSpaces            < NumberOfSpaces         -       1

       RETURN    NumberOfSpaces

ENDFUNCTION


FUNCTION AdjustedNumbeOfSymbols(NumberOfSymbols)                                         RETURNS    INTEGER

       NumberOfSymbols            < NumberOfSymbols               +   2

       RETURN    NumberOfSymbols

ENDFUNCTION
Cambridge International AS & A Level Computer Science



Note that the procedure OutputSpaces uses a variable, Count1, which is used only within
the module. Similarly, outputSymbols uses variable count2 only within the module. We call
such a variable a local variable (see Chapter 14, Section 14.09). A variable available to all
modules is known as a global variable (see Chapter 14, Section 14.09).


0   TIP

    Good design uses local variables as it makes modules independent and re-usable.



EE
—
    Local variable: a variable that is accessible only within the module in which it is declared
    Global variable: a variable that is accessible from all modules


Reflection Point:
Can you think of other problems and use decomposition to break them down into basic
constructs, input and output statements?




    Summary




 Exam-style Questions
 1 The Modulo-11 method of calculating a check digit for a sequence of nine digits is as follows:
   Each digit in the sequence is given a weight depending on its position in the sequence. The leftmost
   digit has a weight of 10. The next digit to the right has a weight of 9, the next one8 and so on. Values are
   calculated by multiplying each digit by its weight. These values are added together and the sum is divided
   by 11. The remainder from this division is subtracted from 11 and this value is the check digit. If this value is
   10, then the check digit is X. Note that x Mop y gives the remainder       from the division of x by y.
     The flowchart shows the algorithm for calculating the Modulo-11 check digit.
     Write pseudocode from the flowchart .
                                                                    Part 2: Chapter 12: Algorithm design and problem-solving




                      v
        Weighting <                         10


                      v
             Total          <           0


                      v
             Count          <—          1
                           RB




             INPUT         Digit



                      v
Value   <«    Digit             *       Weighting

                      y                                     Count   <   Count   +   1

                                                                        A
  Total      <   Total                  +    Value


                      ¥
Weighting <            Weighting                   -    1




Remainder <«           Total                 MOD   11


                      v
CheckDigit       <«    11           -       Remainder




        CheckDigit                      =10
                       ?




        CheckDigit                      <     X




                       f


 C                    End                          »                                                           o
      Cambridge International AS & A Level Computer Science




      2   Write pseudocode for the following problem given in structured English.
          REPEAT       the    following               UNTIL       the   number        input     is    zero

          INPUT    a    number


          Check    whether          number                is   positive    or    negative

          Increment          positive             number        count     if    the   number         is       positive

          Increment          negative             number        count     if    the   number         is       negative   [7]

      3   Write pseudocode from the given flowchart. Use a WHILE loop.




                                     Vv


                       RogueValue                 <   -1




                              Count          <«   0




                                         f
208

                       / Input manor /



                Number         <>    RogueValue




                   Count       <    Count             +    1            Average        <   Total          /   Count




                                     /                                                     Vv

               Total < Total + Number                                      [oven nverage /

                                    Vv


                         INPUT       Number
                                                                                              A




                                                                               (ma)                                      «
Data types and structures

Learning objectives
By the end of this chapter you should be able to:

   select and use appropriate data types for a problem              show understanding of why files are needed
   solution (INTEGER, REAL, CHAR, STRING, BOOLEAN, DATE,            write pseudocode to handle text files that consist of one or
   ARRAY, FILE)                                                     more lines
   show understanding of the purpose of a record structure          show understanding that an Abstract Data Type (ADT) is a
   to hold a set of data of different data types under one          collection of data and a set of operations on those data
   identifier                                                       show understanding that a stack, queue and linked list are
   write pseudocode to define a record structure                    examples of ADTs
   write pseudocode to read data from a record structure and        describe the key features of a stack, queue and linked list
   save data to a record structure                                  and justify their use for a given situation
   use the technical terms associated with arrays including         use a stack, queue and linked list to store, add, edit and
   index, upper and lower bound                                     delete data
   select a suitable data structure (1D or 2D array) to use for a   describe how a queue, stack and linked list can be
   given task                                                       implemented using arrays.
   write pseudocode to process array data including sorting
   using a bubble sort and searching using a linear search.
Cambridge International AS & A Level Computer Science




13.01 Data types
Primitive data types
In Chapter 12 we used variables to store values required by our algorithm. Look at Worked
Example 12.01. The Identifier Table 12.02 lists two variable identifiers: Miles and Km. An
identifier table should also show what sort of data (or data type) is going to be stored in each
variable. The explanation shows that Miles will be a whole number, but that Km will be calculated
using the formula Miles * 1.61. This will result in a number that may not be a whole number.

Primitive data types are those variables that can be defined simply by commands built into
the programming language. Primitive data types are also known as atomic data types. In
Computer Science a whole number is referred to as an INTEGER and a number with a decimal
point is referred to as a REAL. Conditions are either TRUE or FALSE. These are logical values
known as BOOLEAN. Sometimes we may want to store a single character; this is referred to
as a CHAR.

A value that will always be a whole number should be defined to be of type INTEGER, such as
when counting
           the iterations of a loop.



0   TIP

    See Table 13.01 for a list of data types you should be familiar with.
    See Chapter 1 (Sections 1.02 and 1.03) on how integers and characters are represented inside the
    computer. Chapter 16 (Section 16.03) covers the internal representation of real (single, double,
    float) numbers.




Further data types
lf we want to store several characters; this is known as a String.

Note that there is a difference between the number 12 and the string “12”,

The string data type is known as a structured type because it is essentially a sequence
of characters. A special case is the empty string: a value of data type string, but with no
characters stored in it.

When we write a date, such as 3 February 2018, we can also write this as a set of three
numbers: 3/2/2018. Sometimes we might wish to calculate with dates, such as taking one
date away from another to find out how many days, months and years are between these
dates. To make it easier
                       to do this, DATE has been designed as a data type. To see how
different programming languages implement this data type, see Chapter 14 Section 14.03.


 INTEGER                              A signed whole number

 REAL                                 A signed number with a decimal point

 CHAR                                 A single character

 STRING                               A sequence of zero or more characters

 BOOLEAN                               The logical values TRUE and FALSE

  DATE                                 A date consisting of day, month and year, sometimes including a time
                                       in hours, minutes and seconds


Table 13.01 Summary of pseudocode data types
                                                                                 Part 2: Chapter 13: Data types and structures




  TASK 13.01

  Look at the identifier tables in Chapter 12 (Tables 12.06 and 12.09 to 12.12). Give the
  data type that is appropriate for each variable listed.




13.02 The record type
Sometimes variables of different data types are a logical group, such as data about a person
(name, date of birth, height, number ofsiblings, whether they are a full-time student).

Name is a STRING; date of birth is a DATE; height is a REAL; number of siblings is an INTEGER;
whether they are a full-time student is a BOOLEAN.

We can declare a record type to suit our purposes. The record type is known as a user-defined
type, because the programmer can decide which variables (fields) to include as a record.



    TIP

    Arecord type is also known as a composite type.



In pseudocode a record type is declared as:

TYPE    <Typeldentifier>

       DECLARE          <field      identifier>              :   <data   type>




ENDTYPE



We can now declare a variable ofthis record type:

DECLARE       <variable            identifier>           :       <record type>


And then access an individual field using the dot notation:

<variable          identifier>.<field identifier>


Using the example above we can declare a Person record type:

TYPE    PersonType

       Name    :    STRING

       DateOfBirth             :   DATE

       Height       :   REAL

       NumberOfSiblings                :       INTEGER

       IsFullTimeStudent                   :   BOOLEAN

ENDTYPE


To declare a variable of this type we write:
DECLARE       Person       :       PersonType

And now we can assign a value to a field of this Person record:

Person.Name <             "Fred"

Person.NumberOfSiblings < 3

Person.IsFullTimeStudent < TRUE

To output a field ofa record:

OUTPUT    Person.Name
   Cambridge International AS & A Level Computer Science




        TASK 13.02

        Write the declaration of a record type to store the details of a book: Title, Year of
        publication, Price, ISBN.
        Write the statements required to assign the values “Computer Science”, 2019, £44.95,
        "9781108733755" to the fields respectively.




   13.03 Arrays
   Sometimes we want to organise data values into a list or a table / matrix. In most
   programming languages these structures are known as arrays. An array is an ordered set of
   data items, usually of the same type, grouped together using a single identifier. Individual
   array elements are addressed using an array index for each array dimension.

   A list is a one-dimensional (1D) array and a table or matrix is a two-dimensional (2D) array.



  Oo     TIP

         When writing pseudocode, arrays need to be declared before they are used. This means choosing
         an identifier, the data type of the values to be stored in the array and upper bound and lower
         bound for each dimension.




212 t   Array index: row or column number of an individual array element

         Upper bound: the highest number index of an array dimension
         Lower bound: the smallest number index of an array dimension




   13.04 One-dimensional arrays
   When we write a list on a piece of paper and number
                                                    the individual items, we would normally
   start the numbering with 1. You can view a 1D array like a numbered list of items. Many
   programming languages number array elements from 0 (the lower bound), including VB.NET,
   Python and Java. Depending on the problem to be solved, it might make sense to ignore
   element 0. The upper bound is the largest number used for numbering the elements of an array.

   In pseudocode, a 1D array declaration is written as:

   DECLARE      <arrayldentifier>          :    ARRAY[<lowerBound>:<upperBound>]            OF    <dataType>

   Here is a pseudocode example:

   DECLARE List1         :   ARRAY[1:3]        OF STRING    //    3   elements   in this   list

   DECLARE List2         :   ARRAY[0:5]        OF INTEGER //      6   elements   in this   list

   DECLARE List3         :   ARRAY[1:100]       OF INTEGER //         100   elements   in this    list

   DECLARE List4         :   ARRAY[0:25]       OF CHAR     //    26   elements   in this   list



   Accessing 1D arrays
   A specific element in an array is accessed using an index value. In pseudocode, this is written as:
   <arrayldentifier>[x]


   The nth element within the array MyList is referred to as MyList [n]
                                                                                  Part 2: Chapter 13: Data types and structures




Here is a pseudocode example:

NList[25]    <«    0       //      set   25th element    to    zero
AList[3]    <     'D'      //      set   3rd element    to    letter D



  WORKED EXAMPLE 13.01


  Working with a one-dimensional array

  The problem to be solved: Take seven numbers as input and store them for later use.

  We could use seven separate variables. However, if we wanted our algorithm to work with 70 numbers, for
  example, then setting up 70 variables would be complicated and waste time. Instead, we can make use of
                                                                                                       a
  data structure known as a ‘linear list’ or a 1D array.

  This array is given an identifier, for example MyList, and each element within the array is referred to using
  this identifier and its position (index) within the array. For example, MyList [4] refers to the element at
  position 4 in the MyList array. If we are counting the element at position 0 as the first element, MyList [4]
  refers to the fifth element.

  We can use a loop to access each array element in turn. If the numbers input to the pseudocode algorithm
  below are 25, 34, 98, 7,41, 19 and 5 then the algorithm will produce the result in Figure 13.01.

  FOR    Index <           0    TO   6

         INPUT MyList [Index]

  NEXT     Index


  Index     MYList

     [0]                   25
     [1]                   34
     [2]                   98

     [3]                       i
     [4]                   41
     [5]                   19
     [6]                       3

  Figure 13.01 Mylist array populated by a loop




  TASK 13.03

  Define two arrays, one for your friends’ names and one for their ages as shown in
  Figure 13.02.
                  Name                                                      Age


   [0]            Matt                                                [0]   15


   [1]            Fred                                                [1]   16

   [2]            Anna                                                [2]   14




                       {                                                    ‘




  [19]          Xenios                                            [19]      17


  Figure 13.02 Arrays for names and ages
      Cambridge International AS & A Level Computer Science




        WORKED EXAMPLE 13.02


       Searching a 1D array

       The problem to be solved: Take a number as input. Search for this number in an existing 1D array of seven
       numbers (see Worked Example 13.01).

       Start at the first element of the array and check each element in turn until the search value is found or the
       end ofthe array is reached. This method is called a linear search.


         Identifier                    Data type                               Explanation

        MyList                        ARRAY [0:6]            OF    INTEGER |   Data structure (1D array) to store seven numbers


        MaxIndex                       INTEGER                                 The number of elements in the array

         SearchValue                   INTEGER                                 The value to be searched for


        Found                         BOOLEAN                                  TRUEif the value has been found
                                                                               FALSEif the value has not been found

         Index                         INTEGER                                 Index of the array element currently being processed



       Table 13.02 Identifier table for linear search algorithm


       MaxIndex <            6

       INPUT       SearchValue

       Found       <«   FALSE
214
       Index       <    -l

       REPEAT

              Index <            Index      +    1

              IF MyList[Index]                   =   SearchValue

                   THEN

                        Found <«      TRUE

              ENDIF

       UNTIL       FOUND         =   TRUE       OR   Index    >=   MaxIndex

       IF    Found       =   TRUE

            THEN

              OUTPUT         "Value      found         at   location:    "   Index

            ELSE

              OUTPUT         "Value      not         found"

       ENDIF




       The complex condition to the REPEAT. ..UNTIL loop allows us to exit the loop when the search value is
       found. Using the variable Found makes the algorithm easier
                                                                to understand. Found is initialised (first set) to
       FALSE before entering the loop and set to TRUE if the value is found.

       If the value is not in the array, the loop terminates when Index is greater than or equal to MaxIndex. That
       means we have come to the end of the array. Note that using MaxIndex in the logic statement to terminate
       the loop makes it much easier to adapt the algorithm when the array consists of a different number of
       elements. The algorithm only needs to be changed in the first line, where MaxIndex is given a value.
                                                                            Part 2: Chapter 13: Data types and structures




EEE
Linear search: checking each element of an array in turn for a required value




TASK 13.04

Use the algorithm in Worked Example 13.02 as a design pattern. Write an algorithm
using the arrays from Task 13.03 to search for a friend’s name and output their age.




WORKED EXAMPLE 13.03


Sorting elements in a 1D array

The simplest way to sort an unordered list of values is the following method.

1   Compare the first and second values. If the first value is larger than the second value,
    swap them.

2   Compare the second and third values. If the second value is larger than the third
    value, swap them.

3   Compare the third and fourth values. If the third value is larger than the fourth value,
    swap them.

4   Keep on comparing adjacent values, swapping them if necessary, until the last two
    values in the list have been processed.

Figure 13.03 shows what happens to the values as we work down the array, following this
algorithm.

Compare           Compare           Compare          Compare   Compare          Compare   Sorted
                  2TM Pair          3" Pair          4" Pair   5" Pair          6" Pair    list
             no     25                25               25         25              25       25

          swaP = no                   34               34         34              34       34
    98                       swap             Swap      7         7                7        7



    Al              4l                4l                                          19       19

    19              19                19

    5                5                 5



Figure 13.03 Swapping values working down the array

When we have completed the first pass through the entire array, the largest value is in
the correct position at the end ofthe array. The other values may or may not be in the
correct order.

We need to work through the array again and again. After each pass through the array
the next largest value will be in its correct position, as shown in Figure 13.04.


                                                                                                               (Continued)
Cambridge International AS & A Level Computer Science




   Original                           After                 After              After           After          After           After
        list                      pass 1                pass 2             pass 3              pass 4         pass 5          pass 6

        25                                25


        34                                34


        98                                7


         7                                Al


        Al                                19


        19                                5



         mm
  Figure 13.04 States of the array after each pass

  In effect we perform a loop within a loop, a nested loop. This method is known as a
  bubble sort. The name comes from the fact that smaller values slowly rise to the top,
  like bubbles in a liquid.

 The identifiers needed for the algorithm are listed in Table 13.03.

   Identifier                         Data type                                      Explanation

   MyList                             ARRAY[0:6]            OF INTEGER | Data structure (1D array) to store seven numbers

   MaxIndex                           INTEGER                                        The upper bound of the array

   n                                  INTEGER                                        The number of pairs of elements to compare in each
                                                                                     pass


   i                                  INTEGER                                        Counter for outer loop

   5                                  INTEGER                                        Counter for inner loop


   Temp                               INTEGER                                        Variable for temporary storage while swapping values


 Table 13.03 Identifier table for bubble sort algorithm


  The algorithm in pseudocode is:

  n < MaxIndex                        -    1

  FOR    i       <   0       TO       MaxIndex          -    1

         FOR         7       <    0       TOn

                     IF MyList[j]                  >    MyList         +       1]

                             THEN

                                  Temp < MyList[j]

                                  MyList[j]            < MyListl[j         +    1]

                                  MyList[j         +    1]       < Temp

                     ENDIF

         NEXT            j

         n<«en-d1//                            this means           the next time            round the     inner      loop,   we don't

                                          //   look at       the values              already in the        correct positions.

  NEXT       i


                                                                                                                                            (Continued)
                                                                                        Part 2: Chapter 13: Data types and structures




The values to be sorted may already be in the correct order before the outer loop has been through all its
iterations. Look at the list of values in Figure 13.05. It is only slightly different from the first list we sorted.

  Original               After               After           After        After        After           After
     list                pass 1              pass 2          pass 3      pass 4        pass 5          pass 6

      5                      5                 5                  5         5             5              5

     34                      34                7                  7         7             7

     98                      7                 34                 19

      7                      41                19


     41                      19                25


     19                      25



     =|
Figure 13.05 States of the list after each pass

After the third pass the values are all in the correct order but our algorithm will carry on
with three further passes through the array. This means we are making comparisons
when no further comparisons need to be made.

If we have gone through the whole of the inner loop (one pass) without swapping any
values, we know that the array elements must be in the correct order. We can therefore
replace the outer loop with a conditional loop.

We can use a variable NoMoreSwaps to store whether or not a swap has taken place during the current
pass. We initialise the variable NoMoreSwaps to TRUE. When we swap a pair of values we set NoMoreSwaps
to FALSE. At the end of the pass through the array we can check whether a swap has taken place.

The identifier table for this improved algorithm is shown in Table 13.04.

 Identifier                        | Data type                         | Explanation
 MyList                                ARRAY[0:6]     OF INTEGER | Data structure (1D array) to store seven numbers

 MaxIndex                              INTEGER                          The upper bound of the array

 n                                     INTEGER                          The number of pairs of elements to compare in each pass

 NoMoreSwaps                           BOOLEAN                          TRUE when no swaps have occurred in current pass
                                                                        FALSE when a swap has occurred

 j                                     INTEGER                          Counte
                                                                           for inner loop
                                                                                      r


 Temp                                  INTEGER                          Variable for temporary storage while swapping values


Table 13.04 Identifier table for improved bubble sort algorithm


This improved algorithm in pseudocode is:

n < MaxiIndex            -    1

REPEAT

     NoMoreSwaps                  < TRUE

      FOR    j   «   0       TO    n

             IF MyList[j]                >   MyListlj    +   1]


                                                                                                                                  (Continued)
Cambridge International AS & A Level Computer Science




                   THEN

                       Temp < MyList[j]

                       MyList[j]            < MyListl[j        +   1]

                       MyList[j         +    1]       < Temp

                       NoMoreSwaps                <   FALSE

              ENDIF

       NEXT    j

       nen-            tl

  UNTIL   NoMoreSwaps             =   TRUE




Qo
   Bubble sort: a sort method where adjacent pairs of values are compared and swapped



Discussion Point:
What happensif the array elements are already in the correct order?


  TASK 13.05

  Rewrite the algorithm in Worked Example 13.03 to sort the array elements into
  descending order.




13.05 Two-dimensional arrays
When we write a table of data (a matrix) on a piece of paper and want to refer
                                                                             to individual
elements of the table, the convention is to give the row number first and then the column
number. When declaring a 2D array, the number of rows is given first, then the number of
columns. Again we have lower and upper bounds for each dimension.

In pseudocode, a 2D array declaration is written as:

  DECLARE     <identifier>              :    ARRAY[<1lBound1>:<uBoundl1>,
  <lLBound2>:<uBound2>]               OF         <dataType>


The array elements in a 2D array can be numbered from 0. Sometimes it is more intuitive to
use rows from row 1 and columns from column 1, as shown with the board game in Worked
Example 13.04 and 13.05.

To declare a 2D array to represent a game board of six rows and seven columns, the
pseudocode statement is:

  Board   :   ARRAY[1:6,1:7]                OF    INTEGER




Accessing 2D arrays
A specific element in a table is accessed using an index pair. In pseudocode this is written as:

  <arrayldentifier>[x,y]




Pseudocode example:
  Board[3,4]       <   0    //   sets       the       element      in row 3   and column 4   to   zero
                                                                                                 Part 2: Chapter 13: Data types and structures




When we want to access each element of a 1D array, we use a loop to access each element in
turn. When working with a 2D array, we need a loop to access each row. Within each row we
need to access each column. This means we use a loop within a loop (nested loops).

In structured English our algorithm is:

  For    each      row

        For    each        column

              Assign        the   initial     value       to       the   element     at   the    current   position



   WORKED EXAMPLE 13.04


  Working with two-dimensional arrays and nested loops

  Using pseudocode, the algorithm to set each element of array ThisTable to Zero is:

  FOR       Row   <    0   TO   MaxRowIndex

            FOR    Column <«       0   TO   MaxColumniIndex

                   ThisTable[Row,           Column]    <       0

         NEXT         Column

  NEXT       Row


  We need the identifiers shown in Table 13.05.

      Identifier                      Data type                                       Explanation

      ThisTable                     ARRAY [0:3,       0:5]         OF    INTEGER | Table data structure (2D array) to store values

      MaxRowIndex                     INTEGER                                         The upper bound of the row index

      MaxColumnIndex              | INTEGER                                           The upper bound of the column index


      Row                             INTEGER                                         Counter for the row index


      Column                          INTEGER                                         Counter
                                                                                          for the column index



  Table 13.05 Identifier table for working with a table


  When we want to output the contents ofa 2D array, we again need nested loops. We
  want to output all the values in one row of the array on the same line. At the end of the
  row, we want to output a newline.

  FOR    Row      <    0   TO   MaxRowIndex

         FOR      Column <«       0    TO   MaxColumnindex

                  OUTPUT        ThisTable[Row,        Column]            //   stay on     same   line

         NEXT         Column

         OUTPUT Newline                       //   move    to next            line   for next     row

  NEXT      Row




  TASK 13.06

  1     Declare a 2D array to store the board data for the game Noughts and Crosses. The
        empty squares of the board are to be represented by a space. Player A’s counters
        are to be represented by “O”. Player B’s counters are to be represented by “X”.
  2     Initialise the array to start with each square being empty.
  Ww




        Write a statement to represent player A placing their counter in the top left square.

  4     Write a statement to represent player B placing their counter in the middle square.
Cambridge International AS & A Level Computer Science




  WORKED EXAMPLE 13.05


 Creating a program to play Connect 4

 Connect 4 is a game played by two players. In the commercial version shown in Figure 13.06, one player uses
 red tokens and the other uses black. Each player has 21 tokens. The game board is a vertical grid of six rows
 and seven columns.




  Figure 13.06 A Connect 4 board


 Columns get filled with tokens from the bottom. The players take it in turns to choose a column that is not full
 and drop a token into this column. The token will occupy the lowest empty position in the chosen column. The
 winner is the player who is the first to connect four
                                                    of their own tokens in a horizontal, vertical or diagonal line. If
 all tokens have been used and neither player has connected four tokens, the game ends in a draw.

  If we want to write a program to play this game on a computer, we need to work out the steps required to
 ‘solve the problem’, that means to let players take their turn in placing tokens and checking for a winner. We
 will designate our players (and their tokens) by ‘O’ and ‘x’. The game board will be represented by a 2D array.
 To simplify the problem, the winner is the player who is the first to connect four of their tokens horizontally or
 vertically.

   Our first attempt in structured English is:

   Initialise         board

   Set   up     game

   Display board

   While       game    not   finished

         Player   makes        a   move

         Display board

         Check    if    game       finished

         If    game    not   finished,            swap    player


   The top-level pseudocode version using modules is:

    01   CALL    InitialiseBoard

    02   CALL    SetUpGame


    03   CALL    OutputBoard

    04   WHILE    GameFinished            =       FALSE   DO

    05          CALL    PlayerMakesMove

    06          CALL    OutputBoard

    07          CALL    CheckGameFinished

    08          IF GameFinished               =   FALSE


                                                                                                                         (Continued)
                                                                           Part 2: Chapter 13: Data types and structures




  09            THEN

  10               CALL SwapThisPlayer

  11        ENDIF

  12    ENDWHILE


Note that Steps 03 and 06 are the same. This means that we can save ourselves some effort. We only need
to define this module once, but can call it from more than one place. This is one of the advantages of using
modules.

The identifier table for the program is shown in Table 13.06.

 Identifier                                  Data type                 Explanation

 Board                                   ARRAY[1:6,1:7]    OF CHAR | 2D array to represent the board

 InitialiseBoard                                                       Procedure to initialise the board to all blanks

 SetUpGame                                                             Procedure to set initial values for GameFinished
                                                                       and ThisPlayer

 GameFinished                                BOOLEAN                   FALSE if the game is not finished
                                                                       TRUEif the board is full or a player has won

 ThisPlayer                                  CHAR                       'O' when it is Player O’s turn
                                                                        'x' when it is Player X’s turn

 OutputBoard                                                           Procedure to output the current contents of the board

 PlayerMakesMove                                                       Procedure to place the current player’s token into the
                                                                       chosen board location

 CheckGameFinished                                                     Procedure to check if the token just placed makes the
                                                                                             or board is full
                                                                       current player a winner

 SwapThisPlayer                                                         Procedure to change player’s turn


Table 13.06 Initial identifier table for Connect 4 game


  Now we can refine each procedure (module). This is likely to add some more identifiers to our identifier
  table. The additional entries required are shown after each procedure.

  PROCEDURE InitialiseBoard

         FOR Row «       1   TO   6

                FOR Column < 1          TO    7

                       Board[Row,      Column]      < BLANK // use a suitable value for blank
                NEXT    Column

         NEXT    Row

  ENDPROCEDURE



  Identifier                      | Data type                 | Explanation
  Row                                 INTEGER                  Loop counter for the rows

  Column                              INTEGER                  Loop counter
                                                                        for the columns

  BLANK                               CHAR                     A value that represents an empty board location


Table 13.07 Additional identifiers for the InitialiseBoard procedure

                                                                                                                           (Continued)
Cambridge International AS & A Level Computer Science




   PROCEDURE      SetUpGame

        ThisPlayer <          '0O'        //   Player O always          starts

        GameFinished < FALSE

   ENDPROCEDURE


   PROCEDURE      OutputBoard

        FOR     Row <    6   DOWNTO            1

                FOR    Column <«          1    TO    7

                       OUTPUT Board[Row,                 Column]      // don't move to next line
                NEXT    Column

                OUTPUT Newline // move to next                          line

        NEXT     Row

   ENDPROCEDURE


   PROCEDURE      PlayerMakesMove

        ValidColumn < PlayerChoosesColumn // a module returns column number
        ValidRow < FindFreeRow // a module returns row number
        Board[ValidRow,              ValidColumn]             < ThisPlayer

   ENDPROCEDURE



   Identifier                                      Data type           Explanation

   Validcolumn                                     INTEGER            The column number the player has chosen

   PlayerChoosesColumn                              INTEGER            Function to get the current player’s valid choice of
                                                                       column

   ValidRow                                         INTEGER            The row number that represents the first free location in
                                                                       the chosen column

   FindFreeRow                                      INTEGER            Function to find the next free location in the chosen
                                                                       column


  Table 13.08 Additional identifiers for the PlayerMakesMove procedure

    FUNCTION PlayerChoosesColumn RETURNS INTEGER// returns a valid column number
         OUTPUT       "Player        ",       ThisPlayer,       "'s   turn."

         REPEAT

                OUTPUT       "Enter a valid column number:                       "

                INPUT    ColumnNumber

         UNTIL ColumnNumberValid = TRUE // check whether the column number is valid
         RETURN       ColumnNumber

    ENDFUNCTION



   Identifier                                       Data type          Explanation

   ColumnNumber                                     INTEGER            The column number chosen by the current player

   ColumnNumberValid                                BOOLEAN                                 the chosen column is valid
                                                                              to check whether
                                                                       Function

  Table 13.09 Additional identifiers for ThisPlayerChoosesColumn function

    Note that we need to define the function ColumnNumberValid. A column is valid if itis within the range 1
    to 7 inclusive and there is still at least one empty location in that column.

                                                                                                                                   (Continued)
                                                                                          Part 2: Chapter 13: Data types and structures




  FUNCTION        ColumnNumberValid                 RETURNS     BOOLEAN

     //    returns whether or not                   the column number is valid

          Valid <      FALSE

          IF   ColumnNumber           >=   1   AND      ColumnNumber      <=    7

               THEN

                 IF   Board[6,        ColumnNumber]         =   BLANK   //     at   least   1   empty   space   in   column

                      THEN

                       Valid < TRUE

                 ENDIF

          ENDIF

          RETURN Valid

  ENDFUNCTION



 Identifier                            Data type                          Explanation

                                       BOOLEAN                            FALSE if column number is not valid
                                                                          TRUE if column number is valid


Table 13.10 Additional identifier for the ColumnNumberValid function


  FUNCTION        FindFreeRow          RETURNS          INTEGER

    //    returns       the next        free position

          ThisRow <       1

          WHILE    Board[ThisRow,              ValidColumn]       <>   BLANK DO      //   find   first   empty   cell

                 ThisRow < ThisRow              +   1

          ENDWHILE

          RETURN      ThisRow

  ENDFUNCTION



 Identifier                           Data type                           Explanation

 ThisRow                              INTEGER                             Points to the next row to be checked


Table 13.11 Additional identifier for the FindFreeRow function


  PROCEDURE        CheckGameFinished

          WinnerFound <          FALSE

          CALL    CheckIfPlayerHasWon

          IF WinnerFound          =    TRUE

            THEN

                 GameFinished < TRUE

                OUTPUT        ThisPlayer        "   is   the winner"

            ELSE

                CALL     CheckForFullBoard

          ENDIF

 ENDPROCEDURE


  Note that the checkGameFinished procedure uses two further procedures that we need to define.


                                                                                                                              (Continued)
      Cambridge International AS & A Level Computer Science




         Identifier                                                                  Data type        Explanation
        WinnerFound                                                              BOOLEAN              FALSE if no winning
                                                                                                                       line
                                                                                                      TRUE if a winning line is found

        CheckIfPlayerHasWon                                                                           Procedure to check if there is a winning line

        CheckVerticalLineInValidCcolumn                                                               Procedure to check if there is a winning vertical
                                                                                                      line in the column the last token was placed in

        CheckForFullBoard                                                                             Procedure to check whether
                                                                                                                              the board is full


       Table 13.12 Additional identifiers for the checkGameFinished procedure

         PROCEDURE            CheckIfPlayerHasWon

              WinnerFound <                        False

              CALL        CheckHorizontalLine

              IF WinnerFound                       =   FALSE

                 THEN

                      CALL             CheckVerticalLine

         ENDPROCEDURE

         PROCEDURE            CheckHorizontalLine

              FOR     i       <«   1   TO      4

                    IF        Board[ValidRow,                  i]       =       ThisPlayer AND

                          Board[ValidRow,                  i       +       1]    =    ThisPlayer AND

                          Board[ValidRow,                  i       +       2]    =    ThisPlayer AND

224                       Board[ValidRow,                  i       +       3]    =    ThisPlayer

                          THEN

                               WinnerFound < TRUE

                    ENDIF

              NEXT        i

         ENDPROCEDURE


         PROCEDURE            CheckVerticalLine

              IF ValidRow                  =   4    OR ValidRow                  =    5   OR ValidRow     =   6

                THEN

                      IF       Board[ValidRow,                  ValidColumn]                 =   ThisPlayer AND

                              Board[ValidRow               -       1,       ValidColumn]          =   ThisPlayer AND

                              Board[ValidRow               -       2,       ValidColumn]          =   ThisPlayer AND

                              Board[ValidRow               -       3,       ValidColumn]          =   ThisPlayer

                              THEN

                                   WinnerFound < TRUE

                      ENDIF

              ENDIF

        ENDPROCEDURE


        PROCEDURE          CheckForFullBoard

             BlankFound <                      FALSE

             ThisRow <                 0

             REPEAT

                      ThisColumn <                     0

                      ThisRow < ThisRow                        +       1

                      REPEAT



                                                                                                                                                          (Continued)
                                                                                            Part 2: Chapter 13: Data types and structures




                         ThisColumn < ThisColumn +                      1

                         IF Board[ThisRow,                   ThisColumn]     = BLANK

                              THEN

                                BlankFound < TRUE

                         ENDIF

                    UNTIL ThisColumn                =    7   OR BlankFound     =     TRUE

            UNTIL ThisRow            =    6    OR BlankFound =          TRUE

            IF   BlankFound          =    FALSE

                 THEN

                    OUTPUT     "It       is   a draw"

                    GameFinished < TRUE

            ENDIF

       ENDPROCEDURE



       Identifier               Data type                    Explanation

   BlankFound                   BOOLEAN                      FALSE if no blank location found on the board
                                                             TRUE if a blank location found on the board

   ThisRow                      INTEGER                      Loop counter for rows

       ThisColumn               INTEGER                      Loop counter
                                                                     for columns


  Table 13.13 Additional identifiers forthe CheckForFullBoard procedure

       PROCEDURE        SwapThisPlayer

             IF ThisPlayer           =    '0'

                 THEN

                    ThisPlayer <              'X'

                 ELSE


                    ThisPlayer <              '0'

             ENDIF


       ENDPROCEDURE




We can also use arrays of records. Using the Person record type from Section 13.02, we can
declare an array of that type for 100 person records:
DECLARE      Person      :   ARRAY[1:100]               OF PersonType

We can then access an individual’s data. For example the first person’s name in the array is
set as follows:
Person[1].Name <             "Fred"

OUTPUT      Person[1].Name


This is particularly useful when we have several people’s data to work with and do not want
to use a separate 1D array for each field.


  TASK 13.07

   1     Declare an array of BookType (see Task 13.02) for 200 books.
   2     Set the first book's details to the values given in Task 13.02.
 Cambridge International AS & A Level Computer Science




 13.06 Text files
 Data need to be stored permanently. One approach is to use a file. For example, any data held in
 an array while your program is executing will be lost when the program stops. You can save the
 data out to a file and read it back in when your program requires it on subsequent executions.

 A text file consists ofa sequence of characters formatted into lines. Each line is terminated by
 an end-of-line marker. The text file is terminated by an end-of-file marker.



Oo   TIP

     You can check the contents of a text file (or even create a text file required by a program) by using
     a text editor such as NotePad.




 Writing to a text file
 Writing to a text file usually means creating a text file.

 The following pseudocode statements provide facilities for writing to a file:

   OPENFILE      <filename>     FOR WRITE                  //        open    the       file       for writing

   WRITEFILE      <filename>,      <stringValue>            //       write       a    line    of    text    to    the    file

   CLOSEFILE      <filename>                           //       close        file



 Reading from a text file
 An existing file can be read by a program. The following pseudocode statements provide
 facilities for reading from a file:

   OPENFILE      <filename>     FOR READ                         //    open          file    for    reading

   READFILE      <filename>,     <stringVariable>                //    read a         line    of    text    from the       file

   CLOSEFILE      <filename>                                    //    close      file



 Appending to a text file
 Sometimes we may wish to add data to an existing file rather than create a new file. This can
 be done in Append mode. It adds the new data to the end ofthe existing file.

 The following pseudocode statements provide facilities for appending to a file:

   OPENFILE      <filename>     FOR APPEND             //       open        file      for     append

   WRITEFILE      <filename>,      <stringValue>           //    write       a       line    of    text    to    the    file

   CLOSEFILE      <filename>                          //    close           file



 The end-of-file (EOF) marker
 lf we want to read a file from beginning to end, we can use a conditional loop. Text files
 contain a special marker at the end of the file that we can test for. Testing for this special
 end-of-file marker is a standard function in many programming languages. Every time this
 function is called it will test for this marker. The function will return FALSE if the end ofthe file
 is not yet reached and will return TRUE if the end-of-file marker has been reached.

 In pseudocode we call this function Eor(). We can use the construct REPEAT...UNTIL EOF().
 If it is possible that the file contains no data, it is better to use the construct WHILE NOT EOF().

 For example, the following pseudocode statements read a text file and output its contents:

   OPENFILE      "Test.txt"     FOR    READ

   WHILE   NOT    EOF("Test.txt")       DO
                                                                                               Part 2: Chapter 13: Data types and structures




                    READFILE      "Test.txt",   TextString

                    OUTPUT TextString

               ENDWHILE

               CLOSEFILE    "Test.txt"




               TASK 13.08

               1   Write pseudocode to save the array data from Task 13.06 to a text file.
               2   Write pseudocode to read the values stored in the text file back into the
                   board array.




 13.07 Abstract Data Types (ADTs)
An Abstract Data Type is a collection of data and a set of associated operations:

                create a new instance of the data structure

                find an element in the data structure

                insert a new element into the data structure

                delete an element from the data structure

                access all elements stored in the data structure in a systematic manner.


                KEY TERM




The remainder of this chapter describes the following ADTs: stack, queue and linked list. It
also demonstrates how they can be implemented from arrays.

 in the following ADTs data items are represented as a single character, but this would
normally be a set of data, possibly stored as fields in a record.



 13.08 Stacks
What are the features ofa stack in the real world? To make a stack, we pile items on top of
each other. The item that is accessible is the one on top ofthe stack. If we try to find an item
in the stack and take it out, we are likely to cause the pile of items to collapse.
                                                                WB OD N
    sto DD N




                                                              OrRFN
OrRFNwW




                                                                                    <«   TopOfStackPointer
                                                                               |S
                                                                          PFPIDIN




                        < BaseOfStackPointer                                        < BaseOfStackPointer
                        <   TopofStackPointer


 Figure 13.07 An empty stack (left) and a stack with four items pushed (right)
Cambridge International AS & A Level Computer Science




Figure 13.07 shows how we can represent a stack when we have added four items in this
order: A, B, C, D. Note that the slots are shown numbered from the bottom as this feels
more natural.

The BaseOfStackPointer will always point to the first slot in the stack. The
TopOfStackPointer will point to the last element pushed (added) onto the stack. When an
element is popped (removed) from the stack, the TopofStackPointer will decrease to point
to the element now at the top of the stack. When the stack is empty, TopofStackPointer
will have the value -1.

To implement this stack using a 1D array, we write:

DECLARE       Stack:ARRAY[0:7]   OF   CHAR




      TASK 13.09

      1   Draw a diagram to show the contents of the stack shown in Figure 13.07 after “E”
          has been pushed onto the stack.
      2   Draw a diagram to show the contents of the stack shown in Figure 13.07 after one
          item has been popped off the stack.




13.09 Queues
What are the features ofa queue in the real world? When people form a queue, they join
the queue at the end. People leave the queue from the front of the queue. If itis an orderly
queue, no-one pushes in between and people don’t leave the queue from any other position.

Figure 13.08 shows how we can represent a queue when five items have joined the queue in
this order: A, B, C, D, E.

              <    FrontOfQueuePointer
              <    EndOfQueuePointer
                                                ©
©




                                                       IO |wo]y>
                                                      MIO




                                                                   <   FrontOfQueuePointer
                                                FEF
EF




                                                WN
WN




                                                                   <   EndOfQueuePointer
                                                ot
of
Non




                                                No




Figure 13.08 An empty queue (left) and a queue after
                                                   5 items have joined (right)

To implement a queue using an array, we can assume that the front of the queue is at
position 0. When the queue is empty, the EndofQueuePointer will have the value -1. When
one value joins the queue, the EndofQueuePointer will be incremented before adding
the value to the array element where the pointer is pointing to. When the item at the front
of the queue leaves, we need to move all the other items one slot forward and adjust
EndofQueuePointer.
                                                                             Part 2: Chapter 13: Data types and structures




     TASK 13.10

     1    Draw a diagram to show the contents of the queue after "F” has joined the
          non-empty queue shown in Figure 13.08.
     2    Draw a diagram to show the contents of the queue after one item has left the
          non-empty queue shown in Figure 13.08.




This method involves a lot of moving of data. A more efficient way to make use of the slots
is the concept of a ‘circular’ queue. Pointers show where the front and end ofthe queue are.
Eventually the queue will ‘wrap around’ to the beginning. Figure 13.09 shows a circular queue
after 11 items have joined and five items have left the queue.


0         |
1]       oJ
2        K    < EndOfQueuePointer
3
4


5        F    < FrontOfQueuePointer
6        G
7        H


Figure 13.09 A circular queue




13.10 Linked lists
In Section 13.03 we used an array as a linear list. In a linear list, the list iterns are stored
in consecutive locations. This is not always appropriate. Another method is to store an
individual list item in whatever location is available and link the individual item into an
ordered sequence using pointers.

An element of a list is called a node. A node can consist of several data items and a pointer,
which is a variable that stores the address of the node it points to.

A pointer that does not point at anything is called a null pointer. It is usually represented by
©. Avariable that stores the address of the first element is called a start pointer.


ft KEY TERMS




in Figure 13.10, the data value in the node box represents the key field of that node. There are
likely to be many data items associated with each node. The arrows represent the pointers.
it does not show at which address a node is stored, so the diagram does not give the value of
the pointer, only where it conceptually links to.
Cambridge International AS & A Level Computer Science




StartPointer




                             node                            node                     node

Figure 13.10 Conceptual diagram of a linked list


Figure 13.11 shows how a new node, A, is inserted at the beginning ofthe list. The content of
StartPointer is copied into the new node’s pointer field and Start Pointer              is set to point
to the new node,
               A.

StartPointer


    veeee L - - >|       B




                                                                                                 Q
                                                                            Vv
                                             Vv




                                                         Oo
                        A node                                node                     node




           A



               node

Figure 13.11 Conceptual diagram of adding a new node to the beginning of a linked list


In Figure 13.12,      anew node, P, is inserted at the end of the list. The pointer field of node L
points to the new node, P. The pointer field of the new node, P, contains the null pointer.

StartPointer




                       node                       node                    node



                                                                                        P         q
                                                                                         node


Figure 13.12 Conceptual diagram of adding a new node to the end of a linked list


To delete the first node in the list (see Figure 13.13), we copy the pointer field of the node to
be deleted into startPointer.

StartPointer


    oon L - - - pI       B                               D
                                                                                                 Q
                                                                            Vv




                             node                   AR        node                     node


Figure 13.13 Deleting
                   the first node in a linked list

To delete the last node in the list (see Figure 13.14), we set the pointer field for the previous
node to the null pointer.

StartPointer




                             node                             node                     node


Figure 13.14 Conceptual diagram of deleting the last node of a linked list
                                                                             Part 2: Chapter 13: Data types and structures




Sometimes the nodes are linked together in order of key field value to produce an ordered linked
list. This means a new node may need to be inserted or deleted from between two existing nodes.

To insert a new node, C, between existing nodes, B and D (see Figure 13.15), we copy the
pointer field of node B into the pointer field of the new node, C. We change the pointer field of
node B to point to the new node, C.

StartPointer




                         node                    A        node                      node




                                      node


Figure 13.15 Conceptual diagram of adding a new node into a linked list

To delete a node, D, within the list (see Figure 13.16), we copy the pointer field of the node to
be deleted, D, into the pointer field of node B.

StartPointer




                                                                                              iS)
               v




                      lus)




                                          v


                                                     Oo




                                                                         v




                         node                             node                  A   node



Figure 13.16 Conceptual diagram of deleting a node within a linked list

Remember that, in real applications, the data would consist of much more than a key field
and one data item. This is why linked lists are preferable to linear lists. When list elements
need reordering, only pointers need changing in a linked list. In a linear list, all data items
would need to be moved.

Using linked lists saves time, however we need more storage space for the pointer fields.

To implement a linked list using arrays, we can use a 1D array to store the data and a 1D array to
store the pointer. Reading the array values across at the same index, one row represents a node.

A value is added to the next free element of the Data array and pointers are adjusted to
incorporate the node in the correct position within the linked list.

Figure 13.17 shows how two arrays can be used to implement the linked list from Figure 13.10.

                                          Data        Index      Pointer


StartPointer                 1               L             [0]      -1

                                             B             [1]       2


                                             D             [2]       0

                                                           [3]

                                                           [4]

                                                           [5]

                                                           [6]


Figure 13.17 Using arrays to implement the linked list shown in Figure 13.10
Cambridge International AS & A Level Computer Science




Figure 13.18 shows how a new node is added to the beginning of a linked list implemented
using arrays. Note that the value “A” is added at index 3 but the start pointer is adjusted to
make this the new first element ofthe list.

                                          Data       Index       Pointer


StartPointer          + 3                   L          [0]           -1

                                            B          [1]            2

                                            D          [2]            0

                                            A          [3]            1




                                                       [6]



Figure 13.18 Adding a new node to the beginning of a linked list

Figure 13.19 shows how a new node is added to the end of a linked list implemented using
arrays. Note that the value “P” is added at index 3. The node that previously contained the
null pointer (at index 0) has its pointer adjusted to point to the new node.

                                           Data       Index      Pointer


StartPointer            1                     L         [0]        =+ 3

                                              B         [1]          2


                                              D         [2]          0

                                              P         [3]          -1




                                                        [6]



Figure 13.19 Adding a new node to the end of a linked list implemented using arrays

When deleting a node, only pointers need to be adjusted. The old data can remain in the
array, but it will no longer be accessible as no pointer will point to it.

Figure 13.20 shows how the start pointer is adjusted to effectively delete the first element of
the linked list. Note that the start pointer now contains the pointer value of the deleted node.

                                           Data        Index     Pointer


StartPointer           +2                     L         [0]          -1

                                              B         [1]          2


                                              D         [2]           0

                                                        [3]

                                                        [4]

                                                         [5]

                                                         [6]



Figure 13.20 Deleting the first node in a linked list implemented using arrays
                                                                        Part 2: Chapter 13: Data types and structures




Figure 13.21 shows how the pointer value of the penultimate node of the linked list is
changed to the null pointer.


                                         Data       Index     Pointer


StartPointer             1                 L          [0]         -1

                                           B          [1]         2

                                           D          [2]       6 -1

                                                      [3]


                                                      [4]

                                                      [5]


                                                      [6]



Figure 13.21 Deleting
                   the last node of a linked list implemented using arrays


When adding a node that needs to be inserted into the list, the data is added to any free
element of the Data array. The pointer of the new node is set to point to the index of the node
that comes after the insertion point. Note that this is the value of the pointer of the node
preceding the insertion point. The pointer of the node preceding the insertion point is set to
point to the new node.


                                         Data       Index     Pointer


StartPointer             1                 L          LO]         -1

                                           B          [1]        2 3


                                           D          [2]         0

                                           Cc         [3]         2




Figure 13.22 Adding a new node into a linked list implemented using arrays


Again, when deleting a node, only pointers need to be adjusted. Figure 13.23 shows how the
pointer of the node to be deleted is copied into the pointer of the preceding node.


                                         Data       Index     Pointer


StartPointer                               L          [0]         -1

                                           B          [1]        20


                                           D          [2]         0

                                                      [3]


                                                      [4]

                                                      [5]


                                                      [6]



Figure 13.23 Deleting a node within a linked list implemented using arrays
Cambridge International AS & A Level Computer Science




Unused nodes need to be easy to find. A suitable technique is to link the unused nodes to
form another linked list: the free list. Figure 13.24 shows our linked list and its free list.


StartPointer


              >     B                   D              >        L           ©


                    node                 node                   node




FreeListPtr


              >                                        >                        >                4

                    node                 node                   node                    node


Figure 13.24 Conceptual diagram of a linked list and a free list


When an array of nodes is first initialised to work as a linked list, the linked list will be empty.
So the start pointer will be the null pointer. All nodes need to be linked to form the free
list. Figure 13.25 shows an example of an implementation of a linked list before any data is
inserted into it.



                                            Data       Index        Pointer


StartPointer               -1                            LO]            1

                                                         [1]            2

FreeListPtr                0                             [2]            3


                                                         [3]            4


                                                         [4]            5

                                                         [5]            6

                                                         [6]           -1



Figure 13.25A linked list and a free list implemented using arrays


Assume “L”, “B” and “D” were added to the linked list and to be kept in alphabetical order.

Figure 13.26 shows how the values are stored in the Data array and the pointers ofthe linked
list and free list adjusted.


                                            Data       Index        Pointer


StartPointer               1                    L        LO]           -1

                                                B        [1]            2

FreeListPtr                3                    D        [2]            0


                                                         [3]            4


                                                         [4]            5

                                                         [5]            6

                                                         [6]           -1



Figure 13.26 Linked list and free list implemented using arrays
                                                                            Part 2: Chapter 13: Data types and structures




If the node containing “B” is to be deleted, the array element of that node needs to be linked
back into the free list. Figure 13.27 shows how this is done by adding the node to the front of
the free list.



                                           Data      Index        Pointer



StartPointer                                          [0]              -1


                                                      [1]          2    0


FreeListPtr                                           [2]               3


                                                      [3]

                                                      [4]

                                                      [5]

                                                      [6]


Figure 13.27 Linked list and free list implemented using arrays




   TASK 13.11

   A linked list is to be set up using the values in the UserID array shown below.

                                            UserID     Index        Pointer



   StartPointer
                                             BRO1           [0]

                                             FL39           [1]

                                             CK25           [2]

                                             AS23           [3]

                                             DT71           [4]

                                             EB95           [5]

                                                            [6]


   Without moving any of the contents of the UserID array, insert the pointer values so that the
   linked list is in alphabetical order.




In Section 13.02 we looked at the user-defined record type. We grouped together related
data items into record data structures. To use a record variable, we first define a record type.
Then we declare variables of that record type.

We can store the linked list in an array of records. One record represents a node and consists
of the data and a pointer (see Figure 13.28).
Cambridge International AS & A Level Computer Science




                                                                                    List
                                                                         Data              Pointer

                                                             [0]                                1

Start Pointer               -1                               [1]                                2

                                                             [2]                                3

FreeListPtr                 0                                [3]                                4

                                                             [4]                                5

                                                             [5]                                6

                                                             [6]                               -1


Figure 13.28 A linked list before any nodes are used



0   TIP

    Astack can be implemented from a linked list. The start pointer is seen as the top of stack pointer
    and a data item is only added to the start of the linked list and a node is only removed from the
    start of the linked list.




0   TIP

    A queue can be implemented from a linked list. The start pointer is seen as the front of the queue.
    Data items are always added to the end of the linked list and items are always removed from the
    start of the linked list.




Ref lection Point:
What is the difference between standard data types, ADTs and user-defined data types?




      Standard data types are INTEGER, REAL, CHAR, STRING, BOOLEAN, DATE.

      Arecord structure holds a set of data of different data types under one identifier.

      Use the dot notation to address fields of a record.

      Arrays have dimensions with upper and lower bounds.

      Individual array elements are accessed using an index (1D arrays) or two indexes (2D arrays).

      A bubble sort algorithm compares pairs of values in a linear list and swaps them if required.

      A linear search checks each value in turn for a required value.

      Text files can be written to and read from and store data between program runs.

      Stacks, queues and linked lists are examples of Abstract Data Types (ADTs) and can be implemented
      using arrays.
                                                                             Part 2: Chapter 13: Data types and structures




Exam-style Questions

1   Complete the following variable identifier table:

     Variable                               Example value            Data type

     ColourCode                             “034AB45”

     ProductionDate                         2018/03/31

     Weight                                 67.45

     NumberInStock                          98


     SizeCode                               TM’

     Completed                              FALSE
                                                                                                           [3]
2   Astack and a queue are used to reverse the order of a set of values.

    Complete
          the diagram:

Front   of   Queue   =>                                                          Front   of   Queue   =>
                             A)}Ul]
                                al] wy],




                                           Base   of   Stack    =>

                                                                                                           [2]
3   Alicia uses two 1D arrays, UserList and PasswordList. For twenty users, she stores each user ID in
    UserList and the corresponding password in PasswordList. For example, the person with user ID
    Fred12 has password rzt456.

             UserList                                                PasswordList


      [0]       Matt0o5                                        [0]      pgqk1imn4

      [1]       Fred12                                         [1]      rzt456

      [2]       Anna9                                      [2]          jedd321




    [20]}     Xenios4                                     [20]         wkl@tmp6


    Alicia wants to write an algorithm to check whether a user ID and password, entered by a user, are
    correct. She designs the algorithm to search UserList for the user ID. If the user ID is found, the
    password stored in PasswordList is to be compared to the entered password. If the passwords
    match, the login is successful. In all other cases, login is unsuccessful.
      Cambridge International AS & A Level Computer Science




        a   Complete the identifier table.

                 Identifier                           Data type           Explanation

                 UserList                                                 1D array to store user IDs


                                                                          1D array to store passwords



                 MaxIndex                                                 Upper bound           of the array


                 MyUserID                                                 User ID entered
                                                                                      to login


                 MyPassword                   fo                          ieaveesseestesseeareenees

                 UserlIdFound                                             FALSE if user ID not found in UserList
                                                                          TRUE
                                                                             if ceccccceeseseeeaes

                 LoginOK                                                  FALSE if ..eeeseceeseeeeses
                                                                          TRUE
                                                                             if cocccccceeeeseeeane

                 Index                                                    Pointer to current array element


            Complete the pseudocode for Alicia’s algorithm:
            MaxIndex            <       20

                INPUT     MyUserID

                INPUT     MyPassword

            UserIdFound <                    FALSE

            LoginOK <               ...............

                Index     <    -1

            REPEAT
238
                     INDEX          <    ...............



                          THEN

                               UserIdFound < TRUE

                    ENDIF

            UNTIL         ...........206-         (©)    Se

            IF     UserIdFound               =   TRUE

                  THEN

                     IF       PasswordList[............... ]       =     we...
                                                                           eee ee eee

                          THEN

                               LoginOK < TRUE

                     ee




                    OUTPUT              "Login    successful"
                  ELSE

                    OUTPUT              "User    ID    and/or password    incorrect"
            ENDIF

            i       Instead of using two 1D arrays, Alicia could have used an array of records.

                    Write pseudocode to declare the record structure UserRecord.

            ii      Write pseudocode to declare the user array.
Programming and data representation

Learning objectives
By the end of this chapter you should be able to:

   write a program in a high-level language (Python, Visual Basic    use a loop (‘count controlled’, ‘post-condition’, ‘pre-condition’)
   console mode, Java)                                               justify why one loop structure may be better suited to a
   implement and write pseudocode from a given design                problem than the others
   presented as either a program flowchart or structured English     define and use a procedure and explain where in the
   write pseudocode and program statements for:                      construction of an algorithm it is appropriate to use a
   «   the declaration of variables and constants                    procedure
   *   the assignment of values to variables and constants           use parameters

   *   expressions involving any of the arithmetic or logical        show understanding of passing parameters by reference and
       operators                                                     by value
   ¢   input from the keyboard and output to the console             define and use a function and explain where in the
   use a Subset of the built-in functions and library routines       construction of an algorithm it is appropriate to use a function
   supported by the chosen programming language, including           show understanding that a function is used in an expression
   those used for string/character manipulation and random           (the return value replaces the call)
   number generator                                                  use the terminology associated with procedures and
   use an ‘IF’ structure including the ‘ELSE’ clause and nested IF   functions: procedure/function header, procedure/function
   statements                                                        interface, parameter, argument, return value
   use a ‘CASE’ structure                                            write efficient code.
Cambridge International AS & A Level Computer Science




 14.01 Programming languages
Chapters 12 and 13 introduced the concept ofsolving a problem and representing a solution
 using a flowchart or pseudocode. We expressed our solutions using the basic constructs:
assignment, sequence, selection, iteration, input and output.

To write a computer program, we need to know the syntax (the correct structure of
statements) of these basic constructs in our chosen programming language. This chapter
 introduces syntax for Python, Visual Basic console mode and Java.

 Note that for convenience and easy reference, definitive pseudocode syntax is repeated in
this chapter at the appropriate points.

You only need learn to program in one ofthe three languages covered in this book.
 Programming language is only examined at A Level but it is important to start learning
 it from AS Level to ensure you are well-prepared. For the AS Level exams you should use
 pseudocode rather than programming language.



Oo   TIP

     The only way of knowing whether the algorithm you have designed is a suitable solution to the
     problem you are trying to solve, is to implement your pseudocode in your chosen programming
     language and test the program by running it.




 Python
 Python was conceived by Guido van Rossum in the late 1980s. Python 2.0 was released in
2000 and Python 3.0 in 2008. Python is a multi-paradigm programming language, meaning
that it fully supports both object-oriented programming and structured programming.
 Many other paradigms, including logic programming, are supported using extensions. These
 paradigms are covered in Chapters 26, 27 and 29.

The Python programs in this book have been prepared using Python 3 (see www.python.org
for a free download) and Python’s Integrated DeveLopment Environment (IDLE).

 Key characteristics of Python include the following.

 e   Every statement must be on a separate line.

 e   Indentation is significant. This is known as the ‘off-side rule’.

 e   Keywords are written in lower case.

 e   Python is case sensitive: the identifier Number1 is seen as different from number1 or
     NUMBER1.


 e   Everything in Python is an object (see Chapter 27).

 e   Code makes extensive use of a concept called ‘slicing’ (see Section 14.07).
 e   Programs are interpreted (see Chapter 8, Section 8.05 for information on interpreted and
     compiled programs).

 You can type a statement into the Python Shell and the Python interpreter will run it
 immediately (see Figure 14.01).
                                                                                  Part 2: Chapter 14: Programming and data representation




       Python Shell                                                                                                         -([O] x!
    File   Edit   Shell   Debug   Options   Windows    Help
    Python 3.2.3 (default, Apr 11 2012, 07:12:16) [MSC v.1500 64 bit (AMD64)] on win32 a]
    Type      "copyright",         "credits"      or    "license()"   for more     information.
    >>> print ("Hello             World!")
    Hello World!
    >>>
      |




Figure 14.01 Running a statement in the Python shell


You can also type program code into a Python editor (such as IDLE), save it with a .py extension and then run the
program code from the Run menu in the editor window (see Figure 14.02).




                                                                      Python 3.2.3     (default,   Apr   11   2012,   07:12:16)   [MSC v.1500   64 bit   (AMD64)]   on
       # my first program
                                                                      win32

       print ("Hello World!")                                         Type "copyright",     "credits" or "license()" for more information.
                                                                      >>>                                             RESTART
                                                                      >>>

                                                                      Hello   World!

                                                                      >>>




Figure 14.02 (a) Asaved program in the Python editor window and (b) running in the Python shell



Visual Basic Console Mode (VB.NET)
VB.NET is a multi-paradigm, high-level programming language, implemented on the .NET
Framework. Microsoft launched VB.NET in 2002 as the successor to its original Visual Basic
language. Microsoft’s integrated development environment (IDE) for developing in VB.NET is
Visual Studio. Visual Studio Express and Visual Studio Community are freeware.

The Visual Basic programs in this book have been prepared using Microsoft Visual Basic
2010 Express Console Application. (Free download available from www.visualstudio.com/
products/visual-studio-express-vs)

Key characteristics of VB.NET include the following.

e      Every statement should be on a separate line. Statements can be typed on the same line
       with a colon (:) as a separator. However, this is not recommended.
e      Indentation is good practice.

e      VB.NET is not case sensitive. Modern VB.NET editors will automatically copy the case from
       the first definition of an identifier.

e      The convention is to use CamelCaps (also known as PascalCaps) for identifiers and keywords.
e      Programs need to be compiled (see Chapter 8, Section 8.05 for information on interpreted
       and compiled programs).

You type your program code into the Integrated Development Environment (IDE) as shown
in Figure 14.03 (a), save the program code and then click on the Run button DI. This starts
the compiler. If there are no syntax errors the compiled program will then run. Output will be
shown in a separate console window (see Figure 14.03 (b)).

Note that the console window shuts when the program has finished execution. To keep the
console window open so you can see the output (see Figure 14.03), the last statement of your
program should be

Console.ReadLine()
Cambridge International AS & A Level Computer Science




                                                                        x}
                                                                      {5}
                                                                             Hello World?
    & ConsoleApplication1 (Running) - Microsoft Visual Basic 2010 =


    SS                SS         o az?
    PIG A-a@l|4 Bala@la2l|o9-e-l
    Modulel.vb

     6Modulet                            - | ©) (Declarations)
            =|Module Modulel


            =         Sub Main()
                            Console.WriteLine("Hello World!”)
                            Console.ReadLine()
                      End   Sub
                1


     100%           ~ 4]

    Error List


    1 vers Aho vanegs [© ova: |
     4 Immediate Window


    Ready             Ln7




Figure 14.03 (a) Asaved program in the VB.NET editor and (b) running in the program execution
(console) window



Java
Java was originally developed by James Gosling at Sun Microsystems (now owned by Oracle)
and released in 1995. The Java Runtime Environment (JRE) is intended for end users, and the
Java Development kit (JDK) is intended for software developers and includes development
tools such as the Java compiler and a debugger.

Java was intended to be platform independent. The Java programs in this book have been
prepared using NetBeans 8.2. However, any text editor can be used to write Java source code.

Key characteristics of Java include the following.

e   Every statement ends with a semicolon (;). More than one statement can go on a single
    line, but this is not recommended.

e   Indentation is good practice.

e   Java is case sensitive.

e   Theconvention is to use camelCaps for identifiers, lower case for keywords and
    capitalised identifiers for classes.

e   Acompound statement consists ofa sequence of statements enclosed between braces { }.
e   Whenever Java syntax requires a statement, a compound statement can be used.
e   Programs need to be compiled (see Chapter 8, Section 8.05 for information on interpreted
    and compiled programs) into bytecode and then run using the Java Virtual Machine.
Java was designed almost exclusively as an object-oriented language. All code is written inside
classes. Only the simple data types (such as integer, real) are not objects. Strings are objects.

Source files must be named after the public class they contain, appending the suffix java, for
example, Ex1.java. It must first be compiled into bytecode, using a Java compiler, producing
a file named Ex1.class. Only then can it be executed.

The method name “main” is not a keyword in the Java language. It is simply the name of the
method the Java launcher calls to pass control to the program.

You type your program statements into the Integrated Development Environment (IDE) as
shown in Figure 14.04, save the program code and then click on the Run button ( })). This
starts the compiler. If there are no syntax errors the compiled program code will then run.
Output will be shown in the Output window (see Figure 14.04).
                                                                 Part 2: Chapter 14: Programming and data representation




  ® Ex) - NetBeans IDE 8.2

 File Edit View Navigate Source Refactor Run Debug Profile Team Tools Window Help              | Qy Search (Ctri+1)                |

 PEOE
   Rota
      S                                                         i TB D-B-G-
  Proj... X|Files | Services |           —||   StartPage | |si} Exijava |               Jy
  a                                            sore |iistry | M-H-EGP     \Q2e
                                                                            eel\avP
                                                                                  ieng|aua #
          2-8 nt         3                       1      package exl;                      “\a

     eB 8 Ex1java                               3     public class Ex1                                                        in
     a-     Test Libraries                      5          public static void main(String[]    args)


                                               71              System. out.printin("Hello World!");                       | |~
                                                é          {


                                                8          }
                                                9     }
                                               10                                                                         v
                                                      <)                      mI                    |                 >
                                               >                                                                            x



  Navigator X |                 — || Output -Ext (run) x |                                                                  =
  Members       v || <emoty> » | >| Bette Worla!
  B® Ex1                                       J    BUILD SUCCESSFUL (total time: 0 seconds)
      s- @) main(String] args)

                    -            |             2
   @ (G1 ||B)[@) & [88] 48


Figure 14.04
         A Java program in the NetBeans editor and running in the Output window


14.02 Programming basics
Declaration of variables
Most programming languages require you to declare the type of data to be stored ina
variable, so the correct amount of memory space can be reserved by the compiler. A variable
declared to store a whole number (integer) cannot then be used to store alphanumeric
characters (strings), or the other way around. VB.NET and Java require variables to be
declared before they are used.

Python handles variables differently to most programming languages. It tags values. This is
why Python does not have variable declarations.




    TIP

    Itis good programming practice to include a comment about the variables you are planning
                                                                                          to
    use and the type of data you will store in them.



In pseudocode, variable declarations are written as:
  DECLARE     <identifier>           :   <dataType>

For example, you may declare the following variables:
Cambridge International AS & A Level Computer Science




  DECLARE Numberl                 :       INTEGER //                 this    declares Numberl        to       store a whole number

  DECLARE YourName                    :   STRING               //    this    declares YourName           to   store a

                                                               //    sequence of       characters

  DECLARE N1,       N2,       N3           :    INTEGER               //    declares    3   integer variables

  DECLARE Namel,             Name2               :       STRING //          declares    2   string variables



Syntax definitions
The syntax of variable declarations in language code is as follows:

 Python                       Python does not have variable declarations
 VB.NET                      Dim <identifier=[, <identifier>]As <dataType>
                              Each line of declarations must start with the keyword Dim.
 Java                         <datatype> <identifier>[,                                <identifier>];




Code examples
                    # Numberl                    of       type        Integer               There are no declarations,
                                                                                                                   but
                    # YourName of type String                                               comments should be made atthe
                    #       N1,       N2,        N3       of        type    integer;         beginning
                                                                                                    of a module (see the
                    # Namel,                    Name2 of type string;                       section about comments
                                                                                                               at the end
                                                                                            of Section 14.02).

 VB.NET             Dim Numberl As Integer                                                  You can group more than one
                    Dim YourName As                                 Integer                 variable of the same type on the
                    Dim N1,                    N2,       N3    As     Integer               same line.
                    Dim Namel,                       Name2          As     String

                    int       number1;                                                      You can group more than one
                    String yourName;                                                        variable of the same type on the
                    int       nl,              n2,       n3;                                same line.
                    String namel,                             name2;




Declaration and assignment of constants
Sometimes we use a value in a solution that never changes, for example, the value of the
mathematical constant pi (x). Instead of using the actual value in program statements, it is
good practice and helps readability, if we give a constant value a name and declare it at the
beginning of the program.

In pseudocode, constant declarations are written as:

  CONSTANT     <identifier>                          =    <value>

For example:

  CONSTANT     Pi       =    3.14



Syntax definitions
 Python                       <identifier> = <value>

 VB.NET                       Const <identifier> = <value>
                              Each line of declarations must start with the keyword Const.
 Java                         static                 final          <datatype>      <identifier>         =    <value>;
                              Each line of constant declarations must start with the keywords
                              static                 final
                                                                       Part 2: Chapter 14: Programming and data representation




Code examples
               PI = 3.14                            Python convention is to write constant identifiers using
                                                    uppercase only. The values can be changed, although you
                                                    should treat constants as not changeable.

               Const Pi = 3.14                      The value
                                                           of a constant in VB.NET cannot be altered within the
                                                    program.


               static final double | Thevalueofaconstant
                                                    in Java cannot be altered within the
               PI   =   3.14;                       program.




Assignment of variables
Once we have declared a variable, we can assign a value to it (See Chapter 12, Section 12.05).

in pseudocode, assignment statements are written as:

  <identifier>          <       <expression>

For example:

 A   <   34

  Be     Bel




Syntax definitions and code examples
               <identifier>           =    <expression>         A =        34        The assignment operator is =
                                                                B=B4+1

               <identifier>           =    <expression>         A =        34        The assignment operator is =
                                                                B=B+4#+1

               <identifier>           =    <expression>;        |A =       34;       The assignment operator is =
                                                                Bz=B+441;


VB.NET allows you to initialise a variable as part of the declaration statement, for example:
  Dim Numberl           As       Integer   =   0


Java allows you to initialise a variable as part of the declaration statement, for example:
  int    numberl        =       0;

VB.NET and Python allow increment statements such asB = B + 1tobewrittenasB += 1.

Java allows increment statements such asSb = b + 1to bewritten as b++4;


Arithmetic operators
Assignments don’t just give initial values to variables. We also use an assignment when we
need to store the result of a calculation. The arithmetic operators used for calculations are
shown in Table 14.01.


 Operation                  Pseudocode | Python | VB.NET | Java
 Addition                   +                  +         +          +
 Subtraction                -                  -         -             -

 Multiplication             .                  .         *             .
 Division                   /                  /         /         / (when dividing float or double types)

 Exponent                   ‘                            ‘             No operator available, only method:
                                                                   Math. pow(n,e)

 Integer division       | DIV                  //        \         / (when dividing integer types)
 Modulus                    MOD                %         Mod           %


Table 14.01 Arithmetic operators
Cambridge International AS & A Level Computer Science




Oo   TIP

     The result of integer division is the whole number part ofthe division. For example, 7 DIV 2 gives 3.




Oo   TIP

     The result of the modulus operation is the remainder of a division. For example, 7 MOD 2 gives 1.




When more than one operator appears in an expression, the order of evaluation depends
 on the mathematical rules of precedence: parentheses, exponentiation, multiplication,
 division, addition, subtraction.


Qe
     Rules of precedence: define the order of the calculations to be performed


 Question 14.01
 Evaluate each of the following expressions:

4A*3-342

 (4*3-3)%2

4A*(3-3)42

4* (3-342)


 Outputting information to the screen
 In pseudocode, output statements are written as:

   OUTPUT    <string>

   OUTPUT    <identifier(s)>

 When outputting text and data to the console screen, we can list a mixture of output strings
 and variable values in the print list.


 Syntax definitions
 Mare)      print (<printlist>)                              Print list items are separated by commas (,).
            print (<printlist>,           end ='')          To avoid moving onto the next line after the
                                                            output,
                                                                 use end         ='')

 1:4)        Console.WriteLine(<printlist>) | Print list items are joined using &.
             Console.Write(<printlist>)       Console.WriteLine          will move onto the
                                                             next line after the output; Console .Write will
                                                             remain on the same line.

             System.out.print (<printlist>);   Print list items are joined using +.
             System.out.println(<printlist>); | system. out .print1n will move onto the
                                                             next line after the output; System. out.print
                                                            will remain onthe same line.

 in the examples below, the print list consists of four separate items:
 “Hello” and “. Your number is” are strings and
 YourName and Number] are variables, for which we print the value.

 In pseudocode, we can indicate whether a new line should be output at the end by a
 comment at the end of the statement.

 OUTPUT    "Hello    ",   YourName,      ".   Your number     is   ",   Numberl    //   newline

 OUTPUT    "Hello    "    //   no new   line
                                                                          Part 2: Chapter 14: Programming and data representation




Code examples
                         print ("Hello        ",   YourName,
                            ".   Your    number       is   ",       Number1)
                         print ("Hello        ",   end=    '')

                         Console.WriteLine ("Hello                    "       & YourName      &
                            ">   Your number          is   "    & Numberl1)
                         Console.Write ("Hello")

                         System.out.printin("Hello                        "   + yourName          +
                            ".   Your number          is   "    +     numberl);
                         System.out.print ("Hello");


in the code examples above you can see how output statements can be spread over more
than one line when they are very long. You must break the line between two print list items.
You cannot break in the middle of a string, unless you make the string into two separate
strings.

In Python and VB.NET you can also use the placeholder method for output: the variables
to be printed are represented by sequential numbers in { } in the message string and the
variables are listed in the correct order after the string, separated by commas:

                         print   ("Hello       {0}.    Your         number          is    {1}".format (YourName,
                         Number1)
                                )

                         Console.WriteLine ("Hello                    {0}.         Your   number      is    {1}",
                         YourName,      Number1)




Getting input from the user
When coding an input statement, it is good practice to prompt the user as to what they are
meant to enter. For example, consider
                                   the pseudocode statement:

  INPUT    "Enter    a   number:   "A

Note the space between the colon and the closing quote. This is significant. It gives a space
before the user types their input.


Code examples
                A =      input("Enter a number:                  ")                               The prompt is provided asa parameter
                                                                                                  to the input function. Single quotes are
                                                                                                  also accepted. All input is taken to be
                                                                                                  a string; if you want to use the input
                                                                                                  as anumber the input string has to be
                                                                                                  converted using a function (see Section
                                                                                                  14.07).

                 Console.Write("Enter a number:                               ")                  The prompt has to be supplied as an
                A = Console.ReadLine
                                   ()                                                             output statement separately

                 import     java.util.Scanner;                                                    The Scanner class has to be imported
                 Scanner     console      =    new    Scanner (System.in); | from the Java library first and a

                 System.out.print ("Enter a number:                                ");            scanner object has to be created
                 a   =   console.next ();                                                         before it can be used to read an input
                                                                                                  string.
                                                                                                  The prompt has to be supplied as an
                                                                                                  output statement separately.



Comments
It is good programming practice to add comments to explain code where necessary.
Cambridge International AS & A Level Computer Science




Code examples
Python                      # this    is    a       comment
                            # this    is    another       comment


VB.NET                        this    is    a       comment

                              this    is    another       comment


Java                           this    is       a    comment

                               this    is       another       comment
                               this    is       a multi-line
                               comment




  TASK 14.01

   Use the IDE of your chosen programming language (in future just referred to as ‘your
  language’). Type the program statements equivalent to the following pseudocode
  (you may need to declare the variable YourName first):
   INPUT      "What    is   your   name?        "    YourName

  OUTPUT       "Have    a nice     day     ",       YourName

   Save your program as Example1 and then run it. Is the output as you expected?




14.03 Data types
Every programming language has built-in data types. Table 14.02 gives a subset of those
available. The number of bytes of memory allocated to a variable of the given type is given in
brackets for VB.NET and Java.


 Description of data           Pseudocode                Python

Whole signed numbers          | INTEGER                  int                Integer                int (4 bytes)
                                                                            (4 bytes)

 Signed numbers witha         | REAL                     float              Single (4bytes)      | float (4 bytes)
 decimal point                                                              Double (8 bytes)     | double (8 bytes)


A single character             CHAR                      Not available      Char (2 bytes -        char
                               Use single (")                               Unicode)               (2 bytes- Unicode)
                               quotation marks
                               to delimita
                               character

A sequence of characters | STRING                str (stored                String (2 bytes        String
 (a string)                    Use double ("")   as ASCII but               per character)         (2 bytes per
                               quotation marks | Unicode                    Use double (")         character)
                               to delimita       strings are also_|         quotation marks   to | Use double (")
                               string.           available)                 delimit a string.      quotation marks
                                                 Use single ("),                                   to delimit a string.
                                                 double (") or
                                                 triple (''' or
                                                         ") quotation
                                                         marks to
                                                         delimit
                                                               a string.

 Logical values:               BOOLEAN                   bool               Boolean
                                                                                (2 bytes) |Boolean
 True (represented as 1)                                 possible values: | possible values:       possible values:
 and                                                     True               True                   true
 False (represented as 0)                                False              False                  false

Table 14.02 Simple data types
                                                             Part 2: Chapter 14: Programming and data representation




In Python, a single character is represented as a string of length 1.

In VB.NET, each character in a string requires two bytes of memory and each character is
represented in memory as Unicode (in which, the values from 1 to 127 correspond to ASCIl).

Date has various internal representations but is output in conventional format.


 Description of           Pseudocode | Python          VB.NET             Java
 data

 Date value               DATE         Use the         Date (8 bytes) | Date is a class in Java. To make
                                       datetime                         use of it use:
                                       class                              import java.util.Date;


Table 14.03 The Date data types


in Python and Java, date is not available as a built-in data type. Date is provided as a class
(see Table 14.03).

VB.NET stores dates and times from 1.1.0001 (0 hours) to 31.12.9999 (23:59:59 hours) with a
resolution of 100 nanoseconds (this unit is called a ‘tick’). Floating-point (decimal) numbers
are stored in binary-coded decimal format (see Section 1.02).

There are many more data types. Programmers can also design and declare their own data
types (see Chapter 16 (Section 16.01) and Chapter 26 (Section 26.01).



  TASK 14.02

  1      Look at the identifier tables in Chapter 12 (Tables 12.02 and 12.04 to 12.12). Decide
         which data type from your language is appropriate for each variable listed.
  2      Write program code to implement the pseudocode from Worked Example 12.01
         in Chapter 12.




14.04 Boolean expressions
in Chapter 12 (Section 12.06), we covered logic statements. These were statements that
included a condition. Conditions are also known as Boolean expressions and evaluate to
either True or False. True and False are known as Boolean values.

Simple Boolean expressions involve comparison operators (see Table 14.04). Complex
Boolean expressions also involve Boolean operators (see Table 14.05).


 Operation                       Pseudocode       | Python          | VB.NET
 equal                           =                 ==                 =                  _

 not equal                       <>                l=                 <>                 l=

 greater than                    >                 >                  >                  >

 less than                       <                 <                  <                  <

 greater than or equal to        >=                >=                 >=                 >=

                  to
 less than or equal              <=                <=                 <=                 <=


Table 14.04 Comparison operators
Cambridge International AS & A Level Computer Science




 Operation                                         | Pseudocode | Python          VB.NET           | Java
 AND (logical conjunction)                          AND          and              And               &&

 OR(logical inclusion)                              OR           or               Or                | |

 NOT (logical negation)                             NOT          not              Not               l


Table 14.05 Boolean operators



14.05 Selection

IF... THEN statements
In pseudocode the IF... THEN construct is written as:

  IF    <Boolean        expression>

       THEN

           <statement(s)>

 ENDIF




Syntax definitions
                if <Boolean       expression>:                   Note that the THEN keyword is replaced by a
                     <statement
                            (s) >                                colon (:). Indentation is used to show which
                                                                 statements form part of the conditional
                                                                 statement.

VB.NET          If <Boolean       expression>
                                          Then                   Note the position of Then on the same line as
                    <statement
                           (s) >                                 the Boolean expression. The End If keywords
                End    If                                        should line up with the Lf keyword.
                if    (<Boolean       expressions)               Note that the Boolean expression is enclosed in
                    <statement>;                                 brackets.
                                                                 If more than one statement is required as part of
                                                                 the conditional statement, the statements must
                                                                 be enclosed in braces
                                                                                     { }.

Pseudocode example:

 IF    x    <   0

      THEN

           OUTPUT      "Negative"

 ENDIF




Code examples
Python                      if    x    <       0:
                                 print ("Negative")


VB.NET                      If x <             O    Then
                                 Console.WriteLine ("Negative")
                            End       If




                            if    (x       <       0)
                                 System.out.printin("Negative")
                                                              ;
                                                                 Part 2: Chapter 14: Programming and data representation




  TASK 14.03

  Write program code to implement the pseudocode from Worked Example 12.03 in
  Chapter 12.




IF... THEN...ELSE statements
In pseudocode, the IF...THEN...ELSE construct is written as:

  IF    <Boolean expression>

       THEN

           <statement(s)>

       ELSE

           <statement(s)>

 ENDIF



Syntax definitions
                    if    <Boolean expression>:           Indentation is used to show which statements
                         <statement
                                (s) >                     form part of the conditional statement;
                    else:                                 the else keyword must line up with the
                         <statement
                                (s) >                     corresponding if keyword.

88)                 If <Boolean expression> Then          The Else keyword is on its own on a separate
                         <statement
                                (s) >                      line. It is good programming practice to line
                    Else                                  it up with the corresponding If keyword and
                         <statement
                                (s) >                     indent the statements within the conditional
                    End    If                             statement.

                    if (<Boolean           expression>)    If more than one statement is required in the
                         <statement>;                     else part of the statement, the statements
                    else                                   must be enclosed in braces
                                                                                    { }.
                         <statement>;



Pseudocode example:

  IF   x    <   0

       THEN

           OUTPUT         "Negative"

       ELSE

           OUTPUT         "Positive"

 ENDIF



Code examples
                                if
                                 x < 0:
                                     print ("Negative")
                                else:
                                     print ("Positive")

VB.NET                          If x <          0 Then
                                     Console.WriteLine ("Negative")
                                Else
                                     Console.WriteLine ("Positive")
                                End    If

                                if    (x    <   0)
                                     System.out.printin("Negative");
                                else
                                     System.out.println("Positive");
Cambridge International AS & A Level Computer Science




Nested IF statements
In pseudocode, the nested IF statement is written as:

  IF    <Boolean expression>

       THEN

         <statement(s)>

       ELSE

         IF      <Boolean expression>

              THEN

                      <statement(s)>

                 ELSE

                      <statement(s)>

         ENDIF

  ENDIF




Syntax definitions
                       if <Boolean expression>:                 Note the keyword elif (an abbreviation
                         <statement (s)>                        of else if). This keyword must line up
                       elif      <Boolean expression>:          with the corresponding
                                                                                    if.
                            <statement (s)>                     There can be as many e1if parts to this
                       else:                                    construct as required.
                            <statement(s)>




 VB.NET                If <Boolean expression> Then             If ElseIf is used as one word, only one
                         <statement (s)>                        End If is required at the end of this
                       Elself                                   construct.
                            <statement (s)>                     There can be as many ElseTf parts as
                       Else                                     required.
                            <statement(s)>
                       End      If

                       if       (<Boolean expression>)
                            <statement>;

                       else      if    (<Boolean expression>)
                            <statements;

                       else
                            <statement>;




Pseudocode example:

  IF    x    <    0

       THEN

            OUTPUT          "Negative"

       ELSE

            IF    x    =    0

                 THEN

                      OUTPUT         "Zero"

                 ELSE

                      OUTPUT         "Positive"

            ENDIF

  ENDIF
                                                                              Part 2: Chapter 14: Programming and data representation




Code examples
                         if
                          x < 0:
                              print ("Negative")
                         elif       x       ==
                               print ("Zero")
                         else:
                               print ("Positive")

    VB.NET               If    x    <       0    Then
                               Console.WriteLine ("Negative")
                         ElseIf             x    =       0   Then
                               Console.WriteLine ("Zero")
                         Else
                               Console.WriteLine ("Positive")
                         End       If

                         if    (x       <       0)

                         {
                               System.out.println('Negative');

                         }
                         else       if          (x ==         0)
                         {
                               System.out.println('Zero');

                         }
                         else

                         {
                               System.out.printin('Positive');

                         }


     TASK 14.04

     Write program code to implement the pseudocode from Worked Example 12.02 in
     Chapter 12.




CASE statements
An alternative selection construct is the CASE statement. Each considered CASE condition
can be:

e     asingle value

e    single values separated by commas

e     arange.

in pseudocode, the CASE statement is written as:

    CASE OF     <expression>

       <valuel>                                      :       <statement(s)>

       <value2>,<value3>                             :       <statement(s)>

       <value4>    TO   <value5>                     :       <statement(s)>




       OTHERWISE      <statement(s)>

    ENDCASE


The value of <expression> determines which statements are executed. There can be as
many separate cases as required. The OTHERWISE clause is optional and useful for error
trapping.
Cambridge International AS & A Level Computer Science




Syntax definitions
                      Python does not have a CASE statement. You need to use nested If
                      statements instead.

                      Select Case <expression>
                          Case valuel
                             <statement(s)>
                          Case value2,value3
                             <statement(s)>
                          Case value4         To value5
                             <statement(s)>




                           Case    Else
                             <statement(s)>
                      End    Select

                      switch       (<expression>)
                      {
                           case valuel:
                             <statement(s)>;
                             break;
                           case value2:          case value3:
                             <statement(s)>;
                             break;




                           default:       <statement(s)>;



In pseudocode, an example CASE statement Is:
  CASE OF Grade

    nan        :   OUTPUT   "Top grade"

    vet   ong:     OUTPUT   "Fail"

    MBM   EY   ;   OUTPUT   "Pass"

  OTHERWISE OUTPUT        "Invalid grade"

  ENDCASE




Code examples
                     if    Grade    ==    "A";
                          print ("Top grade")
                     elif Grade ==            "F"    or Grade ==   "U":
                          print ("Fail")
                     elif    Grade       in   ("BY     nan   wp,   WEN);


                          print ("Pass")
                     else:
                          print ("Invalid grade")

 VB.NET              Select Case Grade
                          Case    "A"
                            Console.WriteLine("Top grade")
                          Case    "F","U"
                            Console.WriteLine ("Fail")
                          Case    "B"    To   "kK"
                            Console.WriteLine("Pass")
                          Case    Else
                            Console.WriteLine("Invalid grade")
                     End    Select
                                                                                             Part 2: Chapter 14: Programming and data representation




                                 switch                 (grade)

                                 {
                                      case              'A':

                                           System.out.println("Top                               Grade")
                                                                                                       ;
                                           break;
                                      case              'F';      case     'U':

                                           System.out.printin("Fail");
                                           break;
                                      case             'B':       case     'C':       case    'D':     case   'E!';

                                           System.out.printlin("Pass")
                                                                     ;
                                           break;
                                      default:
                                           System.out.printlin("Invalid grade")
                                                                              ;




   TASK 14.05

   The problem to be solved: the user enters the number of the month and year. The
   output is the number of days in that month. The program has to check if the year is a
   leap year for February.
   The pseudocode solution is:

   INPUT       MonthNumber

   INPUT       Year

   Days    <    0

   CASE    OF       MonthNumber

     CASE       1,3,5,7,8,10,12                    :       Days   <   31

     CASE       4,6,9,11         :    Days             < 30

     CASE       2    ;:   Days       <    28

          If    Year MOD             400       =       0

               THEN //       it       is       a       leap year

                    Days    <    29

          ENDIF

          IF    (Year MOD             4    =       0)       AND      (Year MOD        100    >   0)

               THEN //       it       is       a       leap year

                    Days    <    29

          ENDIF

     OTHERWISE             OUTPUT          "Invalid               month     number"
  ENDCASE

  OUTPUT        Days


  Write program code to implement the pseudocode above.




14.06 Iteration
Count-controlled (FOR) loops
In pseudocode, a count-controlled loop is written as:

  FOR    <control          variable>                   «    s   TO    e   STEP    i    //    STEP     is   optional

         <statement(s)>

  NEXT    <control          variable>

The control variable starts with value s, increments by value i each time round the loop and
finishes when the control variable reaches the value e.
        Cambridge International AS & A Level Computer Science




        Syntax definitions
                               for       <control               variable>                  in       The values s, e and i must be of type integer.
                               range(s,         e,          i):                                     The loop finishes when the control variable
                                         <statement(s)>                                             is just below e. The values for s and i can
                                                                                                    be omitted and they default to 0 and 1,
                                                                                                    respectively.

        VB.NET                 For <control variable> = s_ | Thevaluess,eand
                                                                    ican be of type integer
                               To    e     Step         i                                            orfloat.
                                         <statement(s)>
                               Next

                               for       (int       i       =   s;    i     <        e;    i++)    | Wherei isthe controlvariable.
                                         <statement>;



        In pseudcode, examples are:

        FOR    x   <       1   TO    5

               OUTPUT           x

        NEXT       x


        FOR    x       =   2   TO    14    STEP             3

               OUTPUT           x

        NEXT       x


        FOR    x       =   5   TO    1     STEP         -1

               OUTPUT           x

        NEXT       x




= Code examples
  256



                               for x       in range(5):                                                 The start value of x is 0 and it increases by 1
                                      print(x,                  end='           ')                      on each iteration. Output:0 1 2 3 4
                               for x       in       range(2,               14,            3):           Output:2    5   8   11
                                      print(x,                  end='       ')

                               for x in range(5,                           1,         -1):              The start value of x is 5 and it decreases by 1
                                      print(x,                  end='       ')                          on each iteration.

                                                                                                        Output:5    4   3   2

                               for x in             ["a",           "b",        "c"]:                   The control variable takes the value of each
                                      print(x,                  ends'')                                 of the group elements
                                                                                                                         in turn.
                                                                                                        Output: abe

        iA \imee For x = 1 To 5                                                                         Output:1 23 4            5
                                         Console.Write
                                                    (x)
                               Next

                               For    xX   =    2       To      14    Step            3                 Output:2    5   8   11       14
                                      Console.Write
                                                 (x)
                               Next

                               For    x    =    5       To      1    Step            -1                 Output:5    43      2    1
                                      Console.Write
                                                 (x)
                               Next

                               For    x    =    1       To      2.5       Step            0.5           Output
                                                                                                             :

                                      Console.WriteLine (x)                                             1
                               Next                                                                     1.5

                                                                                                        2

                                                                                                        2.5

                               For Each x In                        {"a",        Wp
                                                                                            ton}        The control variable takes the value of each
                                      Console.Write(x)                                                  of the group elements
                                                                                                                         in turn.
                               Next                                                                     Output: abe
                                                                                        Part 2: Chapter 14: Programming and data representation




             for      (int x =           1;   x    <       6;    x++)                Output: 12345


                      System.out.print (x);

             }
             for      (int   x   =       2;   x    <       15;       x    =   x      |QOutput2     5    8    11        14
             +   3)

             {
                      System.out.print(x                         +"           ");

             }
             for      (int   x   =       5;   x    >       0;    x--)                Output5       4    3    2     1


                      System.out.print(x                         +"           ");

             }
             for      (double x =             1;       x    <    3;       X =       | Qutput:1.0       1.5       2.0        2.5
             x   +    0.5)

             {
                      System.out.print(x                         +    "       ");

             }
             char[]      letter = {'a',                     'b',          'c'}; | The control variable takes the value of each
             for      (char x        :    letter            )                        of the group elements
                                                                                                       in turn.
             {                                                                       Output: abe
                     System.out.print(x);

             }



  TASK 14.06

  1   Write program code to implement the pseudocode from Worked Example 12.05
      in Chapter 12.

  2   Write program code to implement the pseudocode from Worked Example 12.08
      in Chapter 12.

  3   Write program code to implement the pseudocode from Worked Example 12.09
      in Chapter 12.




Post-condition loops
A post-condition loop, as the name suggests, executes the statements within the loop at
least once. When the condition is encountered, it is evaluated. As long as the condition
evaluates to False, the statements within the loop are executed again. When the condition
evaluates to True, execution will go to the next statement after the loop.

When coding a post-condition loop, you must ensure that there is a statement within the
loop that will at some point change the end condition to True. Otherwise the loop will
execute forever.

In pseudocode, the post-condition loop is written as:

 REPEAT

       <statement(s)>

 UNTIL    <condition>
Cambridge International AS & A Level Computer Science




Syntax definitions
Python                 Post-condition loops are not available in Python. Use a
                       pre-condition loop instead.

VB.NET                 Do
                                 <statement(s)>
                       Loop Until              <condition>

                       do

                       {
                                 <statement(s)>
                       }    while      <condition>;



Pseudocode example:

 REPEAT

       INPUT   "Enter       Y    or   N:   "   Answer

 UNTIL Answer      =   "y"




Code examples
VB.NET                 Do
                                Console.Write("Enter Y or N:          ")
                                Answer     =    Console.ReadLine()
                       Loop Until              Answer   =   "Y"

                       do

                       {
                                System.out.print("Enter Y or N:            ");
                                answer     =    console.next();
                       }    while          (!(answer.equals("Y")));




  TASK 14.07

  1   Write program code to implement the pseudocode from Worked Example 12.04
      in Chapter 12.

  2   Write program code to implement the first algorithm from Worked Example 12.06
      in Chapter 12.




Pre-condition loops
Pre-condition loops, as the name suggests, evaluate the condition before the statements
within the loop are executed. Pre-condition loops will execute the statements within the loop
as long as the condition evaluates to True. When the condition evaluates to False, execution
will go to the next statement after the loop. Note that any variable used in the condition must
not be undefined when the loop structure is first encountered.

When coding a pre-condition loop, you must ensure that there is a statement within the loop
that will at some point change the value of the controlling condition. Otherwise the loop will
execute forever,

In pseudocode the pre-condition loop is written as:
  WHILE   <condition>           DO

       <statement(s)>

  ENDWHILE
                                                                                               Part 2: Chapter 14: Programming and data representation




Syntax definitions
 dey           While <conditions:                                             Note that statements within the loop must be
                         <statement
                                 (s) >                                        indented by a set number of spaces. The first
                                                                              statement after the loop must be indented less.

VW \8      9) Do While <condition>                                            Note the keyword Loop indicates the end of the
                         <statement(s)>                                       loop

               Loop                                                           VB.NET also has a pre-condition Until loop.
               Do Until <condition>                                           This will execute the statements within the loop
                    <statement(s) >                                           as long as the condition evaluates to False. If the
               Loop                                                           condition evaluates to True when the loop is first
                                                                              encountered, the statements within the loop are
                                                                              not executed at all.
               while       (<condition>)

               {
                         <statement(s)>;

               }

Pseudocode example,
  Answer   <       ""

  WHILE   Answer         <>   "Y¥"        DO

       INPUT        "Enter        Y    or      N:   "     Answer

  ENDWHILE



Code examples
               Answer         =   !!

               while Answer                 !=      'Y':
                        Answer        =   input("Enter                    Y    or    N:        ")

               Dim Answer As                   String            =   ""
               Do       While     Answer            <>     "yY"
                        Console.Write("Enter                         Y    or N:           ")
                        Answer        =   Console.ReadLine()
               Loop

               Answer         =   ""

               Do Until           Answer            =     "yY"
                        Console.Write("Enter                         Y    or N:           ")
                        Answer        =   Console.ReadLine()
               Loop

               String         answer           =    "";
               while(answer.equals("Y")                              ==        false)


                        System.out.print("Enter Y or N:                                             ");
                        answer        =   console.next();




  TASK 14.08

  Write program code to implement the second algorithm from Worked Example
  12.06 in Chapter 12.




Which loop structure to use?
If you know how many times around the loop you need to go when the program execution
gets to the loop statements, use a count-controlled loop. If the termination of the loop
depends on some condition determined by what happens within the loop, then use a
conditional loop. A pre-condition loop has the added benefit that the loop may not be
entered at all, if the condition does not require it.
Cambridge International AS & A Level Computer Science




0   TIP

    Computer Scientists like efficient code. Choosing the most suitable types of selection statements
    and loop structures is an important step along the way to design efficient code.




14.07 Built-in functions
Programming environments provide many built-in functions. Some of them are always
available to use; some need to be imported from specialist module libraries.

Discussion Point:
Investigate your own programming environment and research other library routines.


String manipulation functions
Table 14.06 contains some useful functions for manipulating strings.


 Description                        | Pseudocode                                        VB.NET

 Access a single character           ThisString
                                             [P]                ThisString
                                                                        [P]             ThisString(P)           ThisString.

 using its position P in a string    Counts from 1              Counts from 0           Counts from 0           charAt (P)

 ThisString                                                                                                     Counts from 0

 Returns the character whose         CHR (i         INTEGER)    chr (i)                 Chr (i)                 (char) i;
 ASCII value is i                    RETURNS CHAR

 Returns the ASCII value of          ASC(ch)        RETURNS     ord (ch)                Asc(ch)                 (int)       ch;
 character ch                        INTEGER

 Returns the integer value           LENGTH(S : STRING) | len(S)                        len(S)                  S.length();
 representing the length of          RETURNS INTEGER
 string S

 Returns leftmost    Lcharacters    | LEFT(S : STRING,          S[0:L]                  Left(S,       L)        S.subString
 from S                              L   :    INTEGER)          See the next section,                           (0,    L)
                                     RETURNS        STRING      on slicing

 Returns rightmost L characters |RIGHT(S:           STRING,     S[-L:]                  Right(S,          L)    S.subString
 from S                              L   :    INTEGER)          See the next section,                           (S.length()
                                     RETURNS        STRING      on slicing                                      - L)

 Returns a string of length L        MID(S : STRING,            SIP   : P+ LU]          mid(S,       P,    L)   S.subString(P,       P
 starting at position P from S       P : INTEGER, L :           See the next section,                           + L)
                                     INTEGER)        RETURNS    on slicing
                                     STRING

 Returns the character value         LCASE(Ch : CHAR)           Ch. lower ()            LCase (Ch)              Character.
 representing
           the lower case            RETURNS CHAR                                                               toLowerCase
                                                                                                                        (ch)
 equivalent of Ch

 Returns the character value         UCASE(Ch : CHAR)           Ch.upper()              UCase (Ch)              Character.
 representing the upper case         RETURNS CHAR                                                               toUpperCase (ch)
 equivalent of Ch

 Returns a string formed by          TO _UPPER(S                S.upper ()              S.ToUpper               S.toUpperCase()
 converting all alphabetic           STRING)        RETURNS
 characters of S to upper case       STRING

 Returns a string formed by          TO _ LOWER(S               S. lower ()             S.ToLower               S.toLowerCase()
 converting all alphabetic           STRING)        RETURNS
 characters of S to lower case       STRING

 Concatenate (join) two strings | Sl         & S2               Ss = S1      + S2       s = S1       + S2       s = Sl       + $2;
                                                                                        s   =   Sl   &     S2



Table 14.06 Some useful string manipulation functions
                                                            Part 2: Chapter 14: Programming and data representation




Slicing in Python
In Python a subsequence of any sequence type (e.g. lists and strings) can be created using ‘slicing’.

For example, to get a substring of length L from position P in string S we write S[P: P + L].

Figure 13.05 shows a representation of ThisString. If we want to return a slice of length 3
starting at position 3, we use ThisString[3 : 6]        to give ‘DEF’. Position is counted from 0
and the position at the upper bound of the slice is not included in the substring.

                                    ThisString

[0]        [1]           [2]         [3]     [4]        [5]         [6]




Figure 14.05 A representation of ThisString

ifyou imagine the numbering of each element to start at the left-hand end (as shown in Figure
14,05), then it is easier to see how the left element (the lower bound) is included, but the right
element (the upper bound) is excluded. Table 14.07 shows some other useful slices in Python.


 Expression              | Result           | Explanation
 ThisString[2:]       | CDEFG                If you do not state the upper bound, the slice includes all
                                             characters to the end of the string.

 ThisString[:2]       | AB                   If you do not state the lower bound,
                                                                               the slice includes all
                                             characters from the beginning ofthe string.

 ThisString[-2:] | FG                        A negative lower bound means that it takes the slice starting
                                             from the end of the string.

 ThisString[:-2] | ABCDE                     A negative upper bound means that it terminates the string
                                             at that position.


Table 14.07 Some useful slices in Python


Truncating numbers
Instead of rounding, sometimes wejust want the whole number part of a real number.
This is known as ‘truncation’.

 Jy lifejenye(-) INT(X : REAL) RETURNS INTEGER | Returns
                                                   the integer partof x.
                 int (x)                                      If x is a floating-point number, the
                                                              conversion truncates towards zero.

                 Math. Truncate (x)                           The whole number part of the real number
                                                                                                     x

                                                              is returned.

                 (int)     x;                                 Casts the number
                                                                             as an integer.



Converting a string to a number
Sometimes a whole number may be held as a string. To use such a number in a calculation,
we first need to convert it to an integer. For example, these functions return the integer value
5 from the string "5":

                 int (S)

                 CInt (Ss)

                 Integer.valueOf
                              (S)
Cambridge International AS & A Level Computer Science




Sometimes a number with a decimal point may be held as a string. To use such a number ina
calculation, we first need to convert it to a real (float). For example, these functions return the
real number 75.43 from the string "75.43":

 Pseudocode                 STRING _TO_ NUM(x :                     Returns a numeric representation ofa
                            STRING)     RETURNS      REAL           string.

 Python                                                             The returned value is a floating-point
                            float (x)                               number.

VB.NET                                                              The returned value is of type double.
                            CDb1 (x)

 Java                                                               The returned value is a floating-point
                            Float .valueOf     (x)                  number.



Random number generator
Random numbers are often required for simulations. Most programming languages have
various random number generators available. As the random numbers are generated
through a program, they are referred to as ‘pseudo-random’ numbers. A selection of the
most useful random number generators are shown in the following code examples.


Code examples
 oie)       # in the random library:                                    This code produces a random
            randint (1,       6)                                        number between 1 and 6 inclusive.

            Dim RandomNumber As New Random                             You have to set up a RandomNumber
            Dim x As        Integer                                     object (see Chapter 27). This code
            x = RandomNumber.Next (1,                6)                 generates an integer between 1
                                                                        (inclusive) and 6 (exclusive).

            import java.util.Random;                                   You have to set up a RandomNumber
            Random        randomNumber     =   new Random();        | object (see Chapter 27). This code
            int   x   =    randomNumber.nextInt (6)          +    1; | generates an integer between 1

                                                                        (inclusive) and 6 (inclusive).




  TASK 14.09

   1    Write program code to generate 20 random numbers in the range 1 to 10 inclusive.
   2    Write program code to implement the pseudocode using a pre-condition loop
        trom Worked Example 12.07 in Chapter 12.



Discussion Point:
What other useful functions can you find? Which module libraries have you searched?



14.08 Procedures
In Chapter 12 (Section 12.09), we used procedures as a means of giving a group of statements
a name. When we want to program a procedure we need to define it before the main
program. We call it in the main program when we want the statements in the procedure body
to be executed.

In pseudocode, a procedure definition is written as:

PROCEDURE     <procedurelIdentifier>            //   this   is   the procedure header

       <statement(s)>         //   these   statements       are    the procedure body

ENDPROCEDURE
                                                                         Part 2: Chapter 14: Programming and data representation




This procedure is called using the pseudocode statement:

   CALL    <procedureldentifier>



Syntax definitions
 Python              def    <identifier>():
                            <statement(s)>


VB.NET               Sub <identifier>()
                            <statement(s)>
                     End    Sub

                     void       <identifier>()

                     {
                            <statement(s)>;

                     }

When programming a procedure, note where the definition is written and how the procedure
is called from the main program.

Here is an example pseudocode procedure definition:

  PROCEDURE       InputOddNumber
      REPEAT

             INPUT       "Enter    an       odd   number:      "    Number
      UNTIL       Number    MOD     2   =    1

         OUTPUT    "Valid number             entered"
  ENDPROCEDURE


This procedure is called using the CALL statement:

  CALL    InputOddNumber




Code examples
 Python                                                                  .
                  | & *ProcedureExample.py
                                - C:/Users/Sylvia/Google Dr...                           —     O        x
                  File   Edit     Format         Run   Options          Window   Help

                  deft   InputOddNumber
                                     ():                                                                    A
                         Number         =   0
                         while      Number         %   2   =       0:
                                 Number = int(input("Enter                       an odd number:     "))
                         print ("Valid number                      entered")


                  FREER                         main   program          Starts   here   ~“** RRR   REESE




                  InputOddNumber ()                                                                         S

                                                                                               Ln: 11   Col:
                                                                                                           0


              Figure 14.06 The Python editor with a procedure

              The Python editor colour-codes the different parts of a statement. This helps when you are typing your own code. The
              indentation shows which statements are part of the loop.
              The built-in function input returns a string, which must be converted to an integer before it can be used as a number.
Cambridge International AS & A Level Computer Science




VB.NET             ConsoleApp2                           ~| 5, Modulet                      ~ | @, Number                °
                         1          EiModule Module1                                                                     &
                         2                        Dim Number As Integer                                                  a
                         3
                         4          A             Sub InputOddNumber
                                                                  ()
                         5          &                    Do
                         6                                    Console.Write("Enter an odd number:            “)
                         7                                    Number = Console.ReadLine
                         8              |                Loop Until Number Mod 2 = 1
                         9                               Console.WriteLine("Valid number entered”)                      —
                     10                           End Sub
                     11             cS)           Sub Main()
                     12                                  InputOddNumber
                                                                     ()
                     13                                  Console.ReadLine()
                     14                 L         End Sub
                     15
                     16                     End Module                                                                   v

           100%              ~ 4)                                                                                   >


           Figure 14.07 The Visual Basic Express editor with a procedure

          The Visual Basic Express editor colour-codes different parts of the statement, so it is easy to see if syntax errors are
          made. The editor also auto-indents and capitalises keywords.
          Variables need to be declared before they are used. The editor will follow the capitalisation ofthe variable declaration
          when you type an identifier without following your original capitalisation.
          The editor is predictive: pop-up lists will show when you type the first part of a statement.
          When you execute the Main program, Console.ReadLine () keeps the run-time window open.



              1              package              exl;

              2}6)           import java.util.Scanner;
              3

              4              public           class Ex1i
              5              {
              6                  public             static void inputOddNumber
                                                                             ()
              7}    6               {
              8                               Scanner console = new Scanner (System.in);
             ’                                int number = 0;
            10                                do

            1l                                {
            12                                       System.out.print ("Enter                 an    odd number:    ");
            13                                       number = console.nextiInt();

            14                                }    while      (number    %   2   !=   1);
            15                                System. out.printin("Valid number                       entered");

            16;      *              }
            17

            18                          public       static void main(String[]                     args)


            20 1                                  inputOddNumber ();
            19                          {



            21                          }
            22               }


           Figure 14.08 The NetBeans editor with a void method

           The editor automatically colour codes keyword and strings.
           The procedure body is enclosed within braces {      and }.
           The editor is predictive: pop-up lists will show when you type the first part of a statement.
           Variables need to be declared before they are used.
                                                           Part 2: Chapter 14: Programming and data representation




  TASK 14.10

  Write program code to implement the pseudocode from Worked Example 12.11 in
  Chapter 12.




14.09 Functions
In Section 14.07 we used built-in functions. These are useful subroutines written by other
programmers and made available in module libraries. The most-used ones are usually in the
system library, so are available without you having to import them.

You can write your own functions. Any function you have written can be used in another
program if you build up your own module library.

A function is used as part of
                            an expression. When program execution gets to the statement
that includes a function call as part of the expression, the function is executed. The return
value from this function call is then used in the expression.

When writing your own function, ensure you always return a value as part of the statements
that make up the function (the function body). You can have more than one RETURN
statement if there are different paths through the function body.

In pseudocode, a function definition is written as:

 FUNCTION <functionIdentifier> RETURNS <dataType> //                     function header
        <statement(s)>     //   function body

        RETURN   <value>

 ENDFUNCTION



ft KEY TERM



Syntax definitions
                   def   <functionIdentifier>():
                         <statement(s)>
                         return    <value>

                   Function      <functionIdentifier>()       As    <dataType>
                         <statement(s)>
                         <functionIdentifier>         =   <value>   ‘Return <value>
                   End   Function
                   <data type>      <functionIdentifier>()
                   {
                         <Sstatement(s)>;
                         return    <value>;




When programming a function, the definition is written in the same place as a procedure. The
function is called from within an expression in the main program, or in a procedure.

Different programming languages use different terminology for their subroutines, as listed in
Table 14.08.

 Pseudocode                       | PROCEDURE                       | FUNCTION
 Python                            void function                    fruitful function
 VB                                Subroutine                        Function
 Java                              void method                       method

Table 14.08 Programming language terminology for subroutines
Cambridge International AS & A Level Computer Science




Void means ‘nothing’. Both Python and Java use this term to show that their procedure-type
subroutine does not return a value. Python refers to both types of subroutines as functions.
The fruitful function returns one or more values.

We can write the example procedure from Section 14.09 as a function. In pseudocode, this is:
  FUNCTION     InputOddNumber                            RETURNS           INTEGER

       REPEAT

             INPUT           "Enter            an        odd        number:        "     Number

       UNTIL      Number               MOD         2       1

       OUTPUT        "Valid number                         entered"

       RETURN Number

  ENDFUNCTION



Code examples

                                                                                                                                  =
                                                                                                                                  10)
                                                                                                                                    x!
             File        Edit      Format          Run         Options

             /def InputOddNumber():
                         Number                0
                     while               Number            %    2          0:
                                Number                   int (input ("Enter                      an   odd     number:            "))
                         return             Number


              ¥     KRRKEKEEX                  main            program          starts           here       RRR RRR RRR REE


             NewNumber                         InputOddNumber
                                                            ()



                                                                                                                                    : 10\Col:        0



            Figure 14.09 The Python editor with a function and local variable

            The variable Number in Figure 14.09 is not accessible in the main program. Python’s variables are local unless
            declared to be global.

 VB.NET
             (a)                                                                                           PUT=TE]    BEG) pposolcnontcations -ricrosoft Vis                                       lox
             File    Edit       View     Project       Debug    Data   Tools    Window    Help                        File   Edit       View    Project     Debug   Data   Tools   Window   Help

             PG ly ed et | & a al


                                                                    ~| (J (Declarations)                                                                              ~| J (Declarations)
                     =|Module Module
                                                                                                                             =|Module Modulel                                                       :
                                                                                                                                          Dim NewNumber As Integer
                                Dim Number,            NewNumber As Integer

                                                                                                                             =            Function InputOddNumber()
                     =          Function InputOddNumber()
                                                                                                                                                Dim Number As Integer
                                       Do
                                                                                                                                                Do
                                             Console.Write("Enter an odd number:                      ")                                                 Console.Write("Enter an odd number:
                                             Number = Console.ReadLine
                                                                                                                                                         Number = Console.ReadLine
                                         Loop Until Number Mod 2 = 1
                                                                                                                                                Loop Until Number Mod 2 = 1
                                       InputOddNumber = Number
                                                                                                                                                InputOddNumber = Number
                                End      Function
                                                                                                                                          End Function


                     =          Sub Main()                                                                                   =            Sub Main()
                                       NewNumber = InputOddNumber()                                                                             NewNumber = InputOddNumber()
                                         Console.ReadLine()                                                                                     Console.ReadLine()
                                End    Sub                                                                                                End Sub


                         End Module                                                                                              End Module                                                         |

               100%         ~ «|                                                                                       100%         ~ 4]

             Ready               Ln 20




            Figure 14.10 The VB.NET editor with (a) global variables and (b) a local variable

            The variable Number in Figure 14.10(a) is declared asa                                                   In Figure 14.10(b), the variable Number is declared as a
            global variable at the start of the module. This is not good                                             local variable within the function.
            programming practice.
                                                                                      Part 2: Chapter 14: Programming and data representation




             Sore History |[O B-H-\QUGEB
                                    re. elavle Gly                                                                #
                1         package         exl;                                                                Aun

                2)   6)   import java.util.Scanner;
                3
                4         public class Ex1

                5         {
                6             public        static   int    inputOddNumber
                                                                         (|)

                70            {
                8                     Scanner      console = new Scanner (System.in);
                L                     int number =         0;

               10                     do

               ll                     {
               12                            System. out.print ("Enter             an odd number:   ");

               13                            number = console.nextiInt();                                         |
               14                     }    while   (number      %   2   !=   1);

               15                     return number;                                                              7
               16)    +       }
               17
               18                 public     static void main(String[]               args)



               20 1                   int newNumber = inputOddNumber();
               19                 {


               21                 }
               22         }                                                                                   v
                          <                                                                               >




            Figure 14.11 The NetBeans editor with a function and local variable

            The variable number in Figure 14.11 is not accessible in the main program.


A global variable is available in any part of the program code. It is good programming
practice to declare a variable that is only used within a subroutine as a local variable.

In Python, every variable is local, unless it is overridden with a global declaration.
In VB.NET you need to write the declaration statement for a local variable within the
subroutine. Java does not support global variables. However, static variables declared in a
class are accessible throughout the class.



  TASK 14.11

  Write program code to implement the pseudocode from Worked Example 13.05 in
  Chapter 13. Which variables are global and which are local?




14.10 Passing parameters to subroutines
When a subroutine requires one or more values from the main program, we supply these
as arguments to the subroutine at call time. This is how we use built-in functions. We don’t
need to know the identifiers used within the function when we call a built-in function.

When we define a subroutine that requires values to be passed to the subroutine body, we
use a parameter list in the subroutine header. When the subroutine is called, we supply
the arguments in brackets. The arguments supplied are assigned to the corresponding
parameter ofthe subroutine (note the order of the parameters in the parameter list must be
the same as the order in the list of arguments). This is known as the subroutine interface.

   KEY TERMS
Cambridge International AS & A Level Computer Science




14.11 Passing parameters to functions
The function header is written in pseudocode as:

      FUNCTION       <functionIdentifier>                                (<parameterList>)                 RETURNS         <dataType>


where <parameterLists is a list of identifiers and their data types, separated by commas.

Here is an example pseudocode function definition that uses parameters:

  FUNCTION     SumRange(FirstValue                             :   INTEGER,         LastValue          :   INTEGER)         RETURNS   INTEGER

       DECLARE       Sum,       ThisValue                 :    INTEGER

       Sum <    0

       FOR   ThisValue              <    FirstValue                TO    LastValue

             Sum < Sum +                 ThisValue
      NEXT ThisValue

      RETURN        Sum

 ENDFUNCTION



Code examples

                           ProcedureExample.py - C:/Users/Sylvia/My Programming/
                                                                              CIE Book),                           -lO} x
                      File    Edit      Format      Run    Options      Windows   Help

                      def      SumRange(FirstValue,                       LastValue):                                       =

                              Sum =        0
                              for       ThisValue             in   range(FirstValue,          LastValue      +   1):
                                     Sum =         Sum + ThisValue
                              return           Sum


                      F      Re KKKKEKEK           main       program     Starts     here     ***   kkk KKK KKK

                      NewNumber                =   SumRange(i,           5)
                      print (NewNumber)

                                                                                                                            aes


                                                                                                                 \ln: 14    0

                     Figure 14.12 The SumRange() function in Python

VB.NET




                              ElModule Modulel
                                          Dim Number, NewNumber As Integer


                              cS}         Function SumRange(ByVal FirstValue, ByVal LastValue)
                                                   Dim Sum, ThisValue As Integer
                                                   Sum = @
                                                   For ThisValue = FirstValue To LastValue
                                                          Sum = Sum + ThisValue
                                                   Next
                                                   SumRange = Sum
                                          End Function


                              =]          Sub Main()
                                                   NewNumber = SumRange(1,               5)
                                                   Console.WriteLine(NewNumber)
                                                   Console.ReadLine()
                                          End Sub


                               _End Module

                          100%          ~ 4]



                     Figure 14.13 The SumRange() function in VB.NET
                                                                                          Part 2: Chapter 14: Programming and data representation




                          source | History |O @-H-\Q2HF BGreg elauie ola a
                           1         package          exl;

                           2

                           5!        public class Exi
                           4         {
                           5              public         static          int   sumRange(int   firstValue,   int   lastValue)

                           6}             {
                           7                      int    sum = 0;

                           8                      for    (int thisValue = firstValue;              thisValue <= lastValue;     thisValue++)

                           3                      {
                          10                            sum = sum + thisValue;

                          1l                      }
                          12                      return sum;
                          13)    *        }
                          14
                          15              public         static void main(String[]              args)

                          16              {
                          17                      int newNumber = sumRange(l, 5);
                          18                      System.out.printin (newNumber) ;
                          19              }
                          20         }




                      Figure 14.14 The SumRange()                                   function in Java




  TASK 14.12

  Write a function to implement the following pseudocode:
  FUNCTION      Factorial                 (Number                :   INTEGER)         RETURNS       INTEGER
        DECLARE       Product                 :       INTEGER

        Product       <     1

        FOR    n <    2     TO       Number

               Product           <       Product             *       n

        NEXT    n

        RETURN       Product

  ENDFUNCTION




14.12 Passing parameters to procedures
ifa parameter is passed by value, at call time the argument can be an actual value (as we
showed in Section 14.04). If the argument is a variable, then a copy of the current value of the
variable is passed into the subroutine. The value of the variable in the calling program is not
affected by what happens in the subroutine.

For procedures, a parameter can be passed by reference. At call time, the argument must be
a variable. A pointer to the memory location (the address) of that variable is passed into the
procedure. Any changes that are applied to the variable’s contents will be effective outside
the procedure in the calling program/module.


ft KEY TERMS




Note that neither of these methods of parameter passing applies to Python. In Python or
Java, the method is called pass by object reference. This is basically an object-oriented way
of passing parameters and is beyond the scopeof this chapter (objects are dealt with in
Chapter 27). The important point is to understand how to program in Python and Java to get
the desired effect.
Cambridge International AS & A Level Computer Science




The full procedure header is written in pseudocode, in a very similar fashion to that for
function headers, as:

       PROCEDURE                      <Procedureldentifier>                                        (<parameterList>)

The parameter list needs more information for a procedure definition. In pseudocode, a
parameter in the list is represented in one of the following formats:

     BYREF                <identifierl>                          :     <dataType>

     BYVALUE                   <identifier2>                            :     <dataType>



Passing parameters by value
The pseudocode for the pyramid example in Chapter 12 (Section 12.09) includes a procedure
definition that uses two parameters passed by value. We can now make that explicit:

     PROCEDURE                        OutputSymbols(BYVALUE                                     NumberOfSymbols                :    INTEGER,   Symbol   :   CHAR)

                   DECLARE                Count             :        INTEGER

                   FOR         Count          <«     1     TO         NumberOfSymbols

                               OUTPUT               Symbol                  //    without          moving          to   next       line

                   NEXT           Count

                   OUTPUT NewLine

     ENDPROCEDURE


In Python (see Figure 14.15), all parameters behave like local variables and their effect is as
though they are passed by value.

       ProcedureExample.py - C:/User                                                                             15)
                                                                                                                   x}
 File       Edit      Format      Run     Options        Windows        Help

 def         OutputSymbols (NumberOfSymbols,                                            Symbol):                        =

            for     Count         in     range (NumberOfSymbols):

                   print (Symbol,               end='')

            print
                ()


 F      KkKKEKEKEK             main       program           Starts            here        ** kkk KKK KKK KKK

 OutputSymbols(5,                          '*')
                                                                                                                        vr



                                                                                                               itn: 9   0

Figure 14.15 Parameters passed to a Python subroutine


In VB.NET (see Figure 14.16), parameters default to passing by value. The keyword Byval is
automatically inserted by the editor.

               eApplication1      -     Microsoft
                                                V                                                        =|0)
                                                                                                            x}
File    Edit       View   Project     Debug   Data       Tools       Window      Help

Pa Ga- daa) séaBlalS2|9-c-|>
                          ae


                                                           ~| (£3 Declarations)
        =|Module Modulel


        =          Sub OutputSymbols(ByVal NumberOfSymbols,                              ByVal Symbol)
                          Dim Count As Integer
                          For Count = 1 To NumberOfSymbols
                                 Console.Write(Symbol)
                          Next
                          Console.WriteLine()
                   End Sub


        =          Sub Main()
                          OutputSymbols(5,          "*")
                          Console.ReadLine()
                   End Sub


            End Module                                                                                     |

 100%          ~ 4]




Figure 14.16 Parameters passed by value to a VB.NET procedure
                                                                      Part 2: Chapter 14: Programming and data representation




sore| History |G M- S-\QGP
                        Q2a&elavl
                               H  e ale
                                      a
   1        package         exl;

   2
   3        public       class     Exi

   4        {
   5            public static void outputSymbols (int numberOfSymbols, char symbol)
   é|   4       {
   7                 for      (int   count       =   1;   count   <= numberOfSymbols;        count++)

   8                 {
   9                         System. out.print (symbol);

  10                 }
  ll                 System.out.printin();

  12;   *       }
  13

  14            public        static void main(String[]               args)



  16 i               outputSymbols(5, '*');
  15            {



  17            }
  18        }



Figure 14.17 Parameters passed by value to a Java procedure


In Java (see Figure 14.17), all parameters behave like local variables and their effect is as
though they are passed by value.



Passing parameters by reference
When parameters are passed by reference, when the values inside the subroutine change,
this affects the values of the variables in the calling program.

Consider the pseudocode procedure AdjustValuesForNextRow below.

The pseudocode for the pyramid example generated in Chapter 12 (Section 12.09) includes a
procedure definition that uses two parameters passed by reference. We can now make that
explicit:

  PROCEDURE AdjustValuesForNextRow(BYREF                           Spaces     :   INTEGER,   Symbols    :   INTEGER)

        Spaces      <    Spaces      -   1

        Symbols         <   Symbols      +   2

  ENDPROCEDURE


The pseudocode statement to call the procedure is:

  CALL AdjustValuesForNextRow(NumberOfSpaces,                            NumberOfSymbols)

The values of the parameters Spaces and Symbols are changed within the procedure when
this is called. The variables NumberOfSpaces and NumberOfSymbols in the program
code after the call will store the updated values that were passed back from the procedure.

Python does not have a facility to pass parameters by reference. Instead the subroutine
behaves as a function and returns multiple values (see Figure 14.18). Note the order of the
variables as they receive these values in the main part of the program.
               Cambridge International AS & A Level Computer Science




                       procedure3.py - C:/Users/Sylvia/My Programming/CE                            Bc

                File       Edit     Format   Run   Options           Windows   Help

                def AdjustValuesForNextRow
                                     (Spaces, Symbols):                                                                                             Z|
                           Spaces       =    Spaces      -   1
                           Symbols       =    Symbols        +       2
                           return       Spaces,         Symbols


                FX KK KKKKKEeMAIN              program               starts    here    RRR RRR RRR RRR RRR RRR RRR RR REE

                NumberOfSpaces                 =       int(input())
                NumberOfSymbols                    =    int (input ())
                NumberOfSpaces,                    NumberOfSymbols                = AdjustValuesForNextRow (NumberOfSpaces,   NumberOfSymbols)

                print (NumberOfSpaces)
                print (NumberOfSymbols)




                                                                                                                                           Ln: 6   : 62


               Figure 14.18 Multiple values returned from a Python subroutine


               This way oftreating a multiple of values as a unit is called a ‘tuple’ (see Chapter 11, Section
               11.02). You can find out more by reading the Python help files.

               In VB.NET (see Figure 14.19), the ByRef keyword is placed in front of each parameter
                                                                                                  to be
               passed by reference.



               File Edit          View Project Debug Data Tools Window Help

               PG a-da|*saBlalS2|9-e-|>                                                           ae
                Modulel.vb

                i Modulet                                                 ~| -@ Adjustval
                                                                                                                > +b!«




                       =|Module Modulel
                                  Dim NumberOfSpaces,        NumberOfSymbols As Integer


272                    =          Sub AdjustValuesForNextRow(ByRef Spaces,                  ByRef Symbols)
                                      Spaces = Spaces        -   1
                                      Symbols = Symbols + 2
                                  End Sub


                       =          Sub Main()
                                      NumberOfSpaces = Console.ReadLine()
                                      NumberOfSymbols = Console.ReadLine()
                                      AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols)
                                       Console.WriteLine(NumberOfSpaces)
                                      Console.WriteLine(NumberOfSymbols)
                                      Console.ReadLine()
                                  End Sub


                           End Module                                                                          ea

                100%         ~ 4|




           Figure 14.19 Parameters passed by reference to a VB.NET procedure


           Java does not have a facility to pass simple variable parameters by reference. Only objects
           can be passed by reference. Arrays are objects in Java, so these are passed by reference.


      Oo                                                —                              —                     —              —            —
       |               TIP

                       If only one value needs to be returned, the subroutine can be written as a function. If more than
           |           one value needs to be returned, a work-around is to declare a class and return it as an object
                       (Figure 14.20). If the values to be returned are of the same type, they can be grouped into an
                       array and the array is passed as a reference parameter.




                       TIP

                       A preferable solution is to amend the algorithm and write several functions (Figure 14.21).
                                                                                     Part 2: Chapter 14: Programming and data representation




|source| History |G R-M-\Q&PBaQPpr.giavie ola@a
  1             package exl;

  2}   6)       import java.util.Scanner;
  3

  4             public class Ex1
  5             {
  6                     static class RowData
  7                     {
  8                             public int   spaces = 0;

  3                             public int symbols = 0;
 10                     }
 11

  Q                     public static void adjustValuesForNextRow(RowData thisRow)
 13                     {
 14                             thisRow.spaces--;

 15                             thisRow. symbols = thisRow. symbols + 23
 16                     }
 17

 18                     public static void main(String[]          args)

 19| &                  {
 20                             Scanner console = new Scanner (System.in);
 21                             RowData thisRow = new RowData();

 22                             System.out.print ("Enter number of     spaces:     ");
 23                             thisRow.spaces = console.nextint();

 24                             System.out.print ("Enter number of     symbols:     ");

 25                             thisRow. symbols = console.nextint();
 26                             adjustValuesForNextRow (thisRow);
 27                             System. out.printin(thisRow.spaces);

 28                             System. out.printi1n (thisRow. symbols) ;
 29)    *               }
 30             }




Figure 14.20 Multiple values returned as an object from a Java subroutine


|source| History |G M- HM W\Q2aH BG Pe alae alga
   1                package exl;
   2|}6)            import java.util.Scanner;
   3

   4                public         class Exi

   5                {
   6                        public static int adjustSpacesForNextRow (int spaces)
   7                        {
   8                             spaces--;

   3                             return spaces;
 10                         }
 1l

 12                         public     static   int   adjustSymbolsForNextRow(int            symbols)

 us                         {
 14                              symbols = symbols + 2;
 15                              return symbols;
 16                         }
 17

 18                         public     static void main(String[]          args)

 19| O                      {
 20                              Scanner console = new Scanner (System.in);
 21                              System.out.print ("Enter number            of   spaces:    ");

 22                              int   spaces = console.nextiInt();
 23                              System.out.print ("Enter number            of   symbols:    ");

 24                              int   symbols = console.nextint();

 25                              spaces =                                   (spaces);

 26                              symbols = adjustSymbolsForNextRow (symbols);
 27                              System. out.printin (spaces);

 28                              System. out.printin (symbols);
 29)        *               }
 30                 }



Figure 14.21 The algorithm changed into two subroutines for Java
Cambridge International AS & A Level Computer Science




14.13 Putting it all together
The programs in this section are full solutions to the pyramid-drawing program developed in
Section 14.12.

The parameters of the subroutines have different identifiers from the variables in the main
program. This is done deliberately, so that itis quite clear that the parameters and local variables
within a subroutine are separate from those in the calling program or module. Ifa parameter is
passed by reference to a procedure, the parameter identifier within the procedure references the
same memory location as the variable identifier passed to the procedure as argument.

The pyramid-drawing program in Python, VB.NET and Java
                 SPACE       =    '    '   #       constant                          to give                a       space   a name
                 def    InputMaxNumberOfSymbols():
                       Number          =       0
                       while          Number                   %       2       ==
                             print("How many                                    symbols                make           the base?         ")
                             Number                =       int(input("Input an odd number:                                                   "))
                       return Number


                 def    SetValues():
                       Symbol          =       input("What                               symbol             do you want                to use?     ")
                       MaxSymbols                      =       InputMaxNumberOfSymbols()
                       Spaces          =       (MaxSymbols                               +   1)        //       2
                       Symbols             =       1
                       return          Symbol,                         MaxSymbols,                      Spaces,             Symbols


                 def    OutputChars(Number,                                              Symbol):
                       for       Count             in          range                (Number):
                             print(Symbol,                                 end='')


                 def AdjustValuesForNextRow(Spaces,                                                                  Symbols):
                       Spaces          =       Spaces                      -    1
                       Symbols             =       Symbols                      +    2
                       return          Spaces,                         Symbols


                 def main():
                       ThisSymbol,                         MaxNumberOfSymbols,                                        NumberOfSpaces,              NumberOfSymbols    =   SetValues()
                       while NumberOfSymbols                                                 <= MaxNumberOfSymbols:
                             OutputChars(NumberOfSpaces,                                                            SPACE)
                             OutputChars(NumberOfSymbols,                                                             ThisSymbol)
                             print()                   #       move                 to    new      line
                             NumberOfSpaces,                                        NumberOfSymbols                         = AdjustValuesForNextRow(NumberOfSpaces,
                 NumberOfSymbols)
                 main()

 VB.NET          Module          Modulel
                       Const          Space                =       "       "    ‘constant                   to give a         space a name
                       Dim NumberOfSpaces,                                           NumberOfSymbols                         As    Integer
                       Dim MaxNumberOfSymbols                                                 As       Integer
                       Dim ThisSymbol                                  As       Char


                 Sub InputMaxNumberOfSymbols(ByRef Number As                                                                            Integer)
                       Do

                             Console.WriteLine("How many symbols make                                                                        the base?   ")
                             Console.Write("Input                                            an odd number:                       ")
                             Number                =       Console.ReadLine()
                       Loop Until                      (Number Mod 2                               =    1)
                 End    Sub


                 Sub SetValues(ByRef Symbol,                                                      ByRef MaxSymbols,                      ByRef Spaces,        ByRef Symbols)
                                                                                    Part 2: Chapter 14: Programming and data representation




      Console.Write("What                              symbol                 do you want            to use?     ")
      Symbol       =       Console.ReadLine()
      InputMaxNumberOfSymbols(MaxSymbol1s)
      Spaces       =       (MaxSymbols                          +   1)    \    2
      Symbols          =    1
End       Sub

Sub       OutputChars(ByVal                            Number,                ByVal          Symbol)
      Dim Count As                   Integer
      For       Count       =    1       To       Number

            Console.Write (Symbol)
      Next

End       Sub


Sub AdjustValuesForNextRow(ByRef                                                       Spaces,    ByRef    Symbols)
      Spaces       =       Spaces             -    1
      Symbols          =    Symbols                +       2
End       Sub


Sub Main()
      SetValues(ThisSymbol,                                     MaxNumberOfSymbols,                     NumberOfSpaces,             NumberOfSymbols)
      Do

            OutputChars(NumberOfSpaces,                                                 Space)
            OutputChars(NumberOfSymbols,                                                 ThisSymbol)
            Console.WriteLine()'move                                          to       new    line
            AdjustValuesForNextRow(NumberOfSpaces,                                                      NumberOfSymbols)
      Loop Until                NumberOfSymbols                               > MaxNumberOfSymbols
      Console.ReadLine
                     ()
End       Sub


End       Module

package          ex1;
import          java.util.Scanner;


public          class      Exl

{
      static       final         char              SPACE             =    '    |;


      public       static            char getSymbol()

      {
            Scanner             console                =     new         Scanner(System.in);
            System.out.print("What                                       symbol          do you want          to use?   ");
            String         response                    =     console.next();
            return         response.charAt(0);

      }
      public       static            int           inputMaxNumberOfSymbols()

      {
            Scanner             console                =     new         Scanner(System.in);
            int    number                =    0;
           while           ((number                %    2)          ==   0)

            {
                  System.out.print("How many                                             symbols       make    the base?      ");
                  number             =       console.nextInt();

            }
            return         number;

      }
    public         static            void              outputChars(int                        number,     char    symbol)

      {
            for    (int         count              =       0;       count          <    number;      count++)

            {
                  System.out.print(symbol);

                                                                                                                                                       (Continued)
  Cambridge International AS & A Level Computer Science



(Continued)
   Java                       }
                      }
                      public         static       int       adjustSpacesForNextRow(int                      spaces)

                      {
                              spaces--;

                              return    spaces;

                      }
                      public         static       int       adjustSymbolsForNextRow(int                          symbols)

                      {
                              symbols     =       symbols        +       2;
                              return    symbols;

                      }
                      public         static void main(String[]                               args)

                      {
                              char    thisSymbol             =   getSymbol();
                              int    maxNumberOfSymbols                        =        inputMaxNumberOfSymbols();
                              int    numberOfSpaces                  =       (maxNumberOfSymbols             +    1)/    2;
                              int    numberOfSymbols                     =    1;


                              while    (numberOfSymbols                        <=       maxNumberOfSymbols)

                              {
                                    outputChars(numberOfSpaces,                                SPACE);
                                    outputChars(numberOfSymbols,                                  thisSymbol);
                                    System.out.println();
                                    numberOfSpaces               =       adjustSpacesForNextRow(numberOfSpaces);
                                    numberOfSymbols                  =       adjustSymbolsForNextRow(numberOfSymbols);




                 }

  Discussion Point:
  Can you see how the two procedures OutputSpaces and OutputSymbols have been replaced
  by a single procedure OutputChars without changing the effect of the program?


  14.14 Arrays
  Creating 1D arrays
  VB.NET, Python and Java number array elements from 0 (the lower bound).

  In pseudocode, a 1D array declaration is written as:

  DECLARE     <arrayldentifier>               :   ARRAY[<lowerBound>:<upperBounds]                               OF     <dataType>


  Syntax definitions
                In Python, there are no arrays. The equivalent data structure is called a list. A list is an
                ordered sequence of items that do not have to be of the same data type.
                Dim       <arrayldentifier>(<upperBound>)                                    As   <dataType>

                <datatype>[]           <arrayIdentifier>;
                <arrayldentifier>                  =    new      int[<upperbound>+1];


  Pseudocode example:

    DECLARE    Listl      :   ARRAY[1:3]               OF    STRING                //    3   elements    in this      list

    DECLARE    List2      :   ARRAY([0:5]              OF    INTEGER               //    6   elements    in this        list

    DECLARE    List3      :   ARRAY[1:100]             OF    INTEGER               //    100   elements   in this        list

    DECLARE    List4      :   ARRAY[0:25]          OF       STRING            //        26   elements    in this      list
                                                                                             Part 2: Chapter 14: Programming and data representation




Code examples
                 Listl            =    []                                                    As there are no declarations, the only way to
                 Listl.append ("Fred")                                                       generate a list is to initialise one.
                 List1l.append ("Jack")                                                      You can append elements to an existing list.
                 Listl.append ("Ali")

                 List2            =    [0,        0,      0,    0,    0,       O]            You can enclose the elements in [       ].
                 List3            =    [0       for       i    in    range(100)]             You can use a loop.
                AList             =    [""]          *    26                                 You can provide an initial value, multiplied by
                                                                                             number of elements required.

 VB.NET          Dim         List1l         As       String          ()    =                 You can initialise an array at declaration time
                 {uu         um       mn}
                                                                                             (as with List1). Note that List3 has 101
                Dim List2(5)                         As       Integer                        elements. You can use a range as an array
                Dim List3(100)                            As    Integer                      dimension (as with AList) however the
                Dim AList(0                      To       25)    As       String             lower bound must be 0.
                 String[]              listl             =     ee
                                                                                             You can initialise an array at declaration time
                 int[]            list2;                                                     (as with list1),
                 list2            =   new        int[5];
                 int[]         list3;
                 list3            =   new        int[100];
                 String[]              aList;
                aList             =   new        String[25];



Accessing 1D arrays
A specific element in an array is accessed using an index value. In pseudocode, this is written as:

  <arrayldentifier>|[x]


Pseudocode example:

  NList[25]         =    0    //       set        25th element                  to    zero
  AList[3]      =       "D"   //       set        3rd element                  to    letter D


Code examples
 Vie          | NList [24]                  = 0
                AList [3]              =        "pn"


 VB.NET         NList (25)                  =    0
                AList (3)              =        "pn


 Java           nList [25]                  =    0;
                aList [3]              =        "D";


In Python, you can print the whole contents of a list using print (List). In VB.NET and Java,
you need to use a loop to print one element ofan array at a time.




      TIP

      When writing a solution using pseudocode, always use a loop to print the contents of an array.




  TASK 14.13

  1     Write program code to implement the pseudocode from Worked Example 13.01
        in Chapter 13.
  2     Write program code to implement the pseudocode from Worked Example 13.02
        in Chapter 13.
  3     Write program code to implement the improved algorithm from Worked Example
        13.03 in Chapter 13.
Cambridge International AS & A Level Computer Science




Creating 2D arrays
In pseudocode, a 2D array declaration is written as:

  DECLARE    <identifier>                :       ARRAY[<1lBound1>:<uBoundi1>,
  <lBound2>:<uBound2>]                   OF       <dataType>



Syntax definitions
 Python                     In Python, there are no arrays. The equivalent data structure is a list of lists.
VB.NET                      Dim    <arrayldentifier>(<uBoundl,                                  uBound2>)   As   <dataType>

 Java                       <dataType>                 <arrayIdentifier>;
                            <arrayldentifier>                         =   new       <datatype>[<uBound1] [uBound2];



To declare a 2D array to represent a game board of six rows and seven columns, the
pseudocode statement is:

  DECLARE    Board      :       ARRAY[1:6,              1:7]     OF       INTEGER



Code examples
               Board =           [[0,        0,    0,       0,   0,       0,   OJ,        2D lists can be initialised
                                                                                                                in a similar
                                  [o,        0,    0,       0,   0,       0,   Ol,        way to 1D lists.Remember
                                                                                                                that
                                  [0,        0,    0,       0,   0,       0,   Ol,        elements
                                                                                             are numbered from 0.
                                  [0,        0,    0,       0,   0,       O,   O],        These are alternative
                                                                                                         ways of initialising
                                  [0,        0,    0,       0,   0,       0,   Ol,        a6 x7 list. The rows are numbered 0 to
                                  [(0,       0,    0,       0,   0,       0,   OJ]        5 and the columns
                                                                                                        0 to 6.
               Board =          [[0 for i in range(7)]                                    The upper value of the range is not
                 for j          in range(é)]                                              included.
               Board        =    [[0]        *    7]    *    6

 VB.NET        Dim Board(6,                  7) As Integer                                Elements
                                                                                                are numbered from 0 to the
                                                                                          given number. This declaration has
                                                                                          one row and one column too many.
                                                                                          However, the algorithm may be such
                                                                                          that it is easier
                                                                                                          to convert to program
                                                                                          code if row 0 and column 0 are ignored.
               int[][]          board =            {                                      2D arrays
                                                                                                 can beinitialised
                                                                                                             in a similar
                                  {0,        0,    0,       0,   0,       0,   O},     | wayto1D
                                                                                           arrays. Remember that
                                  {0,        0,    0,       0,   0,       0,   O},       elements
                                                                                            are numbered from 0.
                                  {0,        0,    0,       0,   0,       0,   O},
                                  {0,        0,    0,       0,   0,       0,   O},
                                  {0,        0,    0,       0,   0,       0,   O},
                                  {0,        0,    0,       0,   0,       0,   0}
                            }
               int[][]          board;
               board        =   new      int[6] [7];




Accessing 2D arrays
A specific element in a table is accessed using an index pair. ln pseudocode this is written as:

  <arrayldentifier>[x,                y]



Pseudocode example:

  Board[3,4]    <   0   //       sets        the       element            in   row    3   and    column 4   to   zero

The following code examples demonstrate how to access elements in each of the three
languages.
                                                                             Part 2: Chapter 14: Programming and data representation




Code examples
 Python        Board[2][3]      = 0                Elements are numbered from 0 in Python, so [3] gives
                                                   access to the fourth element.

 VB.NET        Board(3,    4)       =    0         We are ignoring
                                                              row 0 and column 0.

 Java          board[2] [3]         = 0;           Elements are numbered from 0 in Java, so [3] gives access
                                                   to the fourth element.




  TASK 14.14

  1     Write program code to implement the pseudocode from Worked Example 13.04
        in Chapter 13; first initialise the table and then output its contents.
  2     Write program code to implement the pseudocode from Worked Example 13.05
        in Chapter 13.




14.15 Text files
Writing to a text file
The following pseudocode statements provide facilities for writing to a file:

  OPENFILE     <filename>       FOR WRITE                           //   open    the    file    for writing

  WRITEFILE     <filename>,         <stringValue>                   //   write   a     line    of   text   to   the   file

  CLOSEFILE     <filename>                                          //   close   file

The following code examples demonstrate how to open, write to and close a file called
SampleFile.TxT in each ofthe three languages. If the file already exists, it is overwritten as
soon as the file handle is assigned by the ‘open file’ command.


Code examples
               FileHandle = open("SampleFile.TXT",                                   "w")           You specify the filename and mode (‘w’ for write) when
               FileHandle.write (LineOfText)                                                        you call the open function. The line oftext to be written
               FileHandle.close()                                                                   to the file must contain the newline character "\n" to

                                                                                                    move to the next line ofthe text file.

Vey \[3y8) Dim FileHandle As IO.StreamWriter                                                        The file is accessed through an object (see Chapter 27)
           Dim LineOfText As String                                                                 called a StreamWriter.
               FileHandle       =       New
               IO.StreamWriter ("SampleFile.TXT")
               FileHandle.WriteLine (LineOfText)
               FileHandle.Close()

               Alternative method:
               Dim   LineOfText              As   String
               Dim   Channel        As       Integer       =    1
               FileSystem.FileOpen(Channel,                               "SampleFile.TXT",            OpenMode.Output,          OpenAccess.Write)
               FileSystem.PrintLine(Channel,                              LineOfText)
               FileSystem. FileClose (Channel)

               import java.io.FileWriter;                                                           Input output operations throw exceptions. The easiest
               import java.io.PrintWriter;                                                          way to manage these is to change your main heading to:
               import java.io.1OException;                                                          public static void main(String[] args)
               FileWriter       fileHandle             =       new                                  throws      IOException
               FileWriter("SampleFile.TXT",                              false);
               PrintWriter printLine                   =       new
               PrintWriter (fileHandle) ;
               String    lineOfText;
               printLine.printf("ss"+"Sn",                               lineOfText)
                                                                                   ;
               printLine.close();
Cambridge International AS & A Level Computer Science




Reading from a text file
An existing file can be read by a program. The following pseudocode statements provide
facilities for reading from a file:

  OPENFILE     <filename>      FOR READ                             //   open    file    for    reading

  READFILE     <filename>,      <stringVariable>                    //   read a    line    of   text   from the        file

  CLOSEFILE     <filename>                                          //   close    file

The following code examples demonstrate how to open, read from and close a file called
SampleFile.TxT in each ofthe three languages.



Code examples
                FileHandle = open("SampleFile.TXT",                              "r")                      You specify the filename and mode (‘r for read)
                LineOfText      =     FileHandle.readline ()                                               when you call the open function.
                FileHandle.close
                               ()

                Dim LineOfText As              String                                                      The file is accessed through an object
                Dim FileHandle As              IO.StreamReader                                             (see Chapter
                                                                                                                     27) called a StreamReader.
                FileHandle      =     New     I0.StreamReader ("SampleFile.TXT")
                LineOfText      =     FileHandle.ReadLine
                                                        ()
                FileHandle.Close()

                Alternative method:
                Dim   LineOfText         As    String
                Dim   Channel       As   Integer       =    1
                FileSystem.FileOpen(Channel,                            "SampleFile.TXT",         OpenMode.Input,             OpenAccess.Read)
                FileSystem.Input (Channel,                      LineOfText)
                FileSystem. FileClose (Channel)

                import java.io.IOException;                                                                There are other library classes that can be
                import java.io.FileReader;                                                                 used for input/output, such as Scanner.
                import    java.io.BufferedReader;
                FileReader      fileHandle         =       new
                FileReader ("SampleFile.TXT")                       ;
                BufferedReader           textReader             =   new
                BufferedReader (fileHandle) ;
                String    lineOfText          =   textReader.readLine()
                                                                      ;
                textReader.close();




Appending to a text file
The following pseudocode statements provide facilities for appending to a file:

  OPENFILE     <filename>      FOR APPEND                   //      open    file   for    append

  WRITEFILE     <filename>,      <stringValue>              //      write   a    line    of    text   to    the   file

  CLOSEFILE     <filename>                                  //      close   file

The following code examples demonstrate how to open, append to and close a file called
SampleFile.TxT in each ofthe three languages.
                                                                        Part 2: Chapter 14: Programming and data representation




Code examples
 Python       FileHandle = open("SampleFile.TXT",                              "a")       You specify the filename and mode (‘a’ for append)
              FileHandle.write (LineOfText)                                               when you call the   open function.
              FileHandle.close()

:¥\}8     9) Dim FileHandle As IO.StreamWriter                                            The file is accessed througha StreamWriter.
              FileHandle      = New                                                       The extra parameter, True, tells the system to
              I0.StreamWriter ("SampleFile.TXT",                             True)        append
                                                                                            to the object.
              FileHandle.WriteLine (LineOftText)
              FileHandle.Close()

             Alternative method:
             Dim    LineOfText             As    String
             Dim    Channel       As       Integer       =    1
              FileSystem.FileOpen(Channel,                           "SampleFile.TXT",   OpenMode.Append,        OpenAccess.ReadWrite)
              FileSystem.Print (Channel,                          LineOfText)
              FileSystem. FileClose (Channel)

              import    java.io.FileWriter;                                               Input output throws exceptions. The easiest way is
              import    java.io.PrintWriter;                                              to change your main heading to:
              import    java.io.IOException;                                              public    static     void main(String[]
              FileWriter      fileHandle             =       new                          args)     throws     IOException
              FileWriter("SampleFile.TXT"),                           true);
              PrintWriter         printLine          =       new
              PrintWriter (fileHandle) ;
              String    lineOfText;
             printLine.printf("ss"+"Sn",                            lineOfText)
                                                                              ;
             printLine.close();




The end-of-file (EOF) marker
The following pseudocode statements read a text file and output its contents:

 OPENFILE       "Test.txt"    FOR      READ

 WHILE    NOT    EOF("Test.txt")            DO
       READFILE     "Test.txt",            TextString
       OUTPUT     TextString
  ENDWHILE

  CLOSEFILE      "Test.txt"


The following code examples demonstrate how to read and then output the contents of a file
in each of the three languages.



Code examples
              FileHandle      =    open("Test.txt",                   "r")                  There is no explicit EOF function. However, when
             LineOfText       =    FileHandle.readline
                                                     ()                                     a line of text has been read that only consists
             while     len(LineOfText)               >       0:                             of the end-of-file marker, the line of text is of
                   LineOfText          =    FileHandle.readline
                                                              ()                            length 0,
                   print (LineOfText)
              FileHandle.close()

VB.NET       Dim    LineOfText             As    String                                     When the end-of-file marker is detected, the
             Dim    FileHandle             As    System.10.StreamReader                     EndofStream method returns the value True
              FileHandle      =    New                                                      and so the loop will end.
              System.10.StreamReader
                             ("Test .txt")
             Do    Until   FileHandle.EndoOfStream
                   LineOfText          =    FileHandle.ReadLine
                                                              ()
                   Console.WriteLine (LineOfText)
             Loop

              FileHandle.Close
                             ()


                                                                                                                                      (Continued)
Cambridge International AS & A Level Computer Science




VB.NET       Alternative method:
             Dim          LineOfText                  As   String
             Dim          Channel            As       Integer          =    1
             FileSystem.FileOpen(Channel,                                            "Test.txt",
             OpenMode.Input,                           OpenAccess.Read)
             Do          While         Not       FileSystem.
                                                      EOF (Channel)
                         FileSystem.Input (Channel,                                  LineOfText)
                         Console.WriteLine (LineOfText )
             Loop

             FileSystem. FileClose (Channel)

             import java.1o.1OException;                                                                      There is no explicit EOF function. However, when
             import java.io.FileReader;                                                                       a line of text has been read that only consists
             import java.io.BufferedReader;                                                                   of the end-of-file marker, the line oftext is
             FileReader                     fileHandle             =       new      FileReader("Test.         effectively null.
             txt");
             BufferedReader                           textReader                =   new
             BufferedReader (fileHand1le) ;
             String                lineOfText              =    textReader.readLine()
                                                                                    ;
             while                (lineOfText              !=    null)

                 {
                         System.out.printin(lineOfText)
                                                      ;
                         lineOfText               =    textReader.readLine();

                 }
             textReader.close();




  TASK 14.15

  Fred surveys the students at his college to find out their favourite hobby. He wants to
  present the data as a tally chart.
  Fred plans to enter the data into the computer as he surveys the students. After data
  entry is complete, he wants to output the total for each hobby.

  1      Reading books                                     \\\


  2      Play computer games                               \\\\\\\


  3.     Sport                                             \\\\\


  4      Programming                                       \\


  5      Watching TV                                       A

  He starts by writing an algorithm:

  Initialise         Tally             array
  REPEAT

         INPUT       Choice            //    1    for Reading,                  2   for   computer games,

                                       //    3    for Sport,               4    for   Programming,   5   for TV

                                       //    0    to end         input

         Increment                Tally[Choice]

  UNTIL    Choice             =    0

  FOR    Index       =    1       TO   5

         OUTPUT          Tally[Index]

  NEXT    Index
       Write program code to declare and initialise the array Tally : ARRAY[1:5]          OF INTEGER.

       Write program code to implement the algorithm above.

       Write program code to declare an array to store the hobby titles and rewrite the FOR
       loop of your program in part 2 so that the hobby title is output before each tally.

       Write program code to save the array data in a text file.

  5    Write program code to read the data from the text file back into the initialised array.



Reflection Point:
How much practice have you had writing programs? Did you get them to work?
How difficult did you find the different constructs?
Put the following in order of difficulty:

   Usinga FOR loop

   Usinga WHILE loop

   Using an IF ELSE statement

   Declaring a variable of a standard data type

   Declaring and using a constant

   Usinga 1D array

   Using a nested loop to access each element in a 2D array

   Reading from and writing to a text file

   Using a built-in function

   Writing a procedure and calling it from the main program

   Writing a function and using its return value in an expression in the main program

   Using parameters with procedures and functions




  m=   Programming constructs in Python, VB.NET and Java include:
       e   declaration and assignment of constants and variables
       e   the basic constructs of assignment, selection, repetition, input and output
       e   built-in data types and functions.
       Code should be commented where it helps understanding.
       Boolean expressions are needed for conditions.
       Declaration of subroutines (functions and procedures) is done before the main program body.
       Calling a procedure is a program statement.
       Calling a function is done within an expression, for example an assignment.
       VB.NET and Java functions return exactly one value.
       Parameters can be passed to a subroutine. This is known as the interface.
       VB.NET passes parameters by value, as a default, but can return one or more values via parameters if
       they are declared as reference parameters.
  m=   In Python, parameters can only pass values into a subroutine. The only way to update a value of a
       variable in the calling program is to return one or more values from a function.
  m=   In Java, parameters can only pass values into a subroutine. The only way to update a value of a variable
       in the calling program is to return one value from a function. Note that object parameters are always
       passed by reference.
  m    When asubroutine is defined, parameters are the ‘placeholders’ for values passed into a subroutine.
  =    Arguments are the values passed to the subroutine when it is called.
“f
3
                                                                                        |
Ee PRES EE oe A     ARS Sg RG RSS EEE Eat


Z    Preeti wantsa program to outputa conversion table forounces
                                                               to grams
     (1 ounce is 28.35grarns). She writes an algorithm using Structured English:

     OUTPUT    "Ounces      Grams"

     FOR   Ounces    FROM    1   TO    39

           SET Grams     TO Rounded(Qunces           *   28.35)   //   whole   number   of   grams   only

           OUTPUT    Ounces      and    Grams


     Write pseudocode to implement
                                the algorithm. Include formatting, so that the output is
     tabulated.                                                                                               |

2    Write pseucocode to accept an input string Userip. The pseucococe is to test the UserID
     format. A valid format UserID consists of three upper case letters and four digits. The program
     5 to output a message whether UserID           is valid or not.                                          5I

3    Write pseudocode fora procedureOutputTimesTable that takes one integer par ameter nL,
     and outputs
            the times table torn. For example the procedurecallOurputTimesTable(5)
     should DrOGUCE:

     Lx5=5

     2*%5=10
     3x*5=15
     AX5=720
     5x5 =75




     8x5 =AQ
     ?x5=45


& Write sseucococe'forafunction isDivisible(} that takes two integerparameters, x and vy.
     The function ts to returnthe valueTrue orFalseto indicate whether
                                                                     x is exactly divisible by y.
     For example, isDivisible(24,           6)   should returnTrue and isDivisible(24,          7)   should


S    Apoultry farm packs eggs into egg boxes. Each boxtakes six eggs. Boxes mustnot contain
     fewerthan six eggs.

     Write pseudocodefora procedure         EggsI ntoBoxes [nat takes an integer parameter,
     NumberOffggs. The procedu reisto caiculate howmany egg boxes
                                                              can be Hlled withthe
     given number of eges and how many eggs will be left over. The procedure is to return two
     values25 parameters, NumberOfBoxes and Eggsheftover.                                                     1G]

6    Inacertain country, car registrations consist7 alphanumerical characters. The format of a
     car registration is either

                        LENNELE

                        or




     Lise pseudocode £0 writea function that takes
                                                 a string
                                                        as parameter and returns TRUE ifthe
     formatis valid and FALSE otherwise

     The string-handling functions available are those listed in Table 14.06.                                 |
Software development

Learning objectives
By the end of this chapter you should be able to:

   show understanding of the purpose of a development life cycle        locate and identify the different types of errors (syntax errors,
   show understanding ofthe need of different development life          logic errors and run-time errors)
   cycles depending on the program being developed                      correct identified errors
   describe the principles, benefits and drawbacks of each type of      show understanding of available testing methods (dry-run,
   life cycle: waterfall, iterative and rapid application development   walkthrough, white-box, black-box, integration, alpha, beta,
   show understanding of the analysis, design, coding, testing          acceptance, stub)
   and maintenance stages in the program development cycle              select appropriate data for a given testing method
   use a structure chart to decompose a problem into sub-tasks          show understanding of the need for a test strategy and test
   use a structure chart to express the parameters passed               plan and their likely contents
   between the various modules/procedures/functions which are           choose appropriate test data for a test plan (normal,
   part of the algorithm design                                         abnormal, extreme/boundary)
   describe the purpose of a structure chart                            show understanding of the need for continuing maintenance
   construct a structure chart for a given problem                      of a system and the differences between each type of
   derive equivalent pseudocode from a structure chart                  maintenance (corrective, adaptive, perfective)
   show understanding of the purpose of state-transition                analyse an existing program and make amendments to
   diagrams to document an algorithm                                    enhance functionality.
   show understanding of ways of exposing and avoiding faults
   in programs
 Cambridge International AS & A Level Computer Science




 15.01 Stages in the program development life cycle
 Developing a program involves different stages. You solved a problem by designing
                                                                                the
 solution using Structured English, a flowchart and / or pseudocode (see Chapters 12 and 13).
 You then wrote the program code and tested it (see Chapter 14).

 When large software systems are required to solve big problems, these stages are more
 formal, especially when more people are involved in the development. Before a solution can
 be designed, the problem needs to be analysed. When the program works and is being used,
 issues might arise that require changes. This is known as maintenance.


 Analysis
 The first step in solving a problem is to investigate the issues and the current system if there
 is one. The problem needs to be defined clearly and precisely. A ‘requirements specification’
 is drawn up.

 The next step is planning a solution. Sometimes there is more than one solution. You need to
 decide which is the most appropriate.

 The third step is to decide how to solve the problem:

 e   bottom-up: start with a small sub-problem and then build on this

 e   top-down: stepwise refinement using pseudocode, flowcharts or structure charts.


 Design
 You have a solution in mind. How do you design the solution in detail? Chapter 12 (Section
 12.04) showed that an identifier table is a good starting point. This leads you to thinking
 about data structures: do you need a 1D array or a 2D array to store data while it is
 processed? Do you need a file to store data long-term?

 Plan your algorithm by drawing a flowchart or writing pseudocode.


 Coding
 When you have designed your solution, you might need to choose a suitable high-level
 programming language. If you know more than one programming language, you have to
 weigh up the pros and cons of each one. Looking at Chapter 14, you need to decide which
 programming language would best suit the problem you are trying to solve and which
 language you are most familiar with.



Oo   TIP

     This stage is often referred to as implementation.




 You implement your algorithm by converting your pseudocode into program code. When you
 start writing programs you might find it takes several attempts before the program compiles.
 When it finally does, you can execute it. It might ‘crash’, meaning that it stops working. In this
 case, you need to debug the code. The program might run and give you some output. This is
 the Eureka moment: ‘It works!!!”. But does the program do what it was meant
                                                                           to do?


 Testing
 Only thorough testing can ensure the program really works under all circumstances (See
 Sections 15.06 and 15.07).
                                                                             Part 2: Chapter 15: Software development




There are several different development methodologies. These include the waterfall, the
iterative and the rapid application development model.

Discussion Point:
Do you think that all programs can be totally error-free?


The program development life cycle
The program development life cycle follows the defined stages of analysis, design, coding
(implementation), testing and maintenance. When maintenance no longer results in a program
fit for purpose, the development starts again, therefore creating a cycle (see Figure 15.01).

                      Analysis




    Maintenance




            Testing




Figure 15.01 The program development life cycle


The waterfall model
Figure 15.02 shows the waterfall model.




         ae

Figure 15.02 The waterfall model


The arrows going down represent the fact that the results from one stage are input into the
next stage. The arrows leading back up to an earlier stage reflect the fact that often more
work is required at an earlier stage to complete the current stage.

Benefits include the following.

e    Simple to understand as the stages are clearly defined.

e     Easy to manage due to the fixed stages in the model. Each stage has specific outcomes.

e    Stages are processed and completed one at a time.

e    Works well for smaller projects where requirements are very well understood.
                                                                                                      nm
Drawbacks include the following.

«      No working software is produced until late during the life cycie.
«      Notagood model for complex and object-oriented projects.



e      Cannot accommodate changing requirements.

e      tis difficult to measure progress within stages,

®      Integration is cone at the very end, which deesn’t allow icentitying potential technical or
                                    rea




       business issues ear
                                     2




                   at
The Harathys pcs
          x



3 SNe PEATE GRRE WR         PE SASAR
                                   IS


An iterative life cycle model does not atternpt to start with a full specification of
requirements. Instead, development starts with the implementation of a srnall subset of
the program requirements. Repeated (iterative) reviews to identify further requirements
eventually result in the complete system.

Benefits include the following.




       reans corrective measures can be taken more quickly,

       Some working functionality can be developed quickly and early in the tife cycie,
2




e      Results are obtained early and periocically,

       Parailei development can be plannec.
2




       Progress can be measured.

»      Less costly to change the scope/requirements.

»      Testing and debugging of a smaller subset of program is easy.

»      Risks are identified and resolved during iteration.

»      Easier to manage risk — high-risk part is done first.

»      With every increment, operational product is delivered.

«      |ssues, challenges and risks identified frorn each increment can be utilisec/apptied to the
       next increment.

e      Better suited forlarge anc mission-critical projects.

»      During the life cycie, software is produced early, which facilitates customer evaluation and
       feedback.

Drawbacks include the following,              ra)




       Only large softwere development projects can benefit because it is hard to break a small
s




       software system into further small serviceable modules.

e      More resources may be required.

®       Design issues might arise because not ail requirements are gathered at the beginning of
       the entire life cycle.

«       Defining increments may require definition of the complete system.

are       —        8    8       s     x   <         a        .      Poy   a ras     ss
    Pees aS
         es Peasant
            bY3  RSS    A aaadaa ote eae PNexr
                        SAR SS SSS ~  RHP STSS      sort SRE Cee FES TES. sees oy ot ond
                                               Stl SS See    S    PRM TSS
    PES PL     =
                        ASRS3
                                     LOW  SY          LEU
                                                        3
                                                          SA LS POPES

RAD is a software development methodalogy
                                       oy
                                          that uses minimal                                planning.-) instead it uses
prototyping. A prototype is a working model of part of the solution.
                                                                           Part 2: Chapter 15: Software development




In the RAD model, the modules are developed in parallel as prototypes and are integrated
to make the complete product for faster product delivery. There is no detailed preplanning.
Changes are made during the development process.

The analysis, design, code and test phases are incorporated into a series ofshort, iterative
development cycles.

Benefits include the following.

e   Changing requirements can be accommodated.

e   Progress can be measured.

e   Productivity increases with fewer people in a short time.

e   Reduces development time.

e   Increases reusability of components.

e   Quick initial reviews occur.

e   Encourages customer feedback.

e   Integration from very beginning solves a lot of integration issues.

Drawbacks include the following.

e   Only systems that can be modularised can be built using RAD.

e   Requires highly skilled developers/designers.

e   Suitable for systems that are component based and scalable.

e   Requires user involvement throughout the life cycle.

e   Suitable for projects requiring shorter development times.


15.02 Program design using structure charts
An alternative approach to modular design is to choose the sub-tasks and then construct a
structure chart to show the interrelations between the modules. Each box ofthe structure
chart represents a module. Each level is a refinement ofthe level above.

A structure chart also shows the interface between modules, the variables. These variables
are referred to as ‘parameters’ (see Section 14.10). A parameter supplying a value to a lower-
level module is shown as a downwards pointing arrow. A parameter supplying a new value to
the module at the next higher level is shown as an upward pointing arrow.


f KEY TERMS




Figure 15.03 shows a structure chart for a module that calculates the average of two
numbers. The top-level box is the name of the module, which is refined into the three
sub-tasks of Level 1. The input numbers (parameters Numberl and Number2) are passed into
the ‘Calculate Average’ sub-task and then the Average parameter is passed into the ‘OUTPUT
Average’ sub-task. The arrows show how the parameters are passed between the modules.
This parameter passing is known as the ‘interface’.
Cambridge International AS & A Level Computer Science




                                              Averages                                        Level 0
                                                                                              —




                                  ZTAOQUINN

                                               Tiaquinn
                     \
                                                          Average
                              e
                              g
                       %


   INPUT                                      Calculate                           OUTPUT      Level 1
 numbers                                      average                              average


Figure 15.03 Structure chart for a module that calculates the average of two numbers


  TASK 15.01

  Draw a structure chart for the following module: Input a number of km, output the
  equivalent number of miles.


Structure charts can also show control information: selection and repetition.
The simple number-guessing game that was introduced in Chapter 12 (Section 12.06) could
be modularised and presented as a structure chart, as shown in Figure 15.04.


                       Number Guessing Game




     Generate
  SecretNumber                INPUT Guess                              OUTPUT message
                                                                         t




                                                            OUTPUT ;                     snsolatic
                                                                                        consolation
                                                     congratulation                      message



 Figure 15.04 Structure chart for number-guessing game with only one guess allowed
The diamond shape shows a condition that is either True or False. So either one branch or
the other will be followed.

 Figure 15.05 shows the structure chart for the pyramid-drawing program from Worked
 Example 12.10. The semi-circular arrow represents repetition of the modules below the
arrow. The label shows the condition when repetition occurs.
                                                                            Part 2: Chapter 15: Software development




                                           Pyramid

                                                           UNTIL NumberOfSymbols =
                                                             MaxNumberOfSymbols




    Initialise values      Output spaces        Output symbols        Adjust values
                                                                               row
                                                                                    for
                                                                          next


            A


       8
        E
       g
       2
       8
        =
       2
        6
       =


            fe)




    Input Max number
       of symbols




Figure 15.05 Structure chart for pyramid-drawing program



     TASK 15.02

     Amend the structure chart for the number-guessing game (Figure 15.04) to include
     repeated guesses until the player guesses the secret number. The output should
     include the number of guesses made.




     TASK 15.03

     Draw a structure chart for the following problem: A user attempts to log on with a
     user ID. User IDs and passwords are stored in two 1D arrays (lists). The algorithm
     searches the list of user IDs and looks up the password in the password list. The
     user is given three chances to input the correct password. If the correct password
     is entered, a suitable message is output. If the third attempt is incorrect, a warning
     message Is output.



Structure charts help programmers to visualise how modules are interrelated and how
they interface with each other. When looking at a larger problem this becomes even more
important. Figure 15.06 shows a structure chart for the Connect 4 program (Task 13.06). It
uses the following symbols:

e    Anarrow with a solid round end e———» shows that the value transferred is a flag (a
      Boolean value)

e    Adouble-headed arrow «          ro      > shows that the variable value is updated within
     the module.
      Cambridge International AS &A Level Computer Science


                                                         Connect 4

                                                                                    WHILE game not finished




                                                                                             Check game                         Swap
         Initialise                                                                             finished                        player
          board




                                                                                             Winner found
                                                                                    x———~o
                                                                                 Board
                                                     Find free                Check if player                  Check for full
                             Player chooses                                                                       board
                                                       row
                                                                                 has won
                                  Column



                              o
                            oye            =
                            =     12       |||5>
                            a|jz
                                  3
                                  @
                                  om


292
                                Check column                     Check horizontal                              Check vertical
                                                                                                                     line
                                                                       line
                                number valid



        Figure 15.06 Structure chart for the Connect 4 game

        15.03 Deriving pseudocode froma structure  chart
                                               ple 12.10, a modular
                                                               ). In Worked Exam
        Let’s look at the pyramid problem again (Figure 15.05
                                                                and all variables were global. Now we
        solution was created without using a structure Cc hart                    local variables and
        are going to use local variables and parameters. T he reason for using to variables do not have
                                                                    any changes
        parameters is that modules are then self-containe d and
        accidental effects on a variable value elsewhere.
        The top-level module, Pyramid, calls fo ur modules. When
                                                                    a module is called, we supply the
        parameters in parentheses after the mo dule identi
                                                           fier. This gives the following pseudocode:
                                                                                                              umberOfSymbols)
                  CALL SetValues(NumberOfSymbols, NumberOfSpaces, Symbol, MaxN
          MODULE Pyramid


                  REPEAT

                      CALL OutputSpaces (NumberOfSpaces)
                      CALL OutputSymbols(NumberOfsymbols, Symbol)                                             ols)
                      CALL Adjust ValuesForNext Row (NumberOfspaces, NumberOfSymb
                                                                      ls
                  UNTIL NumberOfSymbols > MaxNumberOfSymbo

                                                                                                            MaxNumberOfSymbols)
           ENDMODULE


           PROCEDURE SetValues(NumberOfSymbols, NumberOfSpaces, Symbol,
                  INPUT Symbol
                                                                                                         Part 2: Chapter 15: Software development




       CALL    InputMaxNumberOfSymbols

       NumberOfSpaces <                      (MaxNumberOfSymbols                    -   1)   /   2

       NumberOfSymbols                   <    1

  ENDPROCEDURE


  PROCEDURE     InputMaxNumberOfSymbols(MaxNumberOfSymbols)

       REPEAT

              INPUT    MaxNumberOfSymbols

       UNTIL    MaxNumberOfSymbols                       MOD   2   =   1

  ENDPROCEDURE


  PROCEDURE OutputSpaces(NumberOfSpaces)

       FOR    Count    <       1    TO    NumberOfSpaces

              OUTPUT Space                   // without moving to next                       line

       NEXT    Count

  ENDPROCEDURE


  PROCEDURE OutputSymbols(NumberOfSymbols,                                       Symbol)

       FOR    Count+       1       TO NumberOfSymbols

              OUTPUT Symbol                   // without moving to next                          line

       NEXT    Count

       OUTPUT Newline                //      move   to   the next              line

  ENDPROCEDURE


  PROCEDURE AdjustValuesForNextRow(NumberOfSpaces,                                               NumberOfSymbol1s)

       NumberOfSpaces               < NumberOfSpaces               -       1

       NumberOfSymbols                   < NumberOfSymbols                 +    2

  ENDPROCEDURE


Note that a structure chart does not give details about how parameters are passed: by
reference or by value.




  TASK 15.04

  1   Write pseudocode to implement the structure chart from Figure 12.03 (for the
      average of two numbers).
  2   Write pseudocode to implement the structure chart from Figure 12.04 (for the
      number-guessing game).
  3   Amend the pseudocode from Worked Example 13.05 to implement the interface
      shown in the structure chart from Figure 15.06.



Discussion Point:
The full rules of Connect 4 are that a diagonal of four tokens also is a winning line. Where
in Figure 15.06 should the module to check for a diagonal be added? What parameters are
required for this module? Does this additional module require further stepwise refinement?



15.04 Program design using state-transition diagrams
A computer system can be seen as a finite state machine (FSM). An FSM has a start state. An
input to the FSM produces a transformation from one state to another state.

The information about the states of an FSM can be presented in a state-transition table.
Cambridge International AS & A Level Computer Science




    KEY TERMS


                               '

                                   );   a machine that
                                           ~   I   a   ere

                                                             consists
                                                                eo

                                                                  of a fixed set
                                                                     fC.   fy




Table 15.01 shows an example FSM represented as a state-transition table.

¢   |fthe FSM is in state S1, an input ofa causes no changeof state.

e   Ifthe FSM is in state S1, an input of b transforms S1 to S2.

e   If the FSM isin state S2, an input of b causes no changeof state.

e   ifthe FSM is in state S2, an input ofa transforms S2 to S1.

A state-transition diagram can be used to describe the behaviour of
                                                                  an FSM. Figure 15.07
shows the start state as Sl (denoted by e———-»). If the FSM has a final state (also known as
the halting state), this is shown by a double-circled state (S1 in the example).

                                         current state




Figure 15.07 State-transition diagram

If an input causes an output this is shown by a vertical bar (as in Figure 15.08 ). For example, if
the current state is S1, an input of b produces output c and transforms the FSM to state S2.

                         blc


     ale                                           b|f




                         a|d

Figure 15.08 State-transition diagram with outputs


A Finite State Machine with outputs is also known as a Mealy Machine.
                                                                                       Part 2: Chapter 15: Software development




WORKED EXAMPLE 15.01


Creating a state-transition diagram for an intruder detection system

A program is required that simulates the behaviour ofan intruder detection system.

Description of the system: The system has a battery power supply. The system is activated when the start
button is pressed. Pressing the start button when the system is active has no effect. To de-activate the system,
the operator must enter a PIN. The system goes into alert mode when a sensor is activated. The system will stay
in alert mode for two minutes. If the system has not been de-activated within two minutes an alarm bell will ring.

We can complete a state-transition table (Table 15.02 ) using the information from the system description.


 Current state                              | Event                                     | Next state
 System inactive                             Press start button                             System active

 System active                               Enter PIN                                      System inactive

 System active                               Activate sensor                                Alert mode

 System active                               Press start button                             System active

 Alert mode                                  Enter PIN                                      System inactive

 Alert mode                                  2 minutes pass                                 Alarm bell ringing

 Alert mode                                  Press start button                             Alert mode

 Alarm bell ringing                          Enter PIN                                      System inactive

 Alarm bell ringing                          Press start button                             Alarm bell ringing

Table 15.02 State-transition table for intruder detection simulation

The start state is ‘System inactive’. We can draw a state-transition diagram (Figure 15.09 ) from the
information in Table 15.02.

                                         Press button
                   Start

                                                                   Press button




                  System inactive                       System active




                                                          Sensor activated
           Enter PIN

                                       Enter PIN




                 Alarm bell rings                         Alert mode         Press button
Press button



                                    2 minutes pass



Figure 15.09 State-transition diagram for intruder detection system
Cambridge International AS & A Level Computer Science




    WORKED EXAMPLE 15.02


    Creating a state-transition diagram for a two’s complement FSM

    A finite state machine has been designed that will take as input a positive binary integer, one bit at a time,
    starting with the least significant bit. The FSM converts the binary integer into the two’s complement
    negative equivalent. The method to be used is as follows.

    1       Output the bits input up to and including the first 1.

    2       Output the other bits following this scheme:

    2.1     Foreach 1, output
                            a 0.

    2.2     Foreach 0, outputa 1.

    This information is represented in the state-transition table shown in Table 15.03.

     Current state                              Sl                   Sl             S2                 S2
     Input bit                                   0                   1              0                  1
     Next state                                 Sl                   S2             S2                 S2
     Output bit                                  0                   1              1                  0

    Table 15.03 State-transition table with outputs

    This method can be represented as the state-transition diagram in Figure 15.10.

                                       1/1




                0/0                                              01

        start
                                                                          1]0




    Figure 15.10 State-transition diagram for a two’s complement FSM




    TASK 15.05

    Write a program that simulates the intruder detection system in Worked Example 15.01.




Question 15.01
What is the output from the FSM represented bythe state-transition diagram in Figure 15.10,
when the input is 0101?


Extension Question 15.01
Does the FSM in Figure 15.10 work for converting a negative binary number into its positive
equivalent?



15.05 Types of error
Why errors occur and how to find them
Software may not perform as expected for a number of reasons, such as:

e   the programmer has made a coding mistake

e   therequirement specification was not drawn up correctly
                                                                                        Part 2: Chapter 15: Software development




e      thesoftware designer has made
                                   a design error

e      theuser interface is poorly designed, and the user makes mistakes

e      computer hardware experiences failure.

How are errors found? The end user might report an error. This is not good for the reputation
of the software developer. Testing software before it is released for general use is essential.
Research has shown that the earlier an error can be found, the cheaper it is to fix it. It is very
important that software is tested throughout its development.

The purpose of testing is to discover errors. Edsger Dijkstra, a famous Dutch computer scientist,
said ‘Program testing can be used to show the presence of bugs, but never to show their absence!”

Finding syntax errors is easy. The compiler/interpreter will find them for you and usually gives
you a hint as to what is wrong.

Depending on your development environment editor, some syntax errors may be flagged up by
your editor, So you can correct these as you go along. A syntax error is a ‘grammatical’ error, in
which a program statement does not follow the rules ofthe high-level language constructs.


       KEY TERM


       Syntax error: an errorin which a program statement does not fc          e rules of the languag




Some syntax errors might only become apparent when you are using an interpreter or
compiler to translate your program. Interpreters and compilers work differently (see
Chapter
      8, Section 8.05, and Chapter 20, Section 20.06). When a program compiles
successfully, you know there will be no syntax errors remaining.

This is not the case with interpreted programs. Only statements that are about to be
executed will be syntax checked. So, if your program has not been thoroughly tested, it might
even have syntax errors remaining.

fc ee Microsoft Visual Basic 2010 Express                                                            _(o |x|




         EiModule Module1
                 Const Space := " " ' constant to        give a space a name                              «|
                 Dim Nunber f| End of statement expected. |S As Integer                                                             TM
                 Dim MaxNumb                        -                           The blue underline shows that there is a syntax error.
                 Dim Symbol As Char

                                                                                As you move the mouse pointer over different parts of
                                                                                the line of code, the editor will display explanations.
    Error List


                                                                               \ Here the mouse pointer hovered under the := aw,
    Ready




Figure 15.11 Syntax error in a Visual Basic program


Figure 15.11 gives an example of how a compiler flags a syntax error. The compiler stops
when it first notices a syntax error. The error is often on the previous line. The compiler can’t
tell until it gets to the next line of code and finds an unexpected keyword.

Much more difficult to find are logic errors and run-time errors. A run-time error occurs when
program execution comes to an unexpected halt or ‘crash’ or it goes into an infinite loop and ‘freezes’.
Cambridge International AS & A Level Computer Science




       KEY TERMS




Both of these types of error can only be found by careful testing. The danger of such errors
is that they may only show up under certain circumstances. Ifa program crashes every time
it is executed, it is obvious there is an error. If the program is used frequently and appears to
work until a certain set of data causes a malfunction, that is much more difficult to discover
without perhaps serious consequences.



15.06 Testing methods
Stub testing
When you develop a user interface, you might wish to test it before you have implemented all
the facilities. You can write a ‘stub’ for each procedure (see Figure 15.12). The procedure body
only contains an output statement to acknowledge that the call was made. Each option the
user chooses in the main program will call the relevant procedure.

& ConsoleApplication1 - Microsoft Visual Basic 2010 Express                                -lo)x|
File    Edit   View   Project   Debug    Data   Tools   Window   Help

P7SGa-ad@|s4 BAlAlS2/9-@-|> oa                                                  | Qa see



       ElModule Module                                                                        =
               Dim MenuChoice As String                                                       a
               Dim ProgramEnd As Boolean = False


               [Sub ShowMenu() ...J
       0-8




               Sub EnterNewStudent()
                      Console.WriteLine("EnterNewStudent routine called")
        [      End Sub
       SS}     Sub AmendDetails()
                      Console.WriteLine("AmendDetails routine called”)
        [      End Sub
       A       Sub PrintList()
                      Console.WriteLine("PrintList routine called")
        |      End Sub
       8       Sub SearchByName()
                      Console.WriteLine("SearchByName routine called”)
               End Sub


       =       Sub Main()
                      Do

                            ShowMenu()
                            MenuChoice = Console.ReadLine()
                            Select Case MenuChoice
                                Case "1"
                                        EnterNewStudent()
                                Case "2"
                                        AmendDetails()
                                Case "3"
                                        PrintList()
                                Case "4"
                                        SearchByName()
                                Case "5"
                                        ProgramEnd = True
                                Case Else
                                        Console.WriteLine("Invalid choice.   Try again")
                            End Select
                      Loop Until ProgramEnd


                End   Sub


        | End Module




Figure 15.12 VB.NET stub testing
                                                                          Part 2: Chapter 15: Software development




Black-box testing
As the programmer, you can see your program code and your testing will involve knowledge
of the code (see white-box testing).

As part of thorough testing, a program should also be tested by other people, who do not see
the program code and don’t know how the solution was coded.

Such program testers will look at the program specification to see what the program is meant
to do, devise test data and work out expected results. Test data usually consists of normal
data values, extreme/boundary data values and erroneous/abnormal data values.

The tester then runs the program with the test data and records their results. This method of
testing is called black-box testing because the tester can’t see inside the program code: the
program is a ‘black box’.

Where the actual results don’t match the expected results, a problem exists. The
programmer needs to find the reason for this discrepancy before correcting the program
(see Section 15.08). Once black-box testing has established that there is an error, debugging
software or dry-running have to be used to find the lines of code that need correcting.




White-box testing
How can we check that code works correctly? We choose suitable test data that checks every
path through the code. This is called white-box testing.




  WORKED EXAMPLE 15.03


  White-box testing of pseudocode

  This is the pseudocode from Worked Example 12.02 in Chapter 12:

  INPUT       Numberl

  INPUT       Number2

  INPUT       Number3

  IF   Numberl       >   Number2

       THEN                     //   Numberl   is   bigger

         IF   Numberl      >   Number3

              THEN

                OUTPUT     Numberl

              ELSE

                OUTPUT     Number3

        ENDIF




                                                                                                       (Continued)
Cambridge International AS & A Level Computer Science




       ELSE                            //   Number2   is bigger

            IF    Number2     >       Number3

                 THEN

                   OUTPUT     Number2

                 ELSE

                   OUTPUT     Number3

            ENDIF

  ENDIF



  To test it, we need four sets of numbers with the following characteristics.
  e     The first number is the largest.

  e     The first number
                       is larger than the second number; the third number
                                                                        is the largest.

  e     Thesecond number is the largest.

  e     Thesecond number is larger than the first number; the third number
                                                                         is the largest.

  Note that it does not matter what exact values are chosen as test data. The important point is that the values
  differ in such a way that each part of the nested IF statement is checked. Table 15.04 lists four sets of test
  data and the results from them. The parts of the algorithm not entered for a particular set of data are greyed
  out. This makes it easier to see that each part has been checked after all four tests have been done.


      Line of algorithm                                  | Test 1     | Test 2   | Test 3        | Test 4
      INPUT       Number1                                 15           12         12              8

      INPUT       Number2                                 12           8          15              12

      INPUT       Number3                                 8            15         8               15

      IF   Numberl       >   Number2                      TRUE         TRUE       FALSE           FALSE

      THEN                                                TRUE         FALSE
             IF    Numberl        >   Number3

                  THEN                                    Output 15
                    OUTPUT        Numberl1

                  ELSE                                                 Output
                                                                            15
                    OUTPUT        Number3
             ENDIF

           ELSE                                                                   TRUE            FALSE

             IF    Number2        >   Number3

                  THEN                                                            Output 15
                    OUTPUT        Number2

                  ELSE                                                                            Output
                                                                                                       15
                    OUTPUT        Number3
             ENDIF

      ENDIF



  Table 15.04 Testing the validity of the nested IF statement




Dry-running an algorithm
A good way of checking that an algorithm works as intended is to dry-run the algorithm
using a trace table and different test data. This is also known as a walk through.

The idea is to write down the current contents of all variables and conditional values at each
step of the algorithm.
                                                                                                                        Part 2: Chapter 15: Software development




f KEY TERMS

                                                         s of checking the execution of an algorithm or program by
                                                              e   eslh   .    |        it                c     |   |      ’   ;   ,   Law




   recording variable va ues            IN a trace table




   WORKED EXAMPLE 15.04


  Tracing an algorithm

  Here is the algorithm of the number-guessing game:

  SecretNumber <               34
  INPUT      "Guess       a   number:           "   Guess
  NumberOfGuesses               <       1
  REPEAT

        IF   Guess        =   SecretNumber
             THEN

               OUTPUT          "You          took   ",       NumberOfGuesses,                       "        guesses”

             ELSE

               IF    Guess          >       SecretNumber
                    THEN

                      INPUT             "Guess      a        smaller          number:           "   Guess
                    ELSE

                      INPUT             "Guess      a        larger          number:        "       Guess
               ENDIF

                NumberOfGuesses                     <        NumberOfGuesses                    +    1

        ENDIF

  UNTIL      Guess    =       SecretNumber


  To test the algorithm, construct a trace table (Table 15.05) with one column for each variable used in the
  algorithm and also for the condition Guess > SecretNumber

  Now carefully look at each step of the algorithm and record what happens. Note that we do not tend to write
  down values that don’t change. Here SecretNumber does not change after the initial assignment, so the
  column is left blank in subsequent rows.


   SecretNumber                | Guess              | NumberofGuesses | Guess > SecretNumber | Message
   34                               5                    1                                      FALSE                                       ...larger...

                                    55                  2                                       TRUE                                        ...smaller...

                                30                      3                                       FALSE                                       ...larger...

                                42                      4                                       TRUE                                        ...smaller...

                                36                       5                                      TRUE                                        ...smaller...

                                33                       6                                      FALSE                                       ...larger...

                                34                       7                                                                                      7   guesses




  Table 15.05 Trace table for number-guessing game


We only make an entry in a cell when an assignment occurs. Values remain in variables until
they are overwritten. So a blank cell means that the value from the previous entry remains.

It is important to start filling in a new row in the trace table for each iteration (each time
round the loop).
Cambridge International AS & A Level Computer Science




0   TIP

    When learning to complete trace tables and to ensure you follow every line of code in the correct
    sequence, you can number the lines of the algorithm and add a column for the line numbers in
    your trace table (see Worked Example 15.05 Trace Table 15.06).




    WORKED EXAMPLE 15.05


 Tracing an algorithm

 To test the improved algorithm of Worked Example 13.03 (bubble sort), dry-run the algorithm by completing
 the trace table (Table 15.06).

  O01   MaxIndex <               7
  02    n < MaxiIndex                     -    1
  03    REPEAT

  04          NoMoreSwaps                          <       TRUE

  05          FOR    j       «       1        TO       n
  06                 IF MyList[j]                              >    MyList[j         +       1]
  O07                        THEN
  08                                 Temp < MyList[j]
  09                                 MyList[j]                     < MyListij            +    1]
 10                                  MyList[j                  +    1]       < Temp
 11                                  NoMoreSwaps                         <   FALSE

 12                  ENDIF

 13           NEXT       j
 14           nen-                   tl

 15     UNTIL    NoMoreSwaps                               =   TRUE


          Line      Numbers                                        Max        |n         No-       j     MyList[j]     >    | Temp                    MyList
                                                               Index               MoreSwaps            MyList[j   +   1]            [11 | [21 | [3] | 41 | (51 | (611      £7]

    O01, 02                                                    7              6                                                      5    34    |98    |7    41     |19    |25

    03,04, 05, 06,12                                                               TRUE            1 | FALSE

    13,05,06,12                                                                                    2 | FALSE

    13,05, 06,07, 08,09, 10                                                                        3 | TRUE                  98                 7      98

    11,12                                                                          FALSE

    13,05, 06,07, 08, 09,10                                                                        4 |TRUE                   98                        41    |98

    11,12                                                                          FALSE

    13,05, 06,07, 08, 09,10                                                                        5 | TRUE                  98                              19    | 98

    11,12                                                                          FALSE

    13,05, 06,07, 08, 09,10                                                                        6 | TRUE                  98                                     25    | 98

    11,12                                                                          FALSE

    13,14,15                                                                  5

    03,04, 05, 06,12                                                               TRUE            1 | FALSE

    13,05, 06, 07,08, 09,10                                                                        2 | TRUE                  34           7     34

    11,12                                                                          FALSE

    13,05,06,12                                                                                    3   | FALSE

    13,05, 06, 07,08, 09,10                                                                        4 | TRUE                  41                        19   | 41

    11,12                                                                          FALSE

    13,05, 06, 07,08, 09,10                                                                        5 | TRUE                  41                              25    | 41

    11,12                                                                          FALSE



                                                                                                                                                                     (Continued)
                                                                                                      Part 2: Chapter 15: Software development




               e              be                 a                       0                                 emp




   13,14,15                                               4

   03,04,05,06,12                                                 TRUE            1 | FALSE

   13,05,06,12                                                                    2 | FALSE

   13,05, 06, 07, 08, 09, 10                                                      3 | TRUE                34            19   | 34

   11,12                                                          FALSE

   13,05, 06, 07, 08,              09,10                                          4 | TRUE                34                  25    | 34

   11,12                                                          FALSE

   13,14,15                                               3

   03,04,05,06,12                                                 TRUE            1 | FALSE

   13,05, 06,12                                                                   2 | FALSE

   13,05, 06,12                                                                   3 | FALSE

   13,14,15                                               2



  Table 15.06 Trace table for improved bubble sort algorithm




  TASK 15.06

  Design a trace table for the following algorithm:

  FUNCTION        ConvertFromHex(HexString                         :    STRING)    RETURNS     INTEGER

       DECLARE            ValueSoFar,        HexValue,             HexLength,       i   :   INTEGER

       DECLARE            HexDigit       :   CHAR

       ValueSoFar <                0

       HexLength               <   Length(HexString)

       FOR    1       <   1   TO HexLength
              HexDigit < HexString[i]

              CASE            OF HexDigit

                      'A':     HexValue      <   10

                      'B':     HexValue      <   11

                      'C':     HexValue      <   12

                      'D':     HexValue      <   13

                      'E':     HexValue      <   14

                      'F':     HexValue      <   15

                      OTHERWISE         HexValue      <       StringToInt(HexDigit)

              ENDCASE

              ValueSoFar               < ValueSoFar           *    16    +   HexValue

       NEXT       i

       RETURN ValueSoFar

  ENDFUNCTION

  Dry-run the function call ConvertFromHex('A5') by completing the trace table.




These testing methods are used early on in software development, for example when
individual modules are written. Sometimes programmers themselves use these testing
methods. In larger software development organisations, separate software testers will
be employed.
      Cambridge International AS & A Level Computer Science




      Discussion Point:
      Do you think that a program tester will find errors the programmer did not know about? You
      can try out the idea by letting your friends test a program that you think works perfectly.

      Software often consists of many modules, sometimes written by different programmers.
      Each individual module might have passed all the tests, but when modules arejoined
      together into one program, it is vital that the whole program is tested. This is known as
      integration testing. Integration testing is usually done incrementally. This means that a
      module at a time is added and further testing is carried out before the next module is added.

      Software will be tested in-house by software testers before being released to customers.
      This type of testing is called alpha testing.

      Bespoke software (written for a specific customer) will then be released to the customer.
      The customer will check that it meets their requirements and works as expected. This
      stage is referred to as acceptance testing. It is generally part of the hand-over process. On
      successful acceptance testing, the customer will sign off the software.

      When software is not bespoke but produced for general sale, there is no specific customer
      to perform acceptance testing and sign off the software. So, after alpha testing, a version is
      released to a limited audience of potential users, known as ‘beta testers’. These beta testers
      will use the software and test it in their own environments. This early release version is called
      a beta version and the chosen users perform beta testing. During beta testing, the users will
      feed back to the software house any problems they have found, so that the software house
      can correct any reported faults.
304   t




          Integration testing: individually tested modules are joined into one program and tested to ensure
          the modules interact correctly

          Alpha testing: testing of software in-house by dedicated testers

          Acceptance testing: testing of software by customers before sign-off
          Beta testing: testing of software by a limited number of chosen users before general release




      15.07 Test strategy, test plans and test data
      During the design stage of a software project, a suitable testing strategy must be worked
      out to ensure rigorous testing of the software from the very beginning. Consideration should
      be given to which testing methods are appropriate for the project in question. A carefully
      designed test plan has to be produced.

      It is important to recognise that large programs cannot be exhaustively tested but it is
      important that systematic testing finds as many errors as possible. We therefore need a test
      plan. In the first instance, an outline plan is designed, for example:

      e   flow of control: does the user get appropriate choices and does the chosen option go to
          the correct module?

      e   validation of input: has all data been entered into the system correctly?
      e   doloops and decisions perform correctly?
      e   is data saved into the correct files?

      e   does the system produce the correct results?
      This outline test plan needs to be made into a detailed test plan.
                                                                                  Part 2: Chapter 15: Software development




How can we carry out these tests? We need to select data that will allow us to see whether
itis handled correctly. This type of data is called ‘test data’. It differs from real, live data
because it is specifically chosen with a view of testing different possibilities. We distinguish
between different types of test data, listed in Table 15.07.

 Type of test data                 | Explanation
 Normal (valid)                     Typical data values that are valid

 Abnormal (erroneous)               Data values that the system should not accept

 Boundary (extreme)                 Data values that are at a boundary or an extreme end ofthe range
                                    of normal data; test data should include values just within the
                                    boundary (that is, valid data) and just outside the boundary (that
                                    is, invalid data)


Table 15.07 Types of test data


   WORKED EXAMPLE 15.06


  Designing test data

  Look at the Pyramid Problem (code shown in Section 14.13). This is a simple program, but we can use it to
  illustrate how to choose test data. There are just two user inputs: the number of symbols that make up the
  base and the symbol that is to be used to construct the pyramid. Let’s consider just the test data for the
  number of symbols (Table 15.08).


   Type of test    | Example        Explanation
   data              test values

   Normal (valid) | 7               7 is an odd integer, so should be accepted.
                                    Any odd positive integer would be suitable as test data. However, it should be bigger than 1 to
                                    check that the pyramid is correctly formed. More than one different value to test would be a
                                    good idea.

   Abnormal                         Any number that is not a positive odd integer. This will require several tests to ensure that the
   (erroneous)                      following types of data are not accepted:
                     -f             *   negative integer
                     8              *   even integer
                     75             *   real number
                      me            *   non-numeric input.
                                    You should not take shortcuts and choose one negative even integer or one negative real
                                    number and think you can test two things at the same time. You will not know whether
                                                                                                                      the test
                                    fails for just one reason or both.

   Boundary          1              What isa boundary value? The smallest possible pyramid isa single symbol. So the value 1 is
   (extreme)                        just within the boundary.
                                    Sometimes choosing test data throws up some interesting questions that need to be considered
                     0              when designing
                                                the solution:
                                    «   Should 0 be accepted? Is 0 an even number?
                                        ls it outside the boundary because a pyramid of 0 symbols is not really a pyramid?
                                    «   Is there just one boundary? Should the program reject numbers that are too large?
                     19             The output would not look like a pyramid if there were a wrap-around. So the program really
                     81             should check how many symbols fit onto one line and not allow the user to input a number
                                    greater than this. If the number of characters across the screen is 80, then 79 would bejust
                                    within the boundary but 81 would be outside the boundary, and should not be accepted.
                                    Note that by testing with values within the boundary you are also testing normal data, albeit at
                                    the extreme ends of the normal range.


  Table 15.08 Test data for the pyramid problem
Cambridge International AS & A Level Computer Science




    TASK 15.07

    Look at the programs you wrote in Chapter 14.
    1   Design test data for the number-guessing game (Task 14.09.2).
    2   Design test data for the Connect 4 game (Task 14.11).



How to prevent errors
The best way to write a program that works correctly is to prevent errors in the first place.
How can we minimise the errors in a prograrn? A major cause oferrors is poor requirements
analysis. When designing a solution it is very important that we understand the problem and
what the user of the system wants or needs. We should use:

e   tried and tested design techniques such as structured programming or object-oriented design

e   conventions such as identifier tables, data structures and standard algorithms

e   tried and tested modules or objects from program libraries.


15.08 Corrective maintenance
Maintaining programs is not like maintaining a mechanical device. It doesn’t need lubricating
and parts don’t wear out. Corrective maintenance of a program refers to the work required
when a program is not working correctly due to a logic error or because of a run-time error.
Sometimes program errors don’t become apparent for a long time because it is only under
very rare circumstances that there is an unexpected result or the program crashes. These
circumstances might arise because part of the program is not used often or because the data
on an occasion includes extreme values. Earlier corrective maintenance may also introduce
other errors.



———EEEe
    Corrective maintenance: correcting identified errors



When a problem is reported, the programmer needs to find out what is causing the bug.
To find a bug, a programmer either uses program debugging software or
                                                                    a trace table
(see Section 15.06).



    TASK 15.08

    1   Design a trace table for the following algorithm:
        INPUT          BinaryString
        StringLength < Length(BinaryString)
        FOR    i       <«   1   TO   StringLength
               Bit          < BinaryString[i]
               BitValue <             IntegerValue(Bit)    //   convert    string   to   integer
               DenaryValue             < DenaryValue   +   2    +   BitValue
        NEXT       i

    2   Dry-run the algorithm using '101' as the input. Complete the trace table.

    3   The result should be 5. Can you find the error in the code and correct it?
                                                                           Part 2: Chapter 15: Software development




15.09 Adaptive maintenance
Programs often get changed to make them perform functions they were not originally
designed to do.

For example, the Connect 4 game introduced in Chapter 13 (Worked Example 13.03) allows
two players, O and X, to play against each other. An amended version would be for one player
to be the computer. This would mean a single player could try and win against the computer.

Adaptive maintenance is the action of making amendments to a program to enhance
functionality or in response to specification changes.

   KEY TERM




  TASK 15.09

  Design the algorithm to simulate the computer playing the part of Player X in
  Connect 4.




15.10 Perfective maintenance
The program runs satisfactorily. However, there is still room for improvement. For example, the
program may run faster if the file handling is changed from sequential access to direct access.




  TASK 15.10

  Analyse the pseudocode below and make amendments to enhance maintainability.
   FUNCTION GetPositiveNumber

        DECLARE           n   :    INTEGER

        OUTPUT        "Enter a positive number:             "

        INPUT     n

        RETURN        n

   ENDFUNCTION

   // main program

   REPEAT

        Numberl < GetPositiveNumber

        IF Numberl                <=   0

            THEN

              OUTPUT              "Not     a positive number:   "

        ENDIF

   UNTIL Numberl              >    0

   REPEAT

        Number2           < GetPositiveNumber


                                                                                    (Continued)
Cambridge International AS & A Level Computer Science




       IF   Number2           <=       0

            THEN

              OUTPUT          "Not         a positive              number:   "

       ENDIF

  UNTIL     Number2       >    0




Reflection Point:
Have you used dry-running for programs you have written? You can check your trace table
if you add output statements at key points in your program. You can then compare the
program output with the contents of your trace table.




     The stages of the program development cycle consist of analysis, design, coding, testing and maintenance.

     Structure charts are graphical representations of the modular structure of solutions.

     A structure chart shows the interface between modules: parameters passed between calling module
     and the module being called.

     Structure charts show selection, where a module is called only under certain conditions.
     Structure charts show repetition, where modules are called repeatedly.

     Astate transition diagram is another way of documenting an algorithm.

     Testing strategies include stub testing, black-box testing, white-box testing, integration testing, alpha
     and beta testing, and acceptance testing.

     Locating and correcting logic errors and run-time errors can be done by dry-running an algorithm or
     using a trace table.

     Corrective maintenance means fixing bugs that have come to light during use of the program.

     Adaptive maintenance involves altering an algorithm and data structure in response to required changes.

     Perfective maintenance means enhancing performance or maintainability.




   Consider this code for a function:

   FUNCTION Binary(Number                             :   INTEGER)     RETURNS       STRING

        DECLARE      BinaryString                         :   STRING

        DECLARE      PlaceValue                   :       INTEGER

        BinaryString <                     ''    //       empty     string

        PlaceValue        <        8

        REPEAT


              IF   Number              >=       PlaceValue

                   THEN


                     BinaryString < BinaryString                                 &   '1'   //   concatenates   two   strings

                     Number                < Number            -   PlaceValue

                   ELSE


                     BinaryString < BinaryString                                 &   '0'

              ENDIF
                                                                                                                   Part 2: Chapter 15: Software development




                  PlaceValue <                   PlaceValue              DIV   2

        UNTIL Number                 =       0

        RETURN BinaryString

    ENDFUNCTION


    a    Complete the trace table for the function call Binary(11).

             Number | BinaryString | PlaceValue | Number                                                >=    PlaceValue

             11            mt                                   8




         State the return value.                                                                                                           [5]
    b    i        Complete the trace table for the function call Binary (10).

             Number | BinaryString | PlaceValue | Number                                                >=    PlaceValue

             10            ri                                   8




         State the return value.                                                                                                           [3]
         ii       Thealgorithm is supposed to convert a denary integer into the equivalent binary
                  number, stored as a string of Os and Is. Explain the result of each dry-run and what
                  needs changing in the given algorithm.                                                                                   [3]
2   Aprocedure to output a row ina                         tally chart has been written using pseudocode:
    PROCEDURE OutputTallyRow(NumberToDraw                                              :   INTEGER)

         IF       Count    >    0


              THEN


                   FOR    Count          <       1   TO NumberToDraw

                          IF    (Count               MOD   5)       =    0

                               THEN


                                    OUTPUT('\')             //          every 5th bar                slants    the other way

                               ELSE


                                    OUTPUT ('/')

                          ENDIF


                   NEXT    Count


         ENDIF


         OUTPUT NewLine                      // move to next                   row

    ENDPROCEDURE


    Suggest suitable test data that will test the procedure adequately. Justify your choices in each case. [9]
3   Arandom number generator is to be tested to see whether all numbers within the range 1 to 20 are
    generated equally frequently. The structured English version ofthe algorithm is
    Initialise       a    tally for                  the    numbers            1   to      20

    Repeatedly generate numbers                                 in range           1       to   20
Cambridge International AS & A Level Computer Science




    For     each number generated,             increment          the   relevant   count

    Calculate how often each number                         should be generated        (expected       frequency)

    Output      expected        frequency

    Output       the     list   of   numbers   as     a     table with actual      frequency

    The identifiers required are:

     Identifier                        Data Type                Explanation
     Tally                             Array[1 : 20] | 1D arrayto store the count of how many times
                                       OF INTEGER      each number has been generated

     RandomNumber                      INTEGER                  The random number generated

     NumberOfTests                     INTEGER                  The number of times a random number is to be
                                                                generated (1000 in this example)

     ExpectedFrequency               | INTEGER                  The number oftimes any one number would be
                                                                generated if all numbers are generated equally
                                                                frequently (1000/20 in this example)


    a       Complete the structure chart below by naming the labels A to E.                                          [5]
    b       Develop pseudocode from the structure chart.                                                            [12]




                                            Random Number
                                                    Tally




                  A                     B                    Update Tally        Output Tally




4   Acar park has a barrier at the exit. The starting position of the barrier is lowered. When a
    car wants to exit the car park, the driver has to insert a coin into a coin slot at the barrier.
    The barrier raises and allows the car to drive out of the car park. After the car has passed
    through the barrier, the barrier lowers. In case of emergency, a member of staff can open
    the barrier using a remote control. The barrier will remain open until the remote control is
    used again to lower the barrier.

    The barrier has three states: lowered, raised and open. The transition from one state to
    another is as shown in the state-transition table:

        Current state                       Event                                  Next state

        Barrier lowered                     Coin inserted                          Barrier raised

        Barrier lowered                     Open remotely                          Barrier open

        Barrier open                        Close remotely                         Barrier lowered

        Barrier raised                      Car has exited                         Barrier lowered
                                                         Part 2: Chapter 15: Software development




Complete the state-transition diagram for the barrier:
                                                                                                                            313




Data representation

Learning objectives
By the end of this chapter you should be able to:

   show understanding of why user-defined types are            show understanding of the effects of changing the
   necessary                                                   allocation of bits to mantissa and exponent in a floating-
   define and use non-composite data types                     point representation
   define and use composite data types                         convert binary floating-point real numbers into denary and
   choose and design an appropriate user-defined data type     vice versa
   fora given problem                                          normalise floating-point numbers
   show understanding of the methods of file organisation      show understanding of the consequences of a binary
   and select an appropriate method of file organisation and   representation only being an approximation to the real
   file access fora given problem                              number it represents (in certain cases)
   show understanding of methods of file access                show understanding that binary representations can give
   show understanding of hashing algorithms                    rise to rounding errors.
   describe the format of binary floating-point real numbers




               +
Cambridge International AS & A Level Computer Science




16.01 Data types
Sections 13.01 to 13.05 of Chapter 13 introduced the concept of a variable being associated
with a data type. Before a variable can be used in a program, the variable’s data type has to
be identified. Chapter 13 introduced the most frequently used data types that are available
for association with a variable in a program. This chapter introduces some additional data
types that might be used.



Built-in data types
Remember, for each built-in data type:

e   the programming language defines the range of possible values that can be assigned to a
    variable when its type has been chosen.

e   the programming language defines the operations that are available for manipulating
    values assigned to the variable.



User-defined data types
The term ‘user’ is regularly applied to someone who is provided with a ‘user interface’ by
an operating system — the ‘user’ is the person supplying input to a running program and
receiving output from it.

However, when writing a program, a programmer becomes a ‘user’ ofa programming
language. The term user-defined data type applies to this latter type of user.

A user-defined data type is a data type for which the programmer has included the definition
in the program. Once the data type has been defined, variables can be created and
associated with the user-defined data type. Note that, although the user-defined data type
is not a built-in data type, using the user-defined data type is only possible if a programming
language offers support for the construct.



0    TIP

     Make sure that you do not confuse user-defined data types and abstract data types (defined in
     Section
       13.07 of Chapter 13).




Non-composite data types
A non-composite data type is one which has a definition which does not involve a reference
to another data type. The simple built-in data types, such as integer or real, are examples of
built-in non-composite data types. It is also possible for a user-defined data type to be non-
composite.



Enumerated data type
An enumerated data type is an example of a user-defined non-composite data type. When a
specific enumerated data type is defined, every single possible value for it is identified. The
following pseudocode shows two examples of enumerated data type definitions:
    TYPE

    TDirections     =   (North,   East,   South,    West)

    TDays   =   (Monday,   Tuesday,    Wednesday,     Thursday,      Friday,    Saturday,     Sunday)
                                                                                Part 3: Chapter 16: Data representation




Following these definitions, variables can be declared and assigned values, for example:

    DECLARE   Directionl            :    TDirections

    DECLARE   StartDay         :    TDays

    Directionl    < North

    StartDay < Wednesday

Itis important to note the following points.

e    The values of the enumerated type look like string values but they are not. The values
     must not be enclosed in quotes.

e    The values defined in an enumerated data type are ordinal. This means that enumerated
     data types have an implied order ofvalues.

The ordering can be put to many uses in a program. For example, a comparison statement
can be used with the values of the variables of
                                              an enumerated data type:

    DECLARE   Weekend      :       Boolean

    DECLARE   Day   :    TDays

    Weekend   =   TRUE    IF       Day    >   Friday



    KEY TERMS




The enumerated data type is one reason why user-defined data types are sometimes
needed. There could not be a built-in generic definition of
                                                          an enumerated data type
because the possible values would not be known. The values can only be known when the
programmer has identified them in the type definition.



Composite user-defined data types
A composite user-defined data type has a definition with reference to at least one other type.
There are two very important examples of composite user-defined data type.

1   The record data type (introduced in Chapter 13). Although there could be built-in record
    data types the expectation is for a record data type to be user-defined. This allows the
     programmer to create record data types with components that precisely match the data
    requirements ofthe particular program. Note that Python is a language that does not
    support the use of a record data type.

2   The class. A class is a data type which is used for an object in object-oriented programming.
     Fora given object-oriented programming language there are likely to be a number of built-
    in classes. However, ifa programmer intends to utilise the benefits of the object-oriented
    approach, then the programmer will have to create a number of user-defined classes.



Pointer data type
A pointer variable is one for which the value is a reference to a memory location. The following
isa commentary on some examples of pseudocode involving the use ofthe pointer data type.
Cambridge International AS & A Level Computer Science




1   Anexample ofthe definition ofa pointer type which requires only the identification ofa
    data type for which the pointer is to be used.
    TYPE

    TIntegerPointer < “Integer

2   Anexample ofthe declaration of a variable of the pointer data type which does not
    require the use ofthe caret (*) symbol.
    DECLARE MyIntegerPointer             :       TIntegerPointer

3   Anexample ofthe declaration of two ordinary variables of type integer and the
    assignment of a value for one of them.
    DECLARE     Numberl,     Number2         :   INTEGER

    Numberl     <   100

4   Anexample of an assignment to a pointer variable ofa value which is the address ofa
    different variable.
    MyIntegerPointer < @Numberl

5   Anexample of an assignment which uses the ‘dereferenced’ value which has been stored
    at the address defined by the pointer variable. This assigns the value 200 to Number2.
    Number2 < MyIntegerPointer~                   *   2



—————eEEEiiEEE
    Pointer variable: one for which the value is the address in memory of a different variable



Not all programming languages offer support for the use ofa pointer data type. Those
languages that do so will have their own version of the symbolism illustrated above with *
and @.

Because arithmetic can be performed on pointer variables, it is possible to use pointer
variables to construct dynamically varying data structures. For some programming
languages it is necessary to declare an array with a large upper bound to ensure that the
array is unlikely to be fully populated with values. If the language supports the use of a
pointer variable, the size of an array can expand while a program is running. The details of
how this can be done are beyond the scope of this discussion.


Set data type
A set data type allows a program to create sets and to apply the mathematical operations
defined in set theory. Aset is a mathematical concept with important properties.

e   |tcontains a collection of data values.

e   There is no organisation of the data values within the set.
e   Duplicate values are not allowed.

e   Operations that can be performed on a set include:
    e    checking if a value exists in a set

    e    adding anew data value

    e    removing an existing data value

    e    adding one set to another set.

A set variable can be created if a programming language supports the set data type. It is difficult
to classify the set data type. Because the set contains multiple components it is tempting to
say that the set is a structured data type. However, this contradicts the fact that the set has no
structure and therefore no indexing can be associated with the members of the set.
                                                                                 Part 3: Chapter 16: Data representation




The most useful property of a set is the fact that duplicate values are not allowed. A list ora
one-dimensional array might be created but has to be checked to remove duplicate values. A
simple way of removing duplicate values would be to convert the structure to a set and then
convert the set back to the original structure.

A slightly different example would be if students were allocated to groups for studying a
particular subject. For each subject, the students’ names would be entered into a data
structure defined for that subject. Set data types could then, for example, find out which
students were studying both computer science and physics. The students studying both
subjects would be found by applying the ‘intersection’ operation on the two individual sets.



16.02 File organisation
In everyday computer usage, a wide variety of file types is encountered. Examples are graphic
files, word-processing files, spreadsheet files and so on. Whatever the file type, the content is
stored using a specific binary code that allows the file to be used as intended.

For the specific task of storing data to be used for input to a computer program or for output
from a computer program, there are only two defined file types. A file is either a text file or a
binary file.

A text file, as discussed in Chapter 13 (Section 13.06) contains data stored according to a
character code of the type described in Chapter 1 (Section 1.04). It is possible, by using a text
editor, to create a text file to be used as input to a program.

A program may create a binary file as output with the intention of subsequently using it for
input. A binary file stores data in its internal representation, for example an integer value
might be stored in two bytes in two’s complement representation.

The organisation of a binary file is based on the concept ofa record. A file contains records
and each record contains fields. Each field consists ofa value. For
                                                                  a text file the number of
data items per line must be known and the number of characters per item must be known.
Ifthese are not known then item separator characters must be used. The file has repeating
lines which are defined by an end-of-line character or characters.

For a binary file the number of fields per record must be known. If any ofthe fields
represent a string, the length of the string must be known. For any other field the internal
representation will define the number of bytes required to store the field value. There is no
need for field separator characters or for an end-of-record character.


f KEY TERMS




Discussion Point:
A record is a user-defined data type. It is also a component of a file. Can there be or should
there be any relationship between these two concepts?
                                                                                  |
rood     ogee
Sagara Peis
SS  Yhas FESS

A serial file contains recarcs that have not been organised in any     defined order A typical
use of a Serialfile wouldbefora bankto record transactions involving customer accounts.
A propram would
              be running.£ach time there was a withdrawal or a deposit the program
wouldreceive the details as data inout and would record the dataina transaction file. In a
serial file each new record is simply appended to     the file so thatthe only ordering in the file is
the time order of data entry.




  sequential file has records that are ordered, Inthe bank example, a sequential file could
be used as a master filefor an individual customer account. At regular periods of time, the
transaction file would be read, and all affected customer account master files would be
updated. In order to allow a sequentialfile to be ordered, therehas tobe a key feild for which
the values are unique and sequential but notnecessarily consecutive. When anew record is
to be added to a sequential file it would be possible to simply append the record, with the
intention of sorting
                 the fle later. A more likely approach ts for the file to be reac sequentially
and each record written to @ new file. Thisis continued untilthe appeesiate positionfor the
new record is reached, The new record is then written to the new
                                                               file before the remaining
records in the ola fle are copied in.




Pree aetacceace Flac
Lae Sr ete          PES
       ee       .     =




Direct-access filesare sometimes referred to as ‘randarn-access' files but, as with randam-
access   memory, the randamness
                            is only that the access can be te any record in the file
withoutwtsequential reading ofthefile. Direct access can be achieved with a sequential file. A
separate index file is created which has tw fields per record. Thefirst field has the key field
value andthesecond field has a value for the position ofthis key field value in the main file.

The alternative is to use a hashing algorithrn when a record is entered into the direct-access



One simple hashing aigorithm is applicable if there is a numeric key tield in each record.
The algorithm chooses a suitable number and civides this number by the value in the key
Heid.The remainder from this division then identities the adcressin thefile for storage of
that record. Tnesuitable number works best ifitisa prime number
                                                             of a similar size to the
expected size of the file.

For sirnplicity this can be illustrated for
                                          4-digit valuesin the key fleid where 1000 is used for
the dividing number. The following represent three calculations:

                     0045/1000 gives remainder
                                            45 for the address
                                                            in thefile

                     2005/1000 gives remainder 5 for tne address in the fle
                                                  _




                     3005/1000 gives remainder
                                             5 for the addressin thefile

There are two facts apparentfrom these calculations. The first fact is that the addresses
calculated do not have any order depending on the valuein the key field.The second fact
adress i1 the file
     _
                                                                                  “                 SHOES SS ES




I’ the records do not have a suitable field with numeric cigits, an alternative is to choose a
field with some alphabetic characters. The ASCIi code for each character can be looked up
and the values then added. The sur is then used in the same way as described above, to
calculate an address as the remainder from an integer division.

When the same address is caiculated for different fieid values, it is usually referred to as a
collision (the addresses are sometimes called synonyms}. The best choice for a hashing
aigorithm is one that spreads the addresses most evenly and minimises the number of
collisions. However, collisions cannot be avoided altogether so there has to be a detinec
method for dealing with collisons. There are a number of options, including the following:

e«   useasequential search to look fora vacant address following the caiculated one

*    keep a number of overflow addresses at the end of the    file




Once a file organisation has been chosen and the data has been entered into a file, you need
to consider how this data is to be accessed. For a serial file, the normal usage is to reac the
whole file record by record. lf there was a need to search for a particular vaiue in one ofthe
fields, the only option would be to read the records from the beginning until the target record
was found. if the data is stored in a sequential file and a particular vaiue is needed, searching
may have to be done in the same way. However, if the key field value is known for the record
containing the wanted cata, the process is faster because only key field values need te be
reac. For a direct-access file, the value in the key field is submitted to the hashing algorithm.
The value is the same value that was used when entering the data originally and will provide
the same vaiue for the position in the file that was provided when the algorithm was used at
the time of data input. This eliminates the need to reac records frorn the beginning ofthe file.
However, because of the collision probiern some serial searching might be needed after the
initial jump to the hashed position.



method is used as when a new record was added. Records are copied from the old file to a
new file until the record that needs to be deleted or edited is reached. Following deletion or
editing ail remaining records are copied to the new file.

Fora cirect-access file there is no neec to create a new file. fa record needs eciting it can
be accessed directly anc edited without disturbing any other content. However, if a record
Cambridge International AS & A Level Computer Science




is to be deleted it is necessary to have a flag set in the record. Then, in a subsequent reading
process, that record is skipped over.



Choice of file organisation
Serial file organisation is well suited to batch processing or for backing up data on magnetic
tape. A direct access file is used if rapid access to an individual record in a large file is
required. An example would be on a system with many users. In this case, the file that is used
to check passwords when users log in should be direct-access. A sequential file is suitable
for applications when multiple records are required from one search of the file. An example
could be a family history file where a search could be used for all records with a particular
family name.

At this point it is worth mentioning the difference between key fields in a file and primary
keys in a database table. In the database table the primary key values must all be unique.
This is not a requirement for key fields in any type of file. It may be sensible in certain
applications to ensure key fields have unique values, but it is not mandatory.



16.03 Real numbers
Areal number is one with a fractional part. When we write down a value for a real number in
the denary system we have a choice. We can use a simple representation, or we can use an
exponential notation (sometimes referred to as scientific notation). For example, the number
25.3 might be written as:

                         253 x 10? or 2.53 x 10! or 25.3 x 10° of 253 x 107+

For this number, the simple expression is best. But ifa number is very large or very small the
exponential notation is the only sensible choice.



Floating-point and fixed-point representations
A binary code must be used for storing a real number in a computer system. One possibility
is to use a fixed-point representation. In fixed-point representation, an overall number of bits
is chosen with a defined number of bits for the whole number part and the remainder
                                                                               for the
fractional part. The alternative is a floating-point representation. The format for a floating-
point number can be generalised as:

                                               +M
                                                x RE

In floating-point representation a defined number of bits are used for what is called the
significand or mantissa, +M. The remaining bits are used for the exponent or exrad, E. The
radix, R is not stored in the representation; R has an implied value of 2.


— re
   Floating-point representation: a representation of real numbers that stores a value for the mantissa
   and a value for the exponent



A simple example can be used to illustrate the differences between the two representations.
Let’s consider that a real number is to be stored in eight bits.
                                                                                          Part 3: Chapter 16: Data representation




For the fixed-point option, a possible choice would be to use the most significant bit as a
sign bit and the next five bits for the whole number part. This would leave two bits for the
fractional part. Some important non-zero values in this representation are shown in Table
16.01. (The bits are shown with a gap to indicate the implied position of the binary point.)

    Description                                            Binary code            Denary equivalent
    Largest positive value                                  01111111                       31.75

 Smallest positive value                                    000000 01                         0.25

 Smallest magnitude negative value                          100000 01                      -0.25

    Largest magnitude negative value                        11111111                      -31.75


Table 16.01 Example fixed-point representations (using sign and magnitude)


A possible choice for a floating-point representation would be four bits for the mantissa and
four bits for the exponent with each using two’s complement representation. The exponent
is stored as a signed integer. The mantissa has to be stored as a fixed-point real value. The
question now is where the binary point should be.

Two of the options for the mantissa being expressed in four bits are shown in Table 16.02(a)
and Table 16.02(b). In each case, the denary equivalent is shown, and the position of the
implied binary point is shown by a gap. Table 16.02(c) shows the three largest magnitude
positive and negative values for integer coding that will be used for the exponent.

a                                       b                                   c

      First bit      Real value             Second bit | Real value             Integer bit          Integer
    pattern for | in denary                 pattern for | in denary              pattern             value in
    a real value                            a real value                                             denary
        0111                 3.5               0111             0.875              O111                  7

        0110                 3.0               0110             0.75               0110                  6

        0101                 2.9               0101             0.625              0101                  5

        1010             -3.0                  1010            -0.75               1010                 -6

        100 1            -3.5                  1001            -0.875              1001                 -f

        1000             -4.0                  1000            -1.0                1000                 -8


Table 16.02 Coding a floating-point real value in eight bits (four for the mantissa and four for
the exponent)

When the mantissa has the implied binary point immediately following the sign bit, a smaller
spacing is produced between the values that can be represented. This is the preferred option
for a floating-point representation. Using this option, the most important non-zero values for
the floating-point representation are shown in Table 16.03. (The implied binary point and the
mantissa exponent separation are shown by a gap.)

    Description                                        |      Binary code   |     Denary equivalent
    Largest positive value                                     01110111            0.875 x 2'= 112

    Smallest positive value                                    0 001 1000         0.125 x 2% = 1/2048

    Smallest magnitude negative value                          1111 1000         -0.125 x 2% = -1/2048

    Largest magnitude negative value                           1000 0111             -]1 x 2'=-128


Table 16.03 Example floating-point representations
Cambridge International AS & A Level Computer Science




The comparison between the values in Tables 16.01 and 16.03 illustrate the greater range of
positive and negative values available if floating-point representation is used.


Extension Question 16.02
a_   Using the methods suggested in Chapter 1 (Section 1.01) can you confirm for yourself that
     the denary equivalents of the binary codes shown in Tables 16.02 and Table 16.03 are as
     indicated?

b    Can you also confirm that conversion from positive to negative (or the conversion
     from negative to positive) for a fixed-format real value still follows the rules defined in
     Chapter 1 (Section 1.02) for two’s complement representation?


Precision and normalisation
You have to decide about the format of a floating-point representation in two respects. You
have to decide the total number of bits to be used and decide on the split between those
representing the mantissa and those representing the exponent. In practice, a choice for the
total number of bits to be used will be available as an option when the program is written.
However, the split between the two parts ofthe representation will have been determined
by the floating-point processor. If you did have a choice you would base your decision on
the fact that increasing the number of bits for the mantissa would give better precision for
a value stored but would leave fewer bits for the exponent, which reduces the range of
possible values.

To achieve maximum precision you have to normalise a floating-point number. (This
normalisation is unrelated to the process associated with designing a database.) Precision
increases with an increasing number of bits for the mantissa, so optimum precision will only
be achieved if full use is made of these bits. In practice, that means using the largest possible
magnitude for the value represented by the mantissa.

To illustrate this, we can consider the eight-bit representation used in Table 16.03. Table 16.04
shows possible representations for denary 2 using this representation.

           Denary representation                     Floating-point binary representation
                   0.125 x 24                                        0 001 0100

                   0.25 x 2°                                         0010 0011

                   0.5 x 2?                                          0 100 0010


Table 16.04 Alternative representations of denary 2 using four bits each for mantissa and exponent


For a negative number we can consider representations for —4 as shown in Table 16.05.


           Denary representation                     Floating-point binary representation

             —0,25 x 24                                             11100100

             -0.5 x 2°                                              1100 0011

             -1.0 x 2?                                              1 000 0010


Table 16.05 Alternative representations of denary —4 using four bits each for mantissa and exponent


When the number is represented with the highest magnitude for the mantissa, the two
most significant bits are different. This fact can be used to recognise that a number is in a
normalised representation. The values in Tables 16.03 and 16.04 also show how a number
                                                                                            ek




could be normalised. For 2 positive number, the bits in the mantissa are shifted let untit
the most significant bits are 0 followed by 1. For each shift left the value of the exponent is
reduced by 1.

The same pracess of shitting is usec for a negative number until the most significant bits are
i followed by 0. In this case, no attention is paid to the fact that bits are falling of the most
significant end of the mantissa.
     oe




                                    eat




                                     Mw        re)              WATE VARED rye ADOVS PHSCUSSIG   :   ¥




eons
                                          st



CLOPVersinn ©
          sonar   tones   @   ore   eyeeadinere




                              PSP   SARL SS

In Chapter i (Section 1.01), a number of methods for converting numbers into diferent
representations were discussed. These only considerec integer values, We now need to
consider the conversion of real                numbers.

We can start by considering the conversion of a simple real number, such as 4.75, into a
sirnpie fixed-point binary representation. This looks easy because 4 canverts to 100 in binary
and .75 converts to .11in binary so the binary version of 4.75 should be:

                                                          LOO.11

However, rermember that a positive                   number should start with 0. Can we just add a sign bit?




For negative numbers we still want to use two’s complement form. Sa, to find the
representation of -4.75 we can start with the representation for 4.75 then convert it to two’s
complement as follows:

                                O100.11 converts to 1011.00 in one’s complement
                                Tt4




                                      then to 1G11.01 in two's complement

Fo check the result, we can apply Method 2 from Worked Example 1.01 in Chapter 1. 1011 is



We can now consider the conversion of a denary value expressed as a real number into a
floating-pcint binary representation. Before considering the conversion method it should
be remembered that most fractional parts do not convert to a precise representation. This
is because the binary fractional parts represent a half, a quarter, an eighth, a sixteenth andl
sc on. Unless a denary fraction is a sum ofa collection of these vaiues, there cannot be
an accurate conversion. In particular, of the values from .1 through to .9, only .5 converts
accurately. This was mentioned in Chapter 1 (Section 1.03} in the discussion about storing
currency values.

The method for conversion of 4 positive value is as follows.

    Convert the whole-number part using the method described in Chapter 7 (Section 1.01).

    Add the 0 sign bit.

    Convert the fractional part choosing a method from one of the exampies in Worked
    Example 16.01.

4   Combine the whole number and fractional parts and enter these inte the most significant
    of the bits allocated for the representation of the mantissa.
Cambridge International AS & A Level Computer Science




5       Fill the remaining bits for the mantissa and the bits for the exponent with zeros.

6    Adjust the position of the binary point by changing the exponent value to achieve a
        normalised representation.

To convert a negative value the number is treated initially as positive and the same first five
steps are followed. At this stage a two’s complement conversion of the mantissa code is used
to convert this to a negative value before step 6 is carried out.


    WORKED EXAMPLE 16.01


    Converting a denary value to a floating-point representation


    Example 1

    Let’s consider the conversion of 8.75.

    1     The 8converts to 1000, adding the sign bit gives 01000.

    2     The.75 can be recognised as being .11 in binary.

    3     The combination gives 01000.11 which has exponent value zero.

    4     Shifting the binary point gives 0.100011 which has exponent value denary 4.

    5     Thenext stage depends on the number of bits defined for the mantissa and the exponent; if
          ten bits are allocated for the mantissa and four bits are allocated for the exponent the final
          representation becomes 0100011000 for the mantissa and 0100 for the exponent.


    Example 2

    Let’s consider
                the conversion of 8.63. The first step is the sare but now the .63 has to be converted by
    the ‘multiply by two and record whole number parts’ method. This works as follows:

                                 .63 X 2= 1.26 so 1 is stored to give the fraction .1

                                 .26 X 2=.52 So 0 is stored to give the fraction .10

                                 52 X 2= 1.04sS0 1 is stored to give the fraction .101

                                 04 X 2 = .08 so O is stored to give the fraction .1010

    At this stage it can be seen that, multiplying .08 by 2 successively is going to give a lot of zeros in the
    binary fraction before another 1 is added so the process can be stopped. .63 has been approximated
    as .625. So, following Steps 3-5 in Example 1, the final representation becomes 0100010100 for the
    mantissa and 0100 for the exponent.




    TASK 16.01

    Convert the denary value —7.75 to a floating-point binary representation with ten bits
    for the mantissa and four bits for the exponent. Start by converting 7.75 to binary
    (make sure you add the sign bit!). Then convert to two's complement form. Finally,
    choose the correct value for the exponent to leave the implied position of the binary
    point after the sign bit. Convert back to denary to check the result.




Problems with using floating-point numbers
As illustrated above, the conversion of
                                      a real value in denary to a binary representation
almost guarantees a degree of approximation. There is also a restriction of the number of
bits used to store the mantissa.
                                                                                Part 3: Chapter 16: Data representation




Floating-point numbers are used in extended mathematical procedures involving repeated
calculations. For example, in weather forecasting using a mathematical model of the
atmosphere, or in economic forecasting. In such programming there is a slight approximation
in recording the result of each calculation. These so-called rounding errors can become
significant if calculations are repeated enough times. The only way of preventing the errors
becoming a serious problem is to increase the precision of the floating-point representation
by using more bits for the mantissa. Programming languages therefore offer options to work
in ‘double precision’ or ‘quadruple precision’.

The other potential problem relates to the range of numbers that can be stored. Referring
back to the simple eight-bit representation illustrated in Table 16.03, the highest value
represented is denary 112. Acalculation can easily produce a value higher than this. As
Chapter 1 (Section 1.02) illustrated, this produces an overflow error condition. However,
for floating-point values there is also a possibility that ifa very small number is divided by
a number greater than 1 the result is a value smaller than the smallest that can be stored.
This is an underflow error condition. Depending on the circumstances, it may be possible for
a program to continue running by converting this very small number
                                                                 to zero but this must
involve risk.




   Summary




Reflection Point:
Whenever you are asked to create a binary representation from a denary value or vice-versa
are you always checking your answer by converting it back to the original value?
Cambridge International AS & A Level Computer Science




Exam-style Questions

1   Aprogrammer may choose to use a user-defined data type when writing a program.

    a        Give an example ofa non-composite user-defined data type and explain why its
             use by a programmer is different to the use of an in-built data type.                                              [3]

    b        Aprogram is to be written to handle data relating to the animals kept in a zoo.
             The programmer chooses to use a record user-defined data type.

             i        Explain what a record user-defined data type is.                                                          [2]

             ii       Explain the advantage of using a record user-defined data type.                                           [2]

             iii      Write pseudocode for the definition ofa record type which is to be used to store:
                      animal name, animal age, number in zoo and location in the zoo.                                           [5]

2   a_       Abinaryfileis to be used to store data fora program.

             i        State the terms used to describe the components of such a file?                                           [2]

             ii       Explain the difference between a binary file and a text file.                                             [3]

    b      = Abinary file might be organised for serial, sequential or direct access.

             i        Explain the difference between the three types of file organisation.                                      [4]

             ii       Give an example of file use for which a serial file organisation would be suitable.

                      Justify your choice.                                                                                      [3]

             iii      Give an example of file use when direct access would be advantageous.

                      Justify your choice.                                                                                      [3]

3 A file contains binary coding. The following are four successive bytes in the file:

           10010101             00110011                               11001000                   00010001




    a___     The four bytes represent two numbers in floating-point representation. The first byte in
             each case represents the mantissa. Each byte is stored in two’s complement representation.

             i        Give the name for what the second byte represents in each case.                                           [1]

             ii       State whether
                                 the representations are for two positive numbers or two negative
                      numbers and explain why.                                                                                  [2|

             iii      ~Oneof the numbers is in a normalised representation. State which one it is
                      and give the reason why.                                                                                  [2]

             iv       State where the implied binary point is in a normalised representation and explain
                      why a normalised representation gives better precision for the value represented.                         [3]

             v___|f   two bytes were still to be used but the number of bits for each component was
                      going to be changed by allocating more to the mantissa, state what effect this would
                      have on the numbers that could be represented. Explain your answer.                                       [2]

    b         Using the representation described in part a, give the representation of denary
             12.43 as a floating-point binary number.                                                                           [5]

4   a        Aparticular programming language allows the programmer
                                                                  to define their own data types.

             ThisDate is an example of a user-defined structured data type.

             TYPE      ThisDate

                      DECLARE   ThisDay          :    (1,   2,    3,   4,    5,   6,    7,   8,    9,   10,   11,   12,   13,

                                                      14,   15,    16,      17,   18,    19,      20,   21,   22,   23,

                                                      24,   25,    26,      27,   28,    29,      30,   31)
                                                                                          Part 3: Chapter 16: Data representation




                DECLARE   ThisMonth        :      (Jan,    Feb,    Mar,    Apr,   May,   Jun,   Jul,   Aug,

                                                 Sep,     Oct,    Nov,    Dec)

                DECLARE   ThisYear_        :      INTEGER

          ENDTYPE


    A variable of this new type is declared as follows:

          DECLARE    DateOfBirth      :   ThisDate

          i     Namethe non-composite data type used in the ThisDay and ThisMonth declarations.




                                                                                                                       a
                                                                                                                      =
          ii    Name the data type of ThisDate.




                                                                                                                       a
                                                                                                                      —_
          iii   The month value of DateofBirth needs to be assigned to the variable
                MyMonthoOfBirth.

                Write the required statement.                                                                        (1]

    b = Annual rainfall data from a number of locations are to be processed in a program.

          The following data are to be stored:

          e     location name

          e     height above sea level (to the nearest metre)

          e — total rainfall for each month ofthe year (centimetres to 1 decimal place).

          A user-defined, composite data type is needed. The programmer chooses LocationRainfall
          as the name of this data type.

          A variable ofthis type can be used to store all the data for one particular location.

          i     Write the definition for the data type LocationRainfall.                                             [5]

          ii    The programmer decides to store all the data ina           file. Initially, data from 27 locations
                will be stored. More rainfall locations will be added over time and will never
                exceed 100.

                The programmer has to choose between two typesof file organisation. The two
                types are serial and sequential.

                Give two reasons for choosing serial file organisation.                                              [2]

                                          Cambridge International
                                                               AS & A Level Computer Science 9608 paper 31 Q3 June 2015

5   In a particular computer system, real numbers are stored usingfloating-point
    representation with:

    e     8bits for the mantissa

    e     8 bits for the exponent

    e   — two’s complement form for both mantissa and exponent.

    a     Calculate the floating point representation of +3.5 in this system. Show your working.

                       Mantissa                                                   Exponent


         °                                                                                                           [3]
    b = Calculate the floating point representation of -3.5 in this system. Show your working.

                       Mantissa                                                   Exponent

         ;
Cambridge International AS & A Level Computer Science




  c — Find the denary value for the following binary floating-point number. Show your working.

                    Mantissa                                           Exponent

      0@1      1     1    0     0     0     0           0    0     0    0     0     1     0    0
  d    i    State whether the floating-point number given in part (c) is normalised or not
            normalised.




                                                                                                              a
                                                                                                             YE
       ii   Justify your answer given in part (d)(i).




                                                                                                             bh
  e    Give the binary two’s complement pattern for the negative number with the largest
       magnitude.

                    Mantissa                                           Exponent


       °                                                                                                    [2]
                               Cambridge international
                                                    AS &A Level Computer Science 9608 paper 32 Ql November 2016
Chapter 17:
Communication and Internet technologies

By the end of this chapter you should be able to:

m   show understanding of circuit switching                  m   show understanding of the TCP/IP protocol suite
m   show understanding of packet switching                   m   show understanding of protocols (HTTP, FTP, POP3, IMAP,
m   show understanding of why a protocol is essential for        SMTP, BitTorrent) and their purposes.
    communication between computers
m   show understanding of how protocol implementation
    can be viewed as a stack, where each layer has its own
    functionality
Cambridge International AS & A Level Computer Science




17.01 Transmission modes
For communication over an internetwork there are two possible approaches: circuit
switching or packet switching.


Circuit switching
Circuit switching is the method used in the traditional telephone system. Because the Public
Switched Telephone Networks (PTSNs) have now largely converted to digital technology,
the same method can be provided for data transfer that was traditionally used for voice
communication. In Chapter 2 (Section 2.06) the concept of support for Internet usage by a PTSN
was introduced. Typically, this is provided in a leased line service. The concept is illustrated in
Figure 17.01, which shows end-systems connected to local exchanges which have a switching
function and which are connected via a number
                                         of intermediate nodes with a switching function.




                                         |                   £
                 geobe




                                                                           ere”
          on                —o
                                    aN
                                   /|              ‘0
                                                                                |_

 Figure 17.01 Circuit-switched data transmission


For data transfer
                to take place, the following has to happen.

       The sender provides the identity of the intended receiver.
WNEF




       The system checks whether or not the receiver is ready to accept data.

       If the receiver is available, a sequence of links is established across the network.
bh




       The data is transferred.

5      The links are removed.

It is not necessary for this discussion to define what could constitute a node in a circuit-
switched network. The links that are provided between the nodes are dedicated channels in
shared transmission media that guarantee unimpeded transmission. When a telephone call
has finished there is a definite end to the call with removal ofthe links. However, for a leased-
line data connection there might be a permanent circuit established.


Packet switching
The packet-switching method allows data transmission without a circuit being established.
Data cannot be sent in a continuous stream. Instead data is packaged in portions inside
packets. A packet consists of a header which contains instructions for delivery plus the data
body. The method is similar
                          to that used by the postal service but rather more complex! The
network schematic shown in Figure 17.01 is still appropriate to describe packet switching
except that the links used are not defined at the time a packet is transmitted by the sender.
Furthermore, the nodes will have an extended functionality compared to that required in a
circuit-switched transmission. How a router acts as a node and supports packet switching is
discussed in Section 17.04.

When packet switching is used, there are two ways that the network can provide a service:
connectionless service or connection-oriented service. If a connectionless service is
provided, a packet is dispatched with no knowledge of whether or not the receiver
is ready to accept the packet, and has no way of finding out if the transmission has
                                                         Part 3: Chapter 17: Communication and Internet technologies




succeeded. In a connection-oriented service the first packet sent includes a request for
an acknowledgement. If the acknowledgement is received, the sender transmits further
packets. If no acknowledgement is received, the sender tries again with the first packet.


17.02 Protocols
The basic definition of a protocol is simple — it is a set of rules. So, what do these rules relate
to? Before answering, it should be understood that we often talk about ‘a protocol’ when
we are referring to a protocol suite which contains more than one individual protocol. The
complexity of networking requires many individual protocols. A further complication is that
there might be a number of different versions of a protocol. Finally, there are often protocols
that can be used to complement the use of another protocol.


   KEY TERM




The set of rules that constitute a protocol must be agreed between the sender and the receiver
for any communication transmitted overa network. At the simplest level, a protocol could define
that a positive voltage represents a bit with value 1. A protocol might define a transmission
speed that a sender must not exceed. Many ofthe rules relate to the format ofa message or of a
component ofa message. For example, a definition of the format of the first
                                                                          40 bytes in a packet.



17.03 A protocol stack
For a protocol suite the protocols can be viewed as layers within a protocol stack. There are a
number of aspects relating to this concept.

   Each layer can only accept input from the next higher layer or the next lower layer.

   There is a defined interface between adjacent layers which constitutes the only
   interaction allowed between layers.

   A layer is serviced by the actions of lower layers.

   With the possible exception of the lowest layer the functioning of a layer is created by
   installed software.
   A layer may comprise sub-layers.

   Any user interaction will take place using protocols associated with the highest level layer
   in the stack.

   Any direct access to hardware is confined to the lowest layer in the stack.


17.04 The TCP/IP protocol suite
TCP/IP is the protocol suite underpinning Internet usage. TCP/IP can be explained on the
basis of the network model shown in Figure 17.02. It can be seen that TCP/IP only occupies
the top three layers ofthis model.




    TIP

    Unfortunately there are different names used for two ofthe layers. Figure 17.02 shows the
    Network layer and the Data link layer. In some sources these will be named as the Internet layer
    and the Link layer.
Cambridge International AS & A Level Computer Science




    [Application|-« - - - - -- Logical peer-to-peer relationship - ---- »[Application]
           | <.                    Identical messages                     >|
                                                                                         TCP/IP
    | Transport j«------ Logical peer-to-peer relationship ----- >| Transport | >— protocol
                                                                                         suite
              <<.                  Identical packets                      >




Protocol stack for                   Protocol stack                Protocol stack for
one end-system                         for a router               another end-system


Figure 17.02 A network model relating to the TCP/IP protocol suite


There are two end-systems and the diagram shows the logical connections between
corresponding layers in these two systems. An application can run on one end-system and
behave as though there was a direct connection with an application running on a different
end-system. The application layer protocol on the sender end-system sends a ‘message’ to
the transport layer protocol on the same system. The transport layer protocol then initiates
a process which results in the identical ‘message’ being delivered to the receiver end-system.
On the receiver end-system, the final stage is the transport layer protocol delivering the
‘message’ to the application layer protocol.

The TCP/IP suite comprises a number of protocols, including the following:

e     application layer: HTTP, SMTP, DNS, FTP, POP3, IMAP

e     transport layer: TCP, UDP, SCTP

e     network layer: IP, IGMP, ICMP, ARP.

The selection has been chosen to illustrate that the TCP/IP suite encompasses a very wide
range of protocols that is still evolving. Some of the listed protocols will not be considered
further.



TCP (Transmission Control Protocol)
lf an application is running on an end-system where a ‘message’ is to be sent to a different
end-system the application will be controlled by an application layer protocol as described
above. The protocol will transmit the user data to the transport layer. The TCP protocol
operating in the transport layer now has to take responsibility for ensuring the safe delivery
of the ‘message’ to the receiver. The TCP protocol creates sufficient packets to hold all of the
data. Each packet consists of a header plus the user data.
                                                                                                     .




As well as ensuring safe delivery, TCP has te ensure that any response is directed back to
the application protocel. Sc, one item in the heacler is the port number which identifies the
application layer protocol. Far exarnpie, for HTTP the port number is 80. The packet must
aiso include the port number for the application layer protocol at the receiving end-system.
However, TCP is not concerned with the address of the receiving end-system. if the packet is
one of a sequence, a sequence number is included to ensure eventual correct reassembly of
the user data.




the network layer returns an acknowledgement to the Transport layer indicating that the




     igyfarset
     SS SLATE ESAS


The function of the network layer, and in particular of the IF, is to ensure correct routing over
the Internet. To co this the IP protocal takes the packet received from the transport layer


receiver, To find the IP address of the receiver, it is very likely to use the DNS service to fing


in some detail in Chapter2 (Section 2.09).                                                               se
                            ty




rhe IP packet, which is usually called a ‘datagram’, is sent to the cata-link layer anc therefore    |
to a different protocoi suite. The data-link layer assembies datagrams into ‘frames’ as
discussed in the next section of this chapter. Once the IP packet has been sent to the data-
link layer, IP has ne further duty. iP functions as a connectioniess service. Once a packet
has been sent, |P wiilhave no knowledge of whether or not it reached its destination. if1P
receives a packet which contains an acknowledgement of a previously sent packet, it will
simply pass the packet on te TCP with no awareness of the content.


SRBene
S SYS     rug
         SSE  okey
               OS
ESSE FESS gees

As Figure 17.02 shows, the frame sent by the data-link layer will arrive at a router during
transmission (more likely at several routers). At this stage, the datagram content of the frame
is given back to IP. It is now the function of the router software to choose the next target hos
in the transmission. The software has access to a routing table appropriate to that router. The
size and cornplexity of the internet prohibits a router frorn having a giobal routing table. Once
the appropriate address has been inserted into the datagram, IP passes it back to the data-
link layer of the router.

The routing table for every router has details of any current problerns with any of the options
for the next transmission step. This ensures that packets are delivered to their destination in
the shortest possible time available.

Fhe major distinction between a switch anc 2 router as a node in a network is that when a
frame arrives at a switch, it is transmitted on without any routing cecision, A switch operates
in the data-link layer but has no access to the network layer.
Cambridge International AS & A Level Computer Science




17.05 The Ethernet protocol stack
As discussed in Chapter
                      2 (Section 2.05), Ethernet is a protocol suite designed for use in a
local area network (LAN). As such it can function in an isolated LAN with no connection to
the Internet or any other network. However, it is now almost inevitable that a LAN will be
connected to the Internet and, therefore, a LAN’s protocol suite will support the protocol
suite in use for the Internet.

lf we look at the protocol stack for one end-system, as shown in Figure 17.02, we can see that
the TCP/IP protocol suite occupies the top three layers of the five-layer stack and is therefore
supported by the lower two layers. TCP/IP has no concern with the functioning of these
two lower layers; it is designed to be capable of being supported by whatever protocols are
available. It should be noted that some sources only use a four-layer stack for an end-system.
This is either a decision to only include layers that are handled entirely by software. Or itis a
decision to amalgamate all of the support for TCP/IP into one layer.

Ethernet is the most likely protocol to be used to provide the functionality required of the
two lower layers. Logically the Ethernet suite can be viewed as comprising two sub-layers for
each ofthe Data link and Physical layers. This is illustrated in Figure 17.03.




Figure 17.03 The sub-layers of Ethernet


The following points explain how Ethernet functions when supporting TCP/IP.

e   The Logical Link Control (LCC) protocol is responsible for the interaction with the Network
    layer. It manages data transmissions and ensures the integrity of data transmissions.
    However, because Ethernet is a connectionless protocol it has no responsibility for
    checking that a transmission has been successfully delivered.
e   The Medium Access Control (MAC) protocol is responsible for assembling the Ethernet
    packet which is referred to as a frame. Two components of this are the address of the
    transmitter and the address ofthe receiver. In addition the MAC protocol initiates frame
    transmission and handles recovery from transmission failure due to a collision (possibly
    using CSMA/CD).

    The Physical Coding Sublayer (PCS) protocol is responsible for coding data ready for
    transmission or decoding data received. It either receives a frame from the MAC protocol
    orsends one to it.

    The Physical Medium Attachment (PMA) protocol is responsible for signal transmitting
    and receiving.
                                                    Part 3: Chapter 17: Communication and Internet technologies




MAC addresses
Both addresses in the Ethernet frame are examples of what are called physical or MAC
addresses. A MAC address is the one which uniquely defines one NIC, as described in
Chapter 2 (Section 2.04).

The reason that unique addresses have so far been guaranteed is that the 48 bits used for
the definition have given a sufficient number ofdifferent addresses. However, there is a 64-bit
alternative which is already used occasionally but is available for future use when 48 bits are
insufficient. The 48-bit address is usually written in hexadecimal notation, for example:
                                        4A:30:12:24:1A:10

In one version ofthis addressing scheme the first three bytes identify the manufacturer.


17.06 Application-layer protocols associated with TCP/IP
There are very many application-layer protocols. This discussion considers some that are
used most often.


HTTP (HyperText Transfer Protocol)


    TIP

    Be careful not to confuse HTTP and HTML.



Because HTTP (Hypertext Transfer Protocol) underpins the World Wide Web it has to be
considered to be the most important application-layer protocol. Every time a user accesses a
website using a browser, HTTP is used but its functionality is hidden from view.

HTTP is a transaction-oriented, client-server protocol. The transaction involves the client
sending a ‘request’ message and the server sending back a ‘response’ message. The HTTP
protocol defines the format of the message. The first line of a request message is the ‘request
line’. Optionally this can be followed by header lines. All of this uses ASCII coding. The format
of the request line is:

<Method>    <URL>    <Version>CRLF

where CR and LF are the ASCII carriage return and line feed characters. The request line
usually has GET as the method. However, there are several alternatives to the GET method
which makes HTTP potentially a more widely applicable protocol than just being used for
webpage access. The version has to be specified because HTTP has evolved so there is more
than one version in use.


Email protocols
The traditional method of sending and receiving emails is illustrated in Figure 17.04 which
shows that three, individual, client-server interactions are involved. The email sender acting
as a client has a connection to a mail server. This server then has to function as a client in the
transmission to the mail server used by the email receiver acting as a client.
Cambridge International AS & A Level Computer Science




 PE
                                    Sous,

Email                 Mail                            Mail                      Email
sender     SMTP                       SMTP                           POP3     receiver
 :                   server                          server                      :
client                                                                         client


Figure 17.04 An email message being transmitted from a sender
                                                            to a receiver


Of the two protocols shown being used, SMTP (Simple Mail Transfer Protocol) is a ‘push’
protocol whereas POP3 (Post Office Protocol version 3) is a ‘pull’ protocol. There is a more
recent alternative to POP3, which is IMAP (internet Message Access Protocol). The approach
using POP3 is for emails to be downloaded onto the client computer. With IMAP the emails
are not downloaded; they remain stored on the server but remain accessible from the client.
It can be argued that POP3 is more secure to cyber-attack because emails are locally stored.
However, the server will be backed up regularly whereas the local client might not be. The
major advantage for IMAP is that the server can be accessed from any client. This makes it
suitable for anyone on the move or if someone is using a system other than that normally
used. POP3 emails are only accessible from the one client system.

SMTP has been largely replaced by the use of web-based mail. A browser is used to access
the email application, so HTTP is now the protocol used. However, SMTP remains in use for
transfer between the mail servers.


Question 17.02
Which protocols are being used in your email system? Does your email system give you any
choices?



FTP (File Transfer Protocol)
For routine transfers of files from one user to another the most likely method is to attach the
file to an email. However, this is not always a suitable method. FTP (File Transfer Protocol) is
the application-layer protocol that can handle any file transfer between two end-systems. File
transfer is not simple if the end-systems have different operating systems with different file
systems. FTP handles this by separating the control process from the data-transfer process.


Question 17.03
If you were setting up a website, you would need to upload files to a server. Do you know how
you can use FTPfor this from the system you normally use?



17.07 Peer-to-peer (P2P) file sharing
The network traffic generated by peer-to-peer (P2P) file sharing is one of the main features
of Internet use. P2P is an architecture that has no structure and no controlling mechanism.
Peers act as both clients and servers and each peer is just one end-system. When a peer acts
as a server itis called a ‘seed’.
The BitTorrent protocol is the most used protocol because it allows fast sharing of files. There
are three basic problems to solve if end-systems are using BitTorrent.

1   How does a peer find others that have the wanted content?

    Every content provider should provide a content description, called a torrent, which
    is a file that contains the name of the tracker (a server that leads peers to the content)
    and alist of the chunks that make up the content. The torrent file is at least three orders
    of magnitude smaller than the content so can be transferred quickly. The tracker is a
    server that maintains a list of all the other peers (the ‘swarm’) actively downloading and
    uploading
           the content.

2   How do peers replicate content to provide high-speed downloads for everyone?

    Peers download and upload chunks at the same time, but peers have to exchange lists
    of chunks and aim to download rare chunks for preference. Each time a rare chunk is
    downloaded it automatically becomes less rare!

3   How do peers encourage other peers to provide content rather just using the protocol to
    download for themselves?

    This requires dealing with the free-riders or ‘leechers’ who only download. The solution
    is for a peer to initially randomly try other peers but then to only continue to upload
    to those peers that provide regular downloads. Ifa peer is not downloading or only
    downloading slowly, the peer will eventually be isolated or ‘choked’.

It is worth noting that the language of BitTorrent is quite unusual and there are other terms
used which have not been mentioned. Fortunately, the principles are straightforward.




Reflection Point:
Networking is a large subject area with many interconnected concepts. Have you considered
how you might make some structured notes to help with revision later?




    m   Circuit switching requires a dedicated circuit to be established between sender and receiver before
        transmission can start.

        In packet switching, packets can be transmitted without any circuit being created.

        Packet switching can use connectionless or connection-oriented transmission.

        A protocol suite is implemented as a layered stack.

        The TCP/IP protocol suite supports usage of the Internet.

        Ethernet is the most likely option for use in the Network and Data link layers.

        Examples of application-layer protocols are HTTP, SMTP, POP3, IMAP and FTP.

        Peer-to-peer file sharing on the Internet uses the BitTorrent protocol.
      Cambridge International AS & A Level Computer Science




      Exam-style Questions

      1   The following represents the structure of an IP datagram.

          |            IP Header           |      TCP Header                 TCP Content

              Using the code IP for IP Header, TCP for TCP Header and Content for TCP Content identify where the
          following data will be found:

          a        Destination address                                       d   = Sender port

          b      = Sender address                                            e      Packet sequence number

          c        Destination port                                          f      Acknowledgement.                [6]

      2       Ethernet can be used in conjunction with the TCP/IP protocol suite.

          a        Drawadiagram to illustrate how the combination of Ethernet and the TCP/IP suite
                   provides support for data communication.                                                         [5]

          b        Explain the meaning of the term ‘MAC address’.




                                                                                                                    3
      3   Oneend-system with an Internet connection has a file. A user on another end-system
          connected to the Internet needs a copy of the file. There are different methods that might
          be used to enable the user to obtain a copy of the file.

          a __ Identify three possible methods with a brief explanation for each.                                   [6]

          b        Identify the application-layer protocols that each method will use with a brief explanation
                  for each one.                                                                                     [8]
      4   Forsending and receiving emails the following application protocols might be used:

ost       SMTP
          POP3

          IMAP

          HTTP

          For each of these protocols give a brief explanation as to how they might be used in association
          with an email application. You might find it useful to include a diagram for some of your account.       [12]

      5   a_       Fourdescriptions and three protocols are shown below.

                   Draw a line to connect each description to the appropriate protocol.

                                         Description                                             Protocol used


                    email client downloads an email from an email                                    TTP
                    server




                    email is transferred from one email server
                                                             to
                                                                                                     POP3
                    another email server




                    email client sends email to email server                                        SMTP




                    browser sends a request for a web page to a
                    web server
                                                                                                                          [4]
    b    Downloading a tile can use the clent-server model. Alternatively, a file can be downloaded using
         the BitTorrent protecol.



    ¢    For the BitTorrent protocal, explain the function of each of the following:

         j     tracker                                                                                            [2

         He   8 seed                                                                                              (2)

         Hi   | swarm                                                                                             [2]

                                     Cambridge International AS & A Level Computer Science 9608 paper 31 G6 June 2015

6   Anemiailis sent from one email server
                                        to another usingpacket switching.

    @    State two items thal are containec in an email packet apartfrom the dat                                  el

    b    Explainthe role of routersin sendingan email fram one email server
                                                                         to another.                              [3]
    ¢    Sending an email message
                                is anappropriateuse of packetswitching

         Explain
             why this is the case.                                                                                [2]

    d=   Packet switching is not aiways an appropriate solution.

         Narne an alternative communication method oftransferring data in a digital network,                      -

    eé   Namean apptication for which the metnod identified in part (d) is an appropriate solution.
         Justify your choice.                                                                                     [3]
                                Cambridge international AS & A Level Computer Science 9608 paper
                                                                                               31 Q3 November 2015
                                                                                                                                                                 -_

                                                                                                                                                                                                       —                  -       -

                                                                                                                              ~                x             =                             =       =        =
                                                                                                 _

                                                                                            -—

                                               -                                                 =
                             =>
                                         =                                                       =                  se       =        =        -                                                       =        od            =~
                                                                                                         =      =            eS            =       =                  =                                =         —_               -
     —                              =>                                                               J           ~-      -                                                                                           “<           “=
                                         _—
         —
         =                                                           &


                                                                                                                                      —s                 oe                                            ———                    =
wi




                                                                                                                                  :        er                    o—.                   =       =       oo
                            a     —_
                        :   =      Ss    =~
                                                   —_——
                   =        =                          —_
                   as                              =                                    ~                                         ace               &£   eas                               —
               2            —_                     —         =                     _—
               .
                            —
                            —_
                                               = a               _                ee
                                                                                                                =                          se                ~            2
                                                       i
                                                            <=




     —             —                          —_                 =            =
                                                                         ee   Se    a




                   =              =                                           ~             —~
           =       =                           —_—               re                                                 =.                         —                                                   =                 =
                                                                                                                      —_               =                                          ea

                                        Ss                                    =
                                                                                    =
                                                                                   = a                                   ==                                                            =
                                  ~~                                 =


                                                                                                                                      _—                 o                    :                                  =
                                                                                                     —              =                              EO        a                             ss




         Chapter 18:
         Hardware and virtual machines


         By the end of this chapter you should be able to:

             show understanding of Reduced Instruction Set Computers                                     show awareness of the four basic computer architectures:
             (RISC) and Complex Instruction Set Computers (CISC)                                         SISD, SIMD, MISD, MIMD
             processors                                                                                  show understanding ofthe characteristics of massively
             show understanding ofthe importance/use of pipelining                                           parallel computers
             and registers in RISC processors                                                            show understanding ofthe concept of a virtual machine.
                                                                  Part 3: Chapter 18: Hardware and virtual machines




18.01 The control unit
While a program is being executed, the CPU is receiving a sequence of machine-code
instructions. It is the responsibility of the control unit within the CPU to ensure that each
machine instruction is handled correctly. There are two methods by which a control unit can
be designed to allow it to perform its function.

One method is for the control unit to be constructed as a logic circuit. This is called the hard-
wired solution. The machine-code instructions are handled directly by hardware.

The alternative method is for the control unit to use microprogramming. In this approach, the
control unit contains a ROM component that stores the microinstructions or microcode for
microprogramming, often referred to as firmware. In the next section we will see what might
influence the choice of design of the control unit.



18.02 CISC and RISC processors
A processor will have an architecture which refers to its physical construction. However, a
processor will also have what is termed an ‘instruction set architecture’,

This is concerned with:

e   theinstruction set

e   theinstruction format

e   the addressing modes

e   theregisters accessible by instructions.

The choice ofthe instruction set is the main factor in distinguishing one instruction set
architecture from another.

in the early days of computing a significant factor in choosing the instruction set architecture
for a computer was that it should make the writing of a compiler for a high-level language
easier. At that time the term did not exist, but we would now refer to this as being the
architecture for a Complex Instruction Set Computer (CISC) .

This philosophy began to be challenged in the late 1970s. It was argued that using a Reduced
Instruction Set Computer (RISC) would be a better approach. Table 18.01 contains a
number of features that distinguish RISC from CISC.


f KEY TERMS
Cambridge International AS & A Level Computer Science




    Fewer instructions                                    More instructions

    Simpler instructions                                  More complex instructions

    Small number of instruction formats                   Many instruction formats

    Single-cycle instructions whenever possible           Multi-cycle instructions

    Fixed-length instructions                             Variable-length instructions

    Only load and store instructions to address memory __| Many types of instructions to address memory

    Fewer addressing modes                                More addressing modes

    Multiple register sets                                Fewer registers

    Hard-wired control unit                               Microprogrammed control unit

    Pipelining easier                                     Pipelining more difficult


Table 18.01 Comparison of RISC with CISC


The following are some points to note.

e     For RISC the term ‘reduced’ affects more than just the number of instructions.

e     Areduction in the number of instructions is not the major driving force for the use of RISC.

e     Thereduction in the complexity of the instructions is a key feature of RISC.

e     The typical CISC architecture contains many specialised instructions.

e     The specialised instructions are designed to match the requirement of a high-level
      programming language.

e     The specialised instructions require multiple memory accesses which are very slow
      compared with register accesses.

e     Thesimplicity of the instructions for a RISC processor allows data to be stored in registers
      and manipulated in them with no resource to memory access other than that necessary
      for initial loading and possible final storing.

e     Thesimplicity of RISC instructions makes it easier
                                                       to use hard-wiring inside the control
      unit.

e     Thecomplexity of many of the CISC instructions makes hard-wiring much more difficult
      so microprogramming is the norm.


Extension Question 18.01
Can you find out whether the processors in any systems you are using are described as RISC
or CISC?



Pipelining
One of the major driving forces for creating RISC processors was the opportunity they would
provide forefficient pipelining. Pipelining is a form of parallelism applied specifically to
instruction execution. Other forms of parallelism are discussed in Section 18.03.


i
      Pipelining: instruction-level parallelism
                                                                      Part 3: Chapter 18: Hardware and virtual machines




The underlying principle of pipelining is that the fetch-decode-execute cycle described in
Chapter5 (Section 5.06) can be separated into a number of stages. One possibility is a five-
stage model consisting of:

                                                           Clock cycles

                                      1        2       3         4        5      6      7


      Instruction fetch (IF)         1.1      2.1     3.1       4.1       5.1   6.1    7.1


2 | Instruction decode (ID)                   1.2     2.2 | 32        | 42 | 52        6.2
5
k=

9 |   Operand fetch (OF)                              1.3       2.3       3.3   4,3    5.3
”



S
< |   Instruction execute (IE)                                  1.4       2.4   3.4    4.4


      Result write back (WB)                                              1.5   2.5    3.5


Figure 18.01 Pipelining for five-stage instruction handling


Figure 18.01 shows how pipelining would work with this five-stage breakdown of instruction
handling. For pipelining to be implemented, the construction of the processor must have
five independent units, with each handling one of the five stages identified. This explains the
need for a RISC processor to have many register sets; each processor unit must have access
to its own set of registers. Figure 18.01 uses the representation 1.1, 1.2 and so on to define the
instruction and the stage of the instruction. Initially only the first stage of the first instruction
has entered the pipeline. At clock cycle 6 the first instruction has left the pipeline, the last
stage of instruction 2 is being handled and instruction 6 has just entered.

Once under way, the pipeline is handling five stages of five individual instructions. In
particular, at each clock cycle the complete processing of one instruction has finished.
Without the pipeline the processing time would be five times longer.

One issue with a pipelined processor is interrupt handling. The discussion in Chapter
                                                                                    5 (Section
5.08) referred to a processor with instructions handled sequentially. This approach where a
check for any interrupt is made following the execution of an instruction is applicable to a CISC
processor. It would also be applicable to a RISC processor if there were no pipelining. However,
this is an unlikely circumstance. In the pipelined system described above there will be five
instructions in the pipeline when an interrupt occurs. One option for handling the interrupt is
to erase the pipeline contents for the latest four instructions to have entered. Then the normal
interrupt-handling routine can be applied to the remaining instruction. The other option is
to construct the individual units in the processor with individual program counter registers.
This option allows current data to be stored for all of the instructions in the pipeline while the
interrupt is handled.

Discussion Point:
Consider
      the two consecutive instructions:

ADD   R1,   R2,   R3


ADD   R5,   R1,   R4


These are typical three-register instructions favoured for RISC. The first adds the contents
of registers R2 and R3 and stores the result in Rl. The next instruction is similar but uses
Cambridge International AS & A Level Computer Science




the value stored in R1. In a pipelined structure, the second instruction will be reading the
contents of R1 before the previous instruction has placed the value there. How could this
potential problem be overcome?



18.03 The basic computer architectures
Awell-established approach to describing different computer architectures is to consider
                                                                                      the
number of instruction streams and the number ofdata streams. This leads to four different types.



Single Instruction Stream Single Data Stream (SISD)
SISD is the typical arrangement found in early computers which was also adopted for
the earliest microprocessors. The functioning is purely sequential with no parallelism.
Figure 18.02 illustrates how individual elements in an array are manipulated using SISD.

  Initial array             After the             After the             After the              After the
     with 4                    first              second                  third                 fourth
   elements                instruction           instruction          instruction          instruction

[4]3]2}i}x2> [4]3]2}2}>[4}s}4i2|> [4}6}4}2}>[sfef a2)
Figure 18.02 SISD sequential processing of array elements


The same instruction is used repeatedly to carry out the multiplication by two.



Single Instruction Stream Multiple Data Stream (SIMD)
SIMD can be considered as parallelism applied to the data stream. The difference when array
elements are processed is shown in Figure 18.03.


   One instruction
              ‘
         x2

         x2>

         x2>

         x2>


Figure 18.03 SIMD parallel processing of array elements



The architecture for SIMD is usually represented by a diagram such as Figure 18.04.


                  |       Instructions       |




        Data




Figure 18.04 Schematic representation of the SIMD architecture
                                                                        Part 3: Chapter 18: Hardware and virtual machines




In Figure 18.04 the structure shows four data streams entering four individual components
which are simultaneously supplied with the same instruction. The components are labelled PU
(Processing Unit). Sometimes the components are labelled PE (Processing Element). Whatever
name is used, the components are arithmetic logic units. One of the reasons for the different
names is that there are options for how this architecture could be implemented.




    TIP

    Be careful to distinguish between the pipelining of instructions where different instructions are
    executed in parallel and SIMD when only one instruction is being simultaneously executed on
    different data streams.



One option has been used in computers that are called array or vector processors. These
might have a parallel set of registers; one for each data stream. Alternatively, there would be
a large register, perhaps with 64 or 128 bits which could store four data values at the same
time. In this type of implementation, the parallelism is built into just one processor.

The alternative is the multi-core processor where four individual processors work in parallel.
In this case each processor is likely to have its own dedicated cache memory to provide the
data stream.


   KEY TERMS




Multiple Instruction Stream Single Data Stream (MISD)
MISD is not evidenced in any individual computer architecture design. One example where
the approach could be implemented would be ina             fault-tolerant system. The same data
stream could be fed into two or more processors. The output would only be accepted if the
same output was produced by all of the processors.


Multiple Instruction Stream Multiple Data Stream (MIMD)
The MIMD architecture is similar to that for the type of SIMD architecture shown in Figure
18.04 with more than one processing unit receiving the parallel data streams. The difference
is that each Processing unit does not execute the same instruction. The multiple data stream
can be provided by a suitably partitioned single memory. Each Processing Unit might have a
dedicated cache memory.



Massively parallel computer systems
The MIMD architecture can be implemented in multicomputer systems known as
massively parallel computers. These are the systems used by large organisations for
computations involving highly complex mathematical processing. They are the latest type of
‘supercomputer’. The major difference in architecture is that instead of having a bus structure
Cambridge International AS & A Level Computer Science




to support multiple processors there is a network infrastructure to support multiple
computer units. The programs running on the different computers can communicate by
passing messages using the network.

An alternative type of multicomputer system is cluster computing using PCs (sometimes
referred to as a ‘server farm’).

Whatever the technology used, these systems have an extremely large number of individual
processors working in parallel.


Extension Question 18.02
The IBM Sequoia and a Beowulf cluster are different examples of cluster computing. You
might wish to carry out some research to get some details of their computing power.



18.04 Virtual machines
A virtual machine is software not hardware. The most usual type ofvirtual machine is the
system virtual machine which is software that emulates the hardware of a real computer
system.



EEE
    System virtual machine: the emulation of computer system hardware using software



Remember that when a virtual machine is not being used an application program requires
support from an operating system in order
                                      for the program to run on the hardware. The
principle of a virtual machine is that a process interacts directly with a software interface
provided by an operating system. The logical structure for the operation ofa system virtual
machine is shown in Figure 18.05.


      Application programs for                      Application programs for
          virtual machine VM1                         virtual machine VM2
                   |                                             I
           Guest OS for VM1                             Guest OS for VM2

                   |                                             I
          Virtual machine VM1                         Virtual machine VM2

                                                                 |
                       Virtual-machine implementation software



                                      Host OS




                                   Host hardware


Figure 18.05 Logical structure for a system virtual machine implementation

The following points should be noted when looking at Figure 18.05.

1   The application programs are installed with the assistance of a guest OS. This guest OS
    will support
              the running application by interacting with the virtual machine as though it
    were the hardware that the guest OS would normally run on.
                                                                Part 3: Chapter 18: Hardware and virtual machines




2   The virtual machine implementation software can be considered to be a utility program
    which, when running, is supported by the particular host OS which is specific to the host
    hardware.

3   There can be application programs running at the same time directly on the host
    hardware under the control of the host OS.

The main advantage of the virtual machine approach is that more than one different
operating system can be made available on one computer system. This is particularly
valuable if an organisation has legacy systems and wishes to continue to use the old software
but does not wish to keep the old hardware. Alternatively, the same operating system can be
made available many times by companies with large mainframe computers that offer server
consolidation facilities. Different companies can be offered their own virtual machine running
as a server.


One drawback to using a virtual machine is the time and effort required for implementation.
Another drawback is the fact that the implementation will not offer the same level of
performance that would be obtained on a normal system.


Discussion Point:
Are there other advantages or disadvantages in using a system virtual machine?


The Java virtual machine discussed in Chapter 8 (Section 8.05) is an example of a process
virtual machine, based on a different underlying concept. The process virtual machine
provides a platform-independent programming environment that allows a program to
execute in the same way on any platform. This is specific software that only supports running
a Java program. A system virtual machine supports any application.


Reflection Point:
The description ‘virtual’ occurs in several places in this book. Are you clear about how these
different examples have their own specific context and meaning?




    Summary
      Cambridge International AS & A Level Computer Science




      Exam-style Questions

      1   a    Computer systems are now often constructed with RISC processors.

               i       State what the acronym RISC stands for.




                                                                                                                    —


                                                                                                                        a
                                                                                                                        i
               ii      State four characteristics to be expected of a RISC system.




                                                                                                                    ES
          b    ARISC processor is likely to be ‘hard-wired’.

               i        Explain what this term means and which specific part of the processor will be
                       hard-wired.                                                                                  [3]
               ii.     State what the alternative to hard-wiring is and what hardware component is
                       needed to be part ofthe processor
                                                      to allow this alternative to be implemented.                  [2]

      2   The following diagram represents a system which has implemented a virtual machine.

                     Application program 1                      Application program 2

                               i




                                                    D




348                                             Hardware


               For each of A, B, C, D give a suitable name.




                                                                                                                    ES
          b    Foreach of A, B, C and D give a brief description of the function of the feature.




                                                                                                                    "OO |
          c¢   Explain why the diagram is different for Application 2



                                                                                                                    N
      3   a    Parallelism can be achieved in a number of ways.

               i       _|dentify three different types of parallelism.                                              ics}

               ii.     —|dentify which type pipelining belongs to.
                                                                                                                    —


                                                                                                                        a
                                                                                                                    —




               iii     Using a diagram, explain how pipelining works.
                                                                                                                    Si}




          b = Interrupt handling is not so straightforward in a pipelined system. Explain why this      is

               so and give a brief account of how problems can be avoided.                                          [3]

      4   a_   Three descriptions and two types of processor are shown below.

               Draw a line to connect each description to the appropriate type of processor.
                           Description

                                                                                            Type   of   processor




                   Makes extensive use of
                                                                                                     RISC
                   general purpose registers



                     any addressing modes
                                                                                                    CISC
                   are available



                   Has a simplified set of
                   instructions                                                                                     3]
                                                                     Part 3: Chapter 18: Hardware and virtual machines




b       In a RISC processor three instructions (A followed by B, followed by C) are processed using pipelining.

    The following table shows the five stages that occur when instructions are fetched and executed.
    i       The “A” in the table indicates that instruction A has been fetched in time interval 1.

            Complete the table to show the time interval in which each stage of each instruction (A, B, C)
             is carried out.

                                                                     Time interval
                         Stage
                                                 1      2      3     4       5       6        7     8    9

                          Fetch instruction]     A

                        Decode instruction

                        Execute instruction

               Access operand in memory

                     Write result to register                                                                    [3]



    ii      Thecompleted table shows how pipelining allows instructions to be carried out more
             rapidly. Each time interval represents one clock cycle.

            Calculate how many clock cycles are saved by the use of pipelining in the above example.

            Show your working.                                                                                   [3]

                                 Cambridge International
                                                      AS & A Level Computer Science 9608 paper 31 Q4 November 2015

    The following diagram shows how applications X, Y and Z can run on a virtual machine system.

    |            Application X           |           Application Y       |               Application Z       |
                     ity                                    Ih
    |                      Guest operating system 1                              Guest operating system 2    |
                                       ity                                                    ity
    |                          Virtual machine software
                                                   / virtual machine monitor                                 |
                                                         ty
    |                                           Host operating system                                        |
                               t                                     v
    |                                                 Hardware                                               |

    i       Thevirtual machine software undertakes many tasks.

             Describe two of these tasks.                                                                        [2|

    ii       Explain the difference between a guest operating system and a host operating system.                [2]

    A company uses a computer as web server. The manufacturer will no longer support the
    computer’s operating system (OS) in six months time. The company will then need to
    decide on a replacement OS.

    The company is also considering changing the web server software when the OS is changed.

    Whenever any changes are made, it is important that the web server service is not disrupted.

        In developing these changes, the company could use virtual machines.

    i        Describe two possible uses of virtual machines by the company.                                      [4]

    The web server often has to handle many simultaneous requests.

    ii      Thecompany uses a virtual machine to test possible solutions to the changes that
            they will need to make.

             Explain one limitation of this approach.                                                            [2]

                                      Cambridge international
                                                           AS & A Level Computer Science 9608 paper 31 Q3 June 2016
350




      Logic circuits and Boolean algebra
      Learning objectives
      By the end of this chapter you should be able to:
         produce truth tables for logic circuits including half adders and full adders
         show understandingof a flip-flop (SR, JK)
         show understanding of Boolean algebra
         show understanding of Karnaugh Maps.
                                                                  Part 3: Chapter 19: Logic circuits and Boolean algebra




19.01 Logic circuits
Chapter
      4 introduced the symbols for logic gates that are used in logic circuits and discussed
the relationships between logic circuits, truth tables and logic expressions. This chapter
introduces some specific circuits that are used to construct components that provide
functionality in computer hardware.


The half adder
A fundamental operation in computing is binary addition. The result of adding two bits is
either 1 or 0. However, when 1 is added to 1 the result is 0 but there is a carry bit equal to 1.
This cannot be ignored if two numbers with several bits in each are being added.

The simplest circuit that can be used for binary addition is the half adder. This can be
represented by the diagram in Figure 19.01. The circuit takes two input bits and outputs a
sum bit (S) and a carry bit (C).

A——>|      1 bit       +——>
                          S
          half adder
                       -——>
                          C
B—>|      circuitry


Figure 19.01 A half adder


The truth table for this circuit is shown in Table 19.01.


                        Input                                          Output

            A                        B                        S                        C

             0                       0                        0                        0

             0                       1                        1                        0

             1                       0                        1                        0

             1                       1                        0                        1



Table 19.01 The truth table for a half adder


One possible circuit can be defined directly by examination ofthe truth table. It can be
seen that the only combination of inputs that produces a 1 for the carry bit is when two 1
bits are input. The truth table for the C output is in fact the AND truth table. The truth table
for the S output can be seen to match that for the XOR operator which is shown in Figure
4.02 in Chapter
              4 (Section 4.04). Therefore, one circuit that would produce the half adder
functionality would contain an AND gate and an XOR gate with each gate receiving input from
Aand B.

This is only one of several circuits that would provide the functionality. The NAND and
NOR gates are universal gates. Any logic circuit can be constructed using only NAND gates
or only NOR gates. This fact combined with the ease of manufacture ofthese gates leads
circuit manufacturers to prefer their use. The circuit shown in Figure 19.02 consisting only
of NAND gates has the correct logic to produce the C and S outputs and is a likely choice for
implementation.
Cambridge International AS & A Level Computer Science




                                     p=
A                    w

s_|             >—         >




                                     |

Figure 19.02 A half adder circuit constructed from NAND gates


Question 19.01
In Figure 19.02, can you identify the individual circuits that represent the AND operator and
the XOR operator?



      TASK 19.01

      Use the intermediate points labelled W, X and Y to construct a truth table for the
      circuit shown in Figure 19.02. Check that this reproduces the truth table shown as
      Table 19.01.




The full adder
If two numbers expressed in binary with several bits to be added, the addition must start
with the two least significant bits and then proceed to the most significant bits. At each
stage, the carry from the previous addition has to be incorporated into the current addition.
Ifa half adder is used each time, there has to be separate circuitry to handle the carry bit
because the half adder only takes two inputs.

The full adder is a circuit that has three inputs including the previous carry bit. The truth
table is shown as Table 19.02.


                               Input                                          Output

            A                   B                Cin                   S                 Cout

            0                    0                0                    0                     0

            0                    0                1                    1                     0

            0                    1                0                    1                     0

            0                    1                1                    0                     1

            1                    0                0                    1                     0

            1                    0                1                    0                     1

            1                    1                0                    0                     1

            1                    1                1                    1                     1



Table 19.02 The truth table for a full adder


One possible circuit for implementation contains two half adder circuits and an OR gate as
shown in Figure 19.03.
                                                               Part 3: Chapter 19: Logic circuits and Boolean algebra




Figure 19.03 A possible implementation of a full adder


      KEY TERMS




As before, it is possible to construct the circuit entirely from NAND gates as shown in
Figure 19.04.




                  Da
                                                             D-
Cin               we                               ‘Ds         |p Cout

Figure 19.04
           A full adder circuit constructed from NAND gates


Discussion Point:
Can you see how full adders could be combined to handle addition of, for example, four-bit
binary numbers? What happens to the carry input for the first addition?


19.02 Sequential logic circuits
All of the circuits so far encountered in this book have been combinational circuits. For such
a circuit the output is dependent only on the input values. An alternative type of circuit is a
sequential circuit where the output depends on the input and on the previous output.


| KEY TERMS




The SR flip-flop
The SR flip-flop or ‘latch’ is a simple example of a sequential circuit. It can be constructed
with two NAND gates or two NOR gates. Figure 19.05 shows the version with two NOR gates
Cambridge International AS & A Level Computer Science




                                                   Q'




S


Figure 19.05 A circuit for an SR flip-flop using NOR gates


The cross-coupled circuit with output feedback has some interesting consequences. For
example, if we consider
                     the hypothetical situation where R, S, Q and Q’ all had value 0 we can
see that this would be self-contradictory because two inputs value 0 to a NOR gate produce
a 1 output. A state with Q and Q’ both set to value 1 would be self-contradictory because the
output from a NOR gate is always 0 if either input is 1. The flip-flop is therefore a two-state
device. Either it has Q=1 and Q’=0 or it has the reverse.

The truth table for the circuit can be presented as shown in Table 19.03. The two lines of the
truth table where both S and R are input as 0 represent the condition when no signal is input
to the flip-flop. If we consider
                              the state with Q=1 and Q’=0:

e   and we consider the condition that both S and R inputs are 0

e   then the top NOR gate has inputs both 0

*   giving output 1

e   andthe bottom NOR gate has inputs
                                   1 and 0

e   giving output
                0.

This means that this is a self-consistent state which is referred to as the set state. A similar
argument can be applied for the alternative to the set state which is the unset state with Q=0
and Q’=1.

The S and R inputs are for set and reset, respectively. The truth table shows that an input
combination of S=0 and R=1 converts a set state to an unset state and an input combination
of S=1 and R=0 converts an unset state to a set state.

             Input signals                                            Initial state                                               Final state
                                                           HI HB Ve




                                                                                                              oO] ol]eHRI eB Ve




        Ss
                                                   O}]o;o!};rRI]




                                                                                                            OlrFI
                             Blo!) olrF|o| O fee




        0
                                                                                      ePlelRe|o!]oal|loao




                                                                                                                                                ePlo;lreilrFR|ol|lo




        1

        0

        0

        1

        0



Table 19.03 A representation of a truth table for an SR flip-flop


These properties explain why the SR flip-flop can be used as a storage device for 1 bit and
therefore could be used as a component in RAM because a value is stored but can be altered.
The truth table does not contain rows for R=1 and S=1 because this leads to an invalid
                                                                       Part 3: Chapter 19: Logic circuits and Boolean algebra




state with both Q and Q’ having value 0. Because of this the circuit must be protected from
receiving an input signal on R and S simultaneously.

The alternative NAND gate circuit for the SR flip-flop has a similar structure but the labeling is
different. The important difference is that setting is achieved with S=0 and R=1 and resetting
with R=0 and S=1.



     TASK 19.02

     Find a diagram for a NAND gate SR flip-flop and construct the truth table.



The JK flip-flop
In addition to the possibility of entering an invalid state there is also the potential for a
circuit to arrive in an uncertain state if inputs do not arrive quite at the same time. In order
                                                                                               to
prevent this, a circuit may include a clock pulse input to give a better chance of synchronising
inputs. The JK flip-flop is an example.

The JK flip-flop can be illustrated by the symbol shown in Figure 19.06(a). A possible circuit is
shown in Figure 19.06(b).


                                                      L

                                         —D>—
           xVeca




cP     —                              Clock



                                                      ||                           b      .           Q'
                                         K   —E———e
                                                      r




                                                                           b


Figure 19.06 (a)     Asymbol for a JK flip-flop and (b) a possible circuit




     TIP

     There is one special case for a NAND gate; when all inputs are 1 the output is 0. There is one
     special case for a NOR gate; when all inputs are 0 the output is 1.



To understand the workings of the circuit you must first remember that a NAND gate gives
a 1 output unless all inputs are 1. If the circuit is in the unset state with Q = 0 and Q’ =I this is
stable and self-consistent as shown by the following argument:

e    theclock and R both input0

e    the top-left NAND gate therefore has output 1

e    this then leads to two 1 inputs to the top-right NAND gate

e    ensuring that Q=0.

If the input from J now becomes 1 and the clock pulse switches to a 1 then:

e    the top-left NAND gate has all 1 inputs

e    so the output is 0

e    this causes the top-right NAND gate to output a 1 for Q
Cambridge International AS & A Level Computer Science




e        there are now two 1 inputs to the bottom-right NAND gate

e«       sotheQ’ output becomes 0.

This shows how the J input is a set input. A similar argument shows that the K is a clear input.
In this respect the JK flip-flop behaves in a similar way to the SR flip-flop as a storage device
for one bit. However, there is an important difference in that if both J and K are input as a
1 then the values for Q and Q’ are toggled (they switch value). This makes the JK flip-flop a
more reliable device because there is no combination of input states that leave uncertainty
as to which values are stored. The significant part of the truth table is shown as Table 19.04.




               0                 0                  aN                     Q unchanged

               1                 0                  ay                           1

               0                 1                  4                            0)

               1                 1                  ay                       Q toggles


Table 19.04 Part of the truth table for a JK flip-flop


Question 19.02
Can you follow the logic in the JK flip-flop circuit to see that the truth table is an accurate
representation of the logic for all combinations of input?



19.03 Boolean algebra basics
Chapter
      4 (Section 4.01) introduced logic expressions consisting of logic propositions
combined using Boolean operators. Boolean algebra provides a simplified way of writing a
logic expression and a set of rules for manipulating an expression.

Whenever a form ofalgebra is used it is vital that there is an understanding of its meaning. As
a simple example we can consider the following four interpretations of the meaning of 1+ 1:


     1    +    1   =   2

     1    +    1   =   10

     1    +    1   =   0

     1    +    1   =


The first shows denary arithmetic, the second binary arithmetic and the third bit arithmetic.
The last one applies if Boolean algebra is being used. This is because in Boolean algebra 1
represents TRUE, 0 represents FALSE, and + represents OR. Therefore the fourth statement
represents the logic statement:

                                         TRUE OR TRUE is TRUE

There are options for the representation of Boolean algebra. For example, the symbols for
AND and OR are sometimes represented asA and v. There is also the option of writing A.B or
AB for AAND B. The dot notation is used in this book. Finally, there are options for how NOTA
(the inverse of A) can be represented. Ais used here.



0        TIP

         You do not need to remember
                                  the A and V notation.
                                                                Part 3: Chapter 19: Logic circuits and Boolean algebra




Having established the notation for Boolean algebra we have to consider
                                                                     the rules that apply.
These can formally be described as ‘laws’ or ‘identities’. Table 19.05 contains a full listing.


 Identity/Law                              AND form

 Identity                                 LA=A                               O+A=A

 Null                                     0.A=0                              1+A=1

 Idempotent                               AA=A                               A+tA=A

 Inverse                                  AA=0                               A+A=1
 Commutative                              A.B=BA                            A+B=BtA

 Associative                           (A.B).C = A.(B.C)                (A+B) +C=A+(B+C)

 Distributive                         A+ B.C = (A+B).(A+C)               A(B+C)=ABt+A.C

 Absorption                          A(A+B)=A                              A+AB=A

 De Morgan’s                             AB=A+B                             A+B=AB

 Double Complement                                            A=A

Table 19.05 Boolean algebra identities (laws)


Some of the names used for the identities may be unfamiliar
                                                          to you. This is not a concern.
You should note that for all but one ofthe identities there is an AND form and an OR form.
Furthermore, it is important
                           to note that an identity written in one form can be transformed into
the other by interchanging each 0 or 1 and each AND or OR. For example, 0.A =0 which reads
FALSE AND Ais FALSE transforms into TRUE OR Ais TRUE, written in the algebra as         1+A=1.

it can also be seen that some of the identities look like those applying in normal algebra with
AND functioning as multiplication and OR functioning as addition. So you can use the terms
‘product’ and ‘sum’ in the context of Boolean algebra.



   TASK 19.03

   It is vital that you can interpret a Boolean expression correctly. Go through Table
   19.05 item by item and in each case read out the full meaning. For example:
   1+A=1 can be read as ‘one plus A equals 1’
   but must be understood as ‘TRUE OR A is TRUE’.




Although De Morgan’s laws look complicated at first glance, they can be rationalised easily.
The inverse ofa Boolean product becomes the sum of the inverses ofthe individual values in
the product. The inverse of a Boolean sum is the product of the individual inverses.

Unfortunately, using the algebra to simplify expressions is not something which can be learnt
as a routine. It requires lateral thinking as Worked Example 19.01 will show.
Cambridge International AS & A Level Computer Science




   WORKED EXAMPLE 19.01


  Using Boolean algebra to simplify an expression

  Let’s consider a simple example:

                                             A+A.Bcan be simplified toA+B

  In order to simplify the expression, we have to first make it more complicated! This is where the lateral
  thinking comes in. The OR form of the absorption identity is        A+ A.B =A. This can be used in reverse to replace
  A byA+A.B to produce the following:

                                                         A+AB+AB

  We can for the moment ignore the A.

  Applying the AND form of the commutative law and the OR form of the distributive law in reverse we can see
  that:

                                A.B+A.B is the same as B.A+ B.    Awhich converts to B.(A+ A)

  This allows us to use the OR form of the inverse identity which converts A +A into 1. As a result, the full
  expression, including the A that was ignored, has become:

                                                          A+B.1

  The AND form ofthe identity law can now be applied to the B.1 term to change it to B so the expression then
  becomes
       A+ B.




19.04 Boolean algebra applications
Creating a Boolean algebra expression directly from a truth table
One formal approach to creating a Boolean algebra expression for a particular problem is to
start with the truth table and apply the sum of products method. This establishes a ‘minterm’
for each row of the table that results in a 1 for the output. This can be illustrated using the
half adder circuit truth table shown in Figure 19.01. The only row of the table creating a 1
output for       Chas a1 input forA and for B. The product becomes A.B and the sum of products
has only this one term so we have:

                                               C=A.B

For the S output, there are two rows that produce a 1 output so there is a sum of products
containing two minterms:

                                             S=ABt+A.B

Note that the 0 in a row is represented by the inverse of the input symbol.

In certain cases Boolean algebra laws can be applied directly to parts of the truth table. For
example, consider a truth table which contains the following two rows:

             A              |           B            |            C            |           x
             0                           1                        0                        1

             0                           1                        1                        1


The output for
             X is the same whether C =0 or C= 1. There must therefore be a minterm which
has no reference to C which in this case will be A.B.
                                                             Part 3: Chapter 19: Logic circuits and Boolean algebra




The Boolean algebra representation of a logic circuit
This approach can also be used as part of the process ofcreating a Boolean algebra logic
expression from a circuit diagram. The truth tables for the individual logic gates are used and
then some algebraic simplification is applied.




  Creating a Boolean algebra logic expression for a half adder circuit



                                      tH
               OH                                         ae
  A                   Ww
  B



                                      Da
                                                              poe

  Figure 19.07 A half adder circuit


  Figure 19.07 shows inputs A and B to a NAND gate with output W. The first three rows of the NAND truth table
  produce a 1 output so the sum of products has three minterms:

                                                 W=A.B+AB+AB
  We can now consider
                   the input of W to a NAND gate with A as the other input to produce the X output.
  Instead of using the NAND truth table we will use the fact that the NAND gate operates as an AND gate
  followed by a NOT gate.

  The result of the AND operation is the product of the inputs so we get the following expression as output:

                                                  A{A. B+A.B+A.B)
  This can be simplified by applying the distributive and inverse laws to give:

                                          0+0+A.A.B which is simply A.B
  To complete the NAND operation and get the value forX we have to apply the NOT operation which means
  we have to take the inverse of the above expression.

  This is where we need the AND version of De Morgan’s law which transforms the A.B into A + B. So we have:
                                                       X=A+B
  The same laws applied to the output Y from the other intermediate NAND gate to give

                                                       Y=A+B
  Finally, we need to consider A+ B and A+B      being input to the final NAND gate. Again we can consider
                                                                                                        the
  AND operation first as the product of the inputs to produce the expression:

                                                    (A+B).(A+B)
  We will not multiply this out; we will instead apply De Morgan’s law directly to the expression to perform the
  inverse operation to complete the NAND operation. This gives:

                                                     S=AB+A.B
  This is the value obtained directly from the truth table so the algebra has been used correctly.
Cambridge International AS & A Level Computer Science




Extension Question 19.01
Worked Example 19.02 did not show that the circuit produced the correct output for C. Also
a shortcut was used to reach the final form of S. Can you use Boolean algebra to find the
form of C from the circuit and can you convert the expression for S if you start by using the
distributive law before applying De Morgan’s law?



19.05 Karnaugh maps (K-maps)
A Karnaugh map is a method of creating a Boolean algebra expression from a truth table.
A K-map can make the process much easier than if you use sum-of-products to create
minterms. lf applied correctly a K-map produces the simplest possible form for the Boolean
algebra expression.




                                                                                        Re| oO
                                                   Plo}]rRI|o




                                                                                      ele}
                ePlRr|ol]o




Table 19.06 The truth table for the OR operand


The truth table for an OR gate, shown as Table 19.06, can be used to illustrate the method.
The sum of products method produces the following expression:

                                        X=A.B+ABt+A.B
This is not instantly recognisable as A + B but, with a little effort, using Boolean algebra laws it
could be shown to be the same.

The Karnaugh map approach is simpler. The corresponding K-map is shown in Figure 19.08.
Each cell in a Karnaugh map shows the value of the output
                                                       X for a combination of input
values for
        A and B.

        B                    B


A       0                    1

A       1                    1



Figure 19.08 A K-mapof the truth table in Table 19.06


The interpretation ofa Karnaugh map follows these rules.

e   Only cells containing a 1 are considered.

e   Groups of cells containing 1s are identified where possible, with a group being a row,
    a column ora rectangle.

e   Groups must contain 2, 4,8 and soon cells.

e   Each group should be as large as possible.

e   Groups can overlap and all overlapping groups must be used.

e   |f an individual cell cannot be contained in any group it is treated as being a group.

e   Within each group, the only input values retained are those which retain a constant value
    throughout
            the group.
                                                                                                                                    Part 3: Chapter 19: Logic circuits and Boolean algebra




These rules define a column and a row group as indicated by the blue outlines. In the column
group, B remains unchanged but A changes so B is retained. In the row group, it is A that
remains unchanged. The Boolean algebra expression is then just the sum of these retained
values:

                                                                                             X=A+B

Thus, the Karnaugh map has found the OR expression without using any algebra.


   WORKED EXAMPLE 19.03


  Using a K-map to interpret a three-input problem

  Let’s consider the following truth table:




                                                                                                                            © Je,




                                                                                                                                                                             ies
                                                                                                        BPlo};lrFl)oalH!]oaleH!]




                                                                                                                                                     eBPleE!|laoalalrPiH|ol|l|H
                   >




                                                               Lvs)
                                                               Plo!) ol;rRiyrFR!|o!|o
                   BPlre/leEl/E|ol|oalalo




  Table 19.07                               Asample truth table with three inputs

  Before starting any application of a method it is always worth looking to see if there are any trends. In this
  case you can see that whenever B = 1 the output for
                                                    X is 1. This means that the final algebra should have
  B+something.

  Applying sum of products gives the following five-minterm expression:

  AB.C + AB.C + ABC +AB.C + ABC
  There are two options for how the K-map is presented. We will choose to combine input values in the
  columns.

  Figure 19.09 shows the result. This follows the convention of having the rows corresponding to values ofA
  and the columns to combinations of values for B and C.



              BC                            00         01                               11         10

      A

                   C=                            4                                             r=




                                                 |                                             t

      0                                      1)        0                                1      11
                                                 I                                             l
                   ae |                                                                        a




          1                                  0         0                                1          1




  Figure 19.09 A K-map representation of the truth table shown in Table 19.07

                                                                                                                                                                                   (Continued)
Cambridge International AS & A Level Computer Science




  It is important to note that the labelling of the columns does not follow a binary value pattern. Instead it
  follows the Gray coding sequence where only one bit changes value each time.

  Following the rules stated above the first group to identify is the square offour cells with a value 1 as
  identified by the blue rectangle in the diagram. For these it can be seen that A has different values, B has
  a constant value but C changes values. So, only B is retained. Note this was anticipated from the initial
  inspection ofthe truth table.

  This apparently only leaves the top left cell. It looks like an isolated cell but it is not because K-maps wrap
  round. The cell is defined by BC = 00. This has two adjacent cells under Gray coding rules. It is immediately
  obvious that the cell BC = 01 is adjacent but this contains 0 so it can be ignored. The other adjacent cell is
  the BC = 10 combination because of the wrap round rule. Thus, there is a row group containing BC = 00 and
  BC = 10, indicated by the dotted line partial group outlines. For this row the value Aremains unchanged, B
  changes but C remains unchanged so the product A.C results. By adding this to the B for the other group the
  final expression becomes:

                                                        A.C+B
  This is much simpler than the expression with five minterms derived directly from the truth table.


Extension Question 19.02
Consider
      the Karnaugh map shown in Figure 19.10. This corresponds to a problem with four
inputs. It wraps round horizontally and vertically. Use the map to create a Boolean algebra
expression.




       CD     00     01       11      10

  AB


  00          1      0        1        1




  01          0      0        1        1




  11          0      0        1        1




  10          1      0        0        0




Figure 19.10 A K-map for a four input problem


Reflection Point:
When using Karnaugh maps will you remember
                                         to use Gray codingif there are three inputs
and will you remember
                    to use all overlapping groups?
                                                                     Part 3: Chapter 19: Logic circuits and Boolean algebra




    Summary




Exam-style Questions

1   a_   Consider
            the following circuit:



         a                                        S—D-:

         >t)                                                                      R
         i    _—_ Identify the three different logic gates used.




                                                                                                           AN
         ii        Complete the following truth table for the circuit for the inputs shown for
                                                                                             A and B.

                           Inputs           Workspace              Outputs

                       A            B                          S             R

                       0            0

                       0            1

                       1            0

                       1            1


    b = For the circuit shown in part a, identify the type of circuit and what the outputs represent.     (3]

2   a    Consider
           the following truth table:

              A            B            X

              0)            0           1

              0             1           0

              1             0           1

              1             1           1


         i         Using the sum-of-products approach, write a Boolean expression that matches
                   the logic.                                                                             [3]
         ii        Forthe rows that have A = 1, the output for
                                                             X is 1. Explain how this would be
                   reflected in a simplified form of Boolean expression matching the truth table.         (2
Cambridge International AS & A Level Computer Science




    b     Consider
             the following circuit:

          A


                         DD:
          Lp
          i     Using your knowledge of the truth table for an AND gate, write a Boolean
                algebra expression for the output from the first AND gate.                                 [2]

          ii    Using your knowledge of the truth table for an OR gate write a Boolean algebra
                expression for the output from the OR gate.                                                [3]

          iii   Using De Morgan’s law, write the logic expression for the output from the NOT gate.        [4]

3   a     Consider
            the following truth table:

                          A                                           B                     X

                          0                                            0                    1

                          0                                            1                    )

                          1                                           0                     1

                          1                                           1                     1



          i     Sketch a Karnaugh map to match this truth table.




                                                                                                           9 ES
          ii    Usethe Karnaugh map to write a Boolean algebra expression for this logic.

    b     Consider the truth table shown in part a.

          i     Usethe sum-of-products method to write a Boolean algebra expression from
                the truth table.                                                                           [3]
          ili   Use Boolean algebra to demonstrate that this expression can be simplified to give the
                same expression created from the Karnaugh map. Hint: you might wish to use the fact that

                                         AB =AB+AB
4   a _   Complete the truth table for this NAND gate:
                                                PIlEPIlo]o!]>?,r



                                                                   rPIlo;lFliol!l]mw




          A ——4



                                   X
          B ——




          An SR flip-flop is constructed using two NAND gates.




                <
          S




                —|»
                                                                                       Ol




          R
                                                                                 Part 3: Chapter 19: Logic circuits and Boolean algebra




    b      i    Complete the truth table for the SR flip-flop.

                                                                  S              R              Q            Q
                                     Initially                    1              0              0            1

                           R change to 1                          1              1

                           S changed to 0                         0              1

                           S changed to 1                         1              1

                        S and R changed to 0                      0              0                                             [4]

           ii   Oneofthe combinations in the truth table should not be allowed to occur.

                State the values of S and R that should not be allowed. Justify your choice.                                   [3]

    Another type of flip-flop is the JK flip-flop.

    ¢      i    Give one extra input present
                                           in the JKflip-flop.                                                                 (1]

           ii   Give one advantage of the JK flip-flop.                                                                        (1]

    d___   Describe the role offlip-flops in a computer.                                                                       (2|

                                                     Cambridge international
                                                                          AS & A Level Computer Science 9608 paper 31 Q5 June 2016

5   a      i    Ahalfadderisa                 logic circuit with the following truth table.

                                                 Input                                        Output

                             X                               Y                       A                  B

                                0                            0                       0                  0

                                0)                           1                       0)                 1

                                1                            0)                      0                  1

                                1                            1                       1                  0


                The following logic circuit is constructed.

                P                     X                  A

                                          HALF ADDER                                                                 J
                Q                     Y                  B




                                                                        X                 A

                                                                            HALF ADDER
                R                                                       Y                 B                          K




                Complete the following truth table for this logic circuit.

                          Input                                             .                            Output
                                                                      Working space
                    P       Q             R                                                              J       K

                    0       0             0

                    0       0             1

                    0       1             0

                    0       1             1

                    1       0             0

                    1       0             1

                    1       1             0

                    1       1             1                                                                                    [2]
      Cambridge International AS & A Level Computer Science




            li    State the name given to this logic circuit.                                                     [1]
            ili   Name the   labels usually given toJ and K.

                  Explain why your answers are appropriate labels for these outputs.                             [4]
        b   i     Write down the Boolean expression corresponding to the following logic circuit:


                  A




                  :                                                    DB
                  C                            D>                                                                [2]
            li    Use Boolean algebra to simplify the expression given in part b(i).

                  Show your working.                                                                             [4]
                                    Cambridge International
                                                         AS &A Level Computer Science 9608 Paper 32 05 November 2016




366
 N     Wivi         toeL           VV       AVNAMA
                                                YL YA                NX   XN    VLAN NNW              NOY N            NNN NNSA




                                                                                                                          367




System software

Learning objectives
By the end of this chapter you should be able to:

   show understanding of how an operating system (OS) can    show understanding ofthe various stages in the
   maximise the use of resources                             compilation ofa program
   describe the ways in which the user interface hides the   show understanding of how the grammar of a language can
   complexities of the hardware from the user                be expressed using syntax diagrams or Backus-Naur Form
   show understanding of process-management                  (BNF) notation
   show understanding of virtual memory, paging and          show understanding of how Reverse Polish Notation (RPN)
   segmentation for memory management                        can be used to carry out the evaluation of expressions.
   show understanding of how an interpreter can execute
   programs without producing a translated version




                                           V ff ~
       \/
Cambridge International AS & A Level Computer Science




20.01 The purposes of an operating system (OS)
Chapter 8 (Section 8.02) contained a categorised summary of the various activities that an
operating system engages in. This chapter discusses some of them in more detail.

We can begin by considering a few aspects relating to the use of an OS.

1   Acomputer system needs a program that begins to run when the system is first switched
    on. At this stage, the operating system programs are stored on disk so there is no
    operating system. However, the computer has stored in ROM a basic input/output system
    (BIOS) which starts a bootstrap program. It is this bootstrap program that loads the
    operating system into memory and sets it running.

2   An operating system can provide facilities to have more than one program stored in
    memory. Only one program can access the CPU at any given time but others are ready
    when the opportunity arises, which is described as multi-programming and will happen
    for one single user. Some systems are designed to have many users simultaneously
    logged in, which is described as a time-sharing system.

3   The purposes of an operating system can usefully be considered from two viewpoints: an
    internal viewpoint and an external viewpoint. The internal viewpoint concerns how the
    activities of the operating system are organised to best use the resources available. The
    external viewpoint concerns the facilities made available for the user of the system.

4   The major resources associated with the internal viewpoint are the CPU, the memory and
    the I/O system.


Operating system structure
An operating system is structured to provide a platform for both resource management and
the provision of facilities for users. The logical structure of the operating system provides two
modes of operation. User mode is the one available for the user or an application program.
The alternative has a number of different names but the most often used is ‘kernel mode’.
The difference between the two is that kernel mode has sole access to part of the memory
and to certain system functions that user mode cannot access.

The parts of the OS that provide the two modes of operation are separated. The kernel
runs all of the time. The remainder of the OS runs in user mode so individual parts are only
accessed when needed. One possibility then is to use a layered structure as illustrated in
Figure 20.01. In this model, application programs or utility programs could make system calls
to the kernel. However, to work properly each higher layer needs to be fully serviced by a
lower layer (as in a network protocol stack).


             User interface



         Application programs



                Utilities



                 Kernel



          Hardware interface


Figure 20.01 Layered structure for an operating system
                                                                                      Part 3: Chapter 20: System software




A layered structure for an operating system is hard to achieve in practice. A more flexible
approach uses a modular structure, illustrated in Figure 20.02. The structure works by the
kernel calling on the individual services when required. It could be associated with a micro-
kernel structure where the functionality in the kernel is reduced to the absolute minimum.



      Memory                    File                   Device                  Scheduling
    management              management              management                management




Figure 20.02 Modular structure for an operating system



20.02 The input/output (I/O) system
The I/O system does not just relate to input and output that directly involves a computer
user. It also includes input and output to storage devices while a program is running.
Figure 20.03 is a schematic diagram that illustrates the structure of the I/O system.


                                 Disk         Screen               Keyboard       Printer



                                 Disk         Screen               Keyboard       Printer
                               device          device               device        device
                                driver        driver                driver        driver




  CPU     f= Memory


Figure 20.03 Main components associated with the I/O system


The bus structure in Figure 20.03 shows that there can be an option for the transfer of data
between an |/O device and memory. The operating system can ensure that |/O passes via the
CPU but for large quantities of data the operating system can ensure direct transfer between
memory and an I/O device.

To understand the issues associated with I/O management, some discussion of timescales is
required. It must be understood that one second is a very long time for a computer system.
A CPU typically operates at GHz frequencies. One second sees more than one trillion clock
cycles. Some typical speeds for I/O are given in Table 20.01.


                            Data rate                   Time for transfer of 1 byte

 Keyboard                   10 Bps                      O.1s

 Screen                     50 MBps                     2x10%s

 Disk                       5 MBps                      2x 10°'s


Table 20.01 Typical rates and times for data transfer
Cambridge International AS & A Level Computer Science




The slow speed of |/O compared to a typical CPU clock cycle shows that management of CPU
usage is vital to ensure that the CPU does not remain idle while I/O is taking place. This is
discussed in the next section.



20.03 Process scheduling
Resource management relating to the CPU mainly concerns scheduling to ensure efficient
usage. The methods discussed here consider
                                        the CPU as a single unit; specific issues relating
to a multiprocessor system are not considered.

Programs that are available to be run on a computer system are initially stored on disk. A user
could submit a program as a ‘job’ which would include the program and some instructions
about how it should be run. Figure 20.04 shows an overview of the components involved
when a program is run.

A long-term or high-level scheduler program controls the selection ofa program stored on
disk to be moved into main memory. Occasionally a program has to be taken back to disk
due to the memory getting overcrowded. This is controlled by a medium-term scheduler.
When the program is installed in memory, a short-term or low-level scheduler controls
when it has access to the CPU.

                                                                        Vv
                                  Vv




                                           Memory                                   CPU
                                                          AD




      Disk        <




Figure 20.04 Components involved in running a program




    High-level scheduler: makes decisions about which program stored on disk should be moved
    into memory

    Low-level scheduler: makes decisions about which process stored in memory should have access
    to the CPU




Process states
In Chapter 8 (Section 8.02), it was stated that a process can be defined as ‘a program being
executed’. This definition can be improved by including the state when the program first
arrives in memory. At this stage a process control block (PCB) can be created in memory
ready to receive data when the process is executed. Once in memory the state of the process
can change.

The transitions between the states shown in Figure 20.05 can be described as follows.

e   Anew process arrives in memory and a PCB is created; it changes to the ready state.
e   Aprocess inthe ready state is given access to the CPU by the dispatcher; it changes to the
    running state.

e   Aprocess in the running state is halted by an interrupt; it returns to the ready state.
e   Aprocess in the running state cannot progress until some event has occurred
    (I/O perhaps); it changes to the waiting state (sometimes called the ‘suspended’ or
    ‘blocked’ state).
                                                                                     Part 3: Chapter 20: System software




e   Aprocess in the waiting state is notified that an event is completed; it returns to the
    ready state.

e   Aprocess in the running state completes execution; it changes to the terminated state.




Figure 20.05 The five states defined for a process being executed

It is possible for a process to be separated into different parts for execution. The separate parts
are called threads. If this has happened, each thread is handled as an individual process.


| KEY TERMS




Interrupts
Some interrupts are caused by errors that prematurely terminate a running process.
Otherwise there are two reasons for interrupts.

°   Processes consist of alternating periods of CPU usage and |/O usage. |/O takes far too long
    for the CPU to remain idle waiting for it to complete. The interrupt mechanism is used
    when a process in the running state makes a system call requiring an |/O operation and
    has to change to the waiting state.

e   Thescheduler decides to halt the process for one of several reasons as discussed later
    under the heading ‘Scheduling algorithms’.

Whatever the reason for an interrupt, the OS kernel must invoke an interrupt-handling
routine. This may have to decide on the priority of an interrupt. One required action is that
the current values stored in registers must be recorded in the process control block. This
allows the process to continue execution when it eventually returns to the running state.

Discussion Point:
What would happen if an interrupt was received while the interrupt-handling routine was
being executed by the CPU? Does this require a priority being set for each interrupt?


Scheduling algorithms
Although the long-term or high-level scheduler will have decisions to make when choosing
which program should be loaded into memory, we concentrate here on the options for the
short-term or low-level scheduler.
                                                                                             i
A scheduling algorithm can be preemptive or non-preem ptive. A preemptive algorithm          w)




can halt a process that would otherwise continue running undisturbed. if an algorithm is
preemptive it may involve prioritising processes.

The simplest possible algorithm is first come first served (FCFS). This is a non-preemptive
algorithm and can be implemented by placing the processes in a first-in first-out (FIFO)
queue. The algorithm will be very inefficient if it is the only algorithm employed but it can be
used as part of a mare complex algorithm.

A round-robin algorithm allocates a tirne slice to each process and is therefore preemptive,




round-robin aigoritnm,

A priority-based scheduling algorithm is more cornplicated. One reason far this is that every
time a new process enters the ready queue or when a running pracess is halted, the priorities
for the processes may have to be re-evaluated. The other reason is that whatever scheme is
used to judge priority ievel it will require some computation. Possible criteria are:

e       estimated time of process execution

e       estimated remaining time                                for execution

«       length of time already spent in the ready queue

*       whether
             the process is 1/O bound or CPU bound.

More than one of these criteria might be considerec. Clearly, estimating a time for execution


employees. There is very little CPU usage for such a process 50 it maxes sense to allocate it




“Ses        ShA        RS                       a           *         2    *   oath gee dh
      SEE   Sek RASS
                   PELE ES Pee OS Pe                                      PER PSE REY
dotd
  ei FOy SVERSE SERIE YP SPEECHES
                            ELSIE BEATE SA,
                                                                          a




The term mernory manegement includes a number ofaspects.

®       The provision of protected mernory space for the OS kernel.

»       The loading ofa program into memory recuires defining
                                                           the memory addresses for the
        program itself, for associated procedures and for the data required by the program,

«       inarnultiprograrming systern, this might not be straightforward. The storage of
        processes in main memory can get fragmented in the same way as happens for files
        stored on a hard disk. There may be a need for the medium-term scheduler
                                                                               to move a
        process out of main memory to ease the problem.


        individual processes sharing memory.


ss    See hee aes ge ok
                     eke egee         RDae
                                         SES AE ENE tear. A ote
                                                              a Pad
 ‘A




RSPR oa                         AST
sae              S        &      PRL REL Skate            SORE  &
PU    SST LELESE Eo SEE RAS                OAV ERR IRE PLO


An early approach to memory management when different processes were loaded into
memory simultaneously was to partition the rnemory. The aim was to load the whole of a
process into one partition. This was wasteful of memory if the process size was less than
the partition size, An improvement was dynamic partitioning where the partition size was
allowed to acjust to match the process size. The rule of one process per partition remained,
                                                                                     Part 3: Chapter 20: System software




An extension of this idea which allowed for larger processes to be handled was
segmentation. The large process was divided into segments. Each segment was loaded into
a dynamic partition in memory.

There were two factors that limited the efficiency of this approach. The first was that
the segments were not constrained to be the same size. The second was that the size of
process did not allow all of the segments for one process to be in memory at the same
time. Segments had to be moved from disk to memory but then back again to disk when a
different segment was needed in memory.

These two factors combined to cause fragmentation both of the memory and ofthe disk
storage. This resulted in degradation in the performance of the system.


Paging and virtual memory
The modern approach is to use paging. The process is divided into equal-sized pages and
memory is divided into frames of the same size. The secondary storage can also be divided
into frames.


   KEY TERMS




it could be possible to load all of the pages into memory at the same time. However, even
if this were possible it is usually the case that not all parts of the program are needed at the
same time. A large program is likely to have optional routes for the execution.

A special case for the use of paging is when a program is so large that the address space
needed for it is larger than the size of the memory. Paging now supports what is known as
virtual memory management.


f KEY TERM




Paging requires the CPU to transfer address values to a memory management unit that
allocates a corresponding address on a page. An address has to comprise two parts: the
page number plus the offset from the start of the page. The memory management unit
functions through the use of a page table. Figure 20.06 shows a very simplified system
sufficient to illustrate how this works.

The left-hand part of Figure 20.06 shows a program with 48 instructions. These instructions
occupy three pages. The three pages occupy the first 48 logical memory addresses. Because
only 8 bits are used to store the logical address there are only 16 pages allowed. The logical
address stores the page number in the four most significant bits and the page offset in the
four least significant bits.

The right-hand part of Figure 20.06 shows the page frames with physical memory addresses.
it shows a scenario where the first two program pages have been loaded into page frames.
Note that the page frames used do not have to be adjacent. The centre part of Figure 20.06
Cambridge International AS & A Level Computer Science




shows the contents ofthe page table for this process (there will be a separate page table for
each process in memory). This table has the page number functioning as an index. It has a
value for the presence flag indicating whether or not the page is in memory. In the version
shown here the third entry shows the page frame number. This might instead have recorded
the physical address of the first item in the page frame.



0   TIP

        Remember that you will often see numbering starting from 0.




  Logical    Page             Program           Page       Presence    Page         Physical | Program
  address | number                             number        flag     frame         address
 11111111                                                             number
    Sf               -                                                               f



 11110000
                                                  2            0
                                                                                   00111111      Instr31



    J\S                                                                              J \s
                                                                                   01100000 |_   Instr16

 11101111                      Instr47                                             00101111




 11100000                      Instr32                                             00100000

 00011111                      Instr31            0            1        1          00011111 | Instri5



 00010000                      Instr16                                             00010000 |    Instroo
 00011111                      Instr15                                             00001111




 00000000                      InstrOO                                             00000000


Figure 20.06 The use of a page table for a paging system


When paging is being used the starting situation is that the set of pages comprising a process are
stored on disk. One or more of these pages is loaded into memory when the process is changing
to the ready state. When the process is dispatched to the running state, the process starts
executing. At some stage, the process will need access to a page that the page table indicates is
not in memory. This is called a page fault condition. It is now almost inevitable that, in order to
bring in the required page from secondary storage, a page will need to be taken out of memory
first. This is when a page replacement algorithm is needed. There are a number of options for
this.     Asimple algorithm would use a first-in first-out method. A more sensible method would be
the least-recently-used page but this requires statistics of page use to be recorded.

The system overhead in running virtual memory can be a disadvantage. The worst problem
is disk thrashing, when part ofa process on one page requires another page which is
on disk. When that page is loaded it almost immediately requires the original page again.
                                                                                              Part 3: Chapter 20: System software




This can lead to almost never-ending loading and unloading of pages. Algorithms have been
developed to guard against this never-ending loading and unloading but the problem can
still occur.


    KEY TERM


    Disk thrashing:   when paging is   being used and a repetitive state has been reached where loading   one




Extension Question 20.01
Find out information about the virtual memory capacity and page size of a computer system
that you use. In what circumstances might these need to be changed?



20.05 Operating system facilities provided for the user
The user interface may be made available as a command line, a graphical display or a voice
recognition system. But the function of a user interface is always to allow the user to interact
with running programs. When a program involves use of a device, the operating system
provides the device driver: the user just expects the device to work. (You might, however,
wish to argue that printers do not always quite fit this description.)

The operating system will provide a file system for a user to store data and programs. The
user has to choose filenames and organise a directory (folder) structure but the user does
not have to organise the physical data storage on a disk. If the user is a programmer, the
operating system supports the provision ofa programming environment. The operating
system allows a program to be created and run without the programmer being familiar with
how the processor functions.

When a program is running it can be considered to be a type of user. The operating system
provides a set of system calls that provide an interface to the services it offers. For instance, if
a program specifies that it needs to read data from a file, the request for the file is converted
into a system call that causes the operating system to take charge, find the file and make it
available to the program. An extension ofthis concept is when an operating system provides
an application programming interface (API). Each API call fulfils a specific function such as
creating a screen icon. The API might use one or more system calls. The API concept aims to
provide portability for a program, where a program can run on different operating systems
with minimal changes.



20.06 Translation software
Chapter
      8 (Section 8.05) provided an overview of how a compiler or an interpreter is used.
We will now will consider some details of how a compiler works with a brief reference to the
workings of an interpreter. Compiler or interpreter writing is a specialised task carried out by
professionals who each will have their own particular methods. So, we will just look at some
general principles and illustrations of some of the techniques that are likely to be used.

A compiler can be described as having a ‘front end’ and a ‘back end’. The front-end program
performs analysis of the source code and unless errors are found produces an intermediate
code that expresses completely the semantics (the meaning) of the source code. The back-
end program then takes this intermediate code as input and performs synthesis of object
code. This analysis-synthesis model is represented in Figure 20.07.
Cambridge International AS & A Level Computer Science




                        v              |
    Source
                    Read         +-»| Analyse L»/'Intermediate
                                                      code wt, Synthesise
                                                                       ;                      Object



                                                            \

                                                       Interpret
                                                            and
                                                       execute


Figure 20.07 Analysis-synthesis model for a compiler


For simplicity, Figure 20.07 assumes no error in the source code. There is a repetitive process
in which the source code is read line-by-line. For each line, the compiler creates matching
intermediate code. Figure 20.07 also shows how an interpreter program would have the same
analysis front-end: In this case, however, once a line of source code has been found to be
error free and therefore converted to intermediate code, the line of source code is executed.


Front-end analysis stages
The four stages offront-end analysis, shown in Figure 20.08, are:

e    lexical analysis

e    syntax analysis

e    semantic analysis

e    intermediate code generation.


                                                                             Annotated
                                                                              abstract
    Source          Symbol                                                    syntax      intermediate

[code           l    table
                        A
                             /                                                    tree
                                                                                          generation
                                                                                             code

      vy                             Syntax            Parse
                                    analysis           —                                       y
    Lexical. > / Tokens} >                                              Semantic                     ;
    analysis                                                            analysis
                                                                              .           termediate
                                                                                         Intermedi

                                                                                            code


Figure 20.08 Front-end analysis


The course code that is the input data for a compiler or interpreter consists of a sequence
of characters. Each meaningful individual character or collection of characters is referred to
as a lexeme. A lexeme may be an identifier used by the programmer or may be a keyword,
operator or symbol that is defined by the programming language. One approach to lexical
analysis is first to remove all white space and all comments then to take each line of source
code and identify each lexeme. This is a pattern-matching exercise. It requires the analyser to
have knowledge of the components that can be found in a program written in the particular
programming language.

For example, the declaration statement:

                                       Var     Count    :   integer;

would be recognised as containing five lexemes:

                                       Var     Count    :   integer      ;

The assignment statement:

                                 PercentMark[Count]             :=   Score    *    10
                                                                                                           Part 3: Chapter 20: System software




would be recognised as containing eight lexemes:

                           PercentMark             [   Count     ]      :=      Score   *   10

The lexical analyser must now categorise each lexeme in order to tokenise the line of code.
For instance, in the first example, var        and integer must be recognised as keywords; count
recognised as anidentifierand:          and    ;       must be recognised as distinct lexemes.

For each identifier recognized there must be an entry made in the symbol table (which could
have been called the identifier table). The symbol table contains identifier attributes such
as the data type, where it is declared and where it is assigned a value. The symbol table is
an important data structure for a compiler. Although Figure 20.08 shows it only being used
by the syntax analysis program, it is also used by later stages of compilation. Furthermore,
most compilers are multi-pass allowing the contents of the symbol table to be frequently
upgraded.


   KEY TERM


   Symbol table: a    data structure in which each      record       contains    the name
                                                                                        and attributes of an identifier




Question 20.01
A symbol table is used by an assembler and by a compiler or interpreter. What are the
differences between these?

Another table   is used to identify the relevant token for each lexeme that is not an identifier so
that the lexeme in the line of code can be replaced by a token. In some cases each identifier
is also replaced by a token. Whatever scheme is applied the output from lexical analysis is
a tokenised version of the source code. A wide variety of formats for the representation of
tokens are mentioned in the literature.


Question 20.02
Can you think of any reason why a compiler might wish to tokenise white space rather than
removing it all?

Syntax analysis, which is also known as parsing, involves analysis of the program constructs.
The results of the analysis are recorded as a syntax or parse tree. Figure 20.09 shows the
parse tree for the following assignment statement:

                                              yrr3
                                                2* x + 4




UN.
  va
 aN
Figure 20.09 Parse tree for an assignment statement
Cambridge International AS & A Level Computer Science




Note that the hierarchical structure of the tree, if correctly interpreted, ensures that the
multiplication of2 by x is carried out before the addition of 4.

Semantic analysis is about establishing the full meaning of the code. An annotated abstract
syntax tree is constructed to record this information. For the identifiers in this tree an
associated set of attributes is established including, for example, the data type. These
attributes are also recorded in the symbol table.

An often-used intermediate code created by the last stage of front-end analysis is a three-
address code. As an example the following assignment statement has five identifiers
requiring five addresses:

                                                  ysr=adt
                                                     (b* c-d)/e

The assignment statement could be converted into the following four statements, each
requiring at most three addresses:

temp     :=b*                c

temp     :=           temp       -   d

temp         :=       temp       /   e

y   :=   a        +    temp




Representation of the grammar of a language
For each programming language, there is a defined grammar. This grammar must be
understood by a programmer and also by a compiler writer.



                                                          Letter
                                                     Vv




                                                     >    Digit



Identifier
       —————————->                       Letter
                                                                        Vv




Figure 20.10 Syntax diagram defining an identifier


One method of presenting the grammar rules is a syntax diagram. Figure 20.10 represents
the grammar rule that an identifier must start with a letter which can be followed by any
combination of none or more letters or digits. The convention used here is that options are
drawn above the main flow line and repetitions are drawn below it.

An alternative approach is to use Backus-Naur Form (BNF). A possible format fora BNF
definition of an identifier is:

<ldentifier> ::= <Letter>|<|dentifier><Letter>|<Identifier><Digit>

<Digit> ::= 0|1|2|3|4|5|6|7|8]9

<Letter> «= <UpperCaseLetter>|<LowerCaseLetter>

<UpperCaseLetter> ::= A|B|C|D|E]F]G|H]||J|K|L|MJN|O|P|Q|RIS|T|UV|W|X|Y
                                                                    |Z

<LowerCaseLetter> ::= alb|c|djelflg|h|ilj|k|l|m]njo|p|q)r|s)t|ulv|w|x]y|z
                                                                                      Part 3: Chapter 20: System software




The use of | is to separate individual options. The ::= characters can be read as ‘is defined
as’. Note the recursive definition of <Identifier> in this particular version of BNF. Without the
use of recursion the definition would need to be more complicated to include all possible
combinations following the initial <Letter>.

A syntax diagram is only used in the context of a language. It has limited use because it
cannot be incorporated into a compiler program as an algorithm. By contrast, BNF is a
general approach which can be used to describe any assembly of data. Furthermore, it can
be used as the basis for an algorithm.


Back-end synthesis stages
if the front-end analysis has established that there are syntax errors, the only back-
end process is the presentation of a list of these errors. For each error, there will be an
explanation and the location within the program source code.

In the absenceof errors, the main back-end stage is machine code generation from the
intermediate code. This may involve optimisation of the code. The aim of optimisation is to
create an efficient program. One type of optimisation focuses on features that were inherent
in the original source code and have been propagated into the intermediate code. As a
simple example, consider these successive assignment statements:

xX :=     (a
           + b) *                     (a
                                       - bd)

yos=      (a+
           2 * b)                       *    (a
                                              - b)

The most efficient code would be:

temp      :=       (a    —    b)

xX   :=   (a       +    b)    *       temp

y    :=   x    +       temp       *    b



Question 20.03
Check the maths for the efficient code defined above.

Another example is when a statement inside a loop, which is therefore executed for each
repetition of the loop, does the same thing each time. Optimisation would place the
statement immediately before the loop.

The other type of optimisation is instigated when the machine code has been created. This
type of optimisation may involve efficient use of registers or of memory.


Evaluation of expressions
An assignment statement often has an algebraic expression defining a new value for an
identifier. The expression can be evaluated by first converting the infix representation in the
code to Reverse Polish Notation (RPN). RPN is a postfix representation which never requires
brackets and has no rules of precedence.


     WORKED EXAMPLE 20.01


     Manually converting an expression between RPN and infix

     Converting an expression to RPN

     We consider a very simple expression:

                                                     a+b**e


                                                                                                               (Continued)
Cambridge International AS & A Level Computer Science




  The conversion to RPN has to take into account operator precedence so the first step is to convertb * cto
  get the intermediate form:

                                                  a+bec#*


  We then convert the two terms to give the final RPN form:

                                                  abc*           +


  If the original expression had been        (a + b)        * c (where the brackets were essential) then the conversion
  to RPN would have given:

                                                  ab+e*


  Converting an expression from RPN

  Consider this more complicated example of
                                          an RPN expression:

                                       x2*y3*                    +6       /


  The RPN is scanned until two identifiers are followed by an operator. This combination is converted to give
  an intermediate form (brackets are used for clarification):

                                    (x *          2)   y3    *       46       /

  This process is repeated to give the following successive versions:

                                  (x     *       2) (y *    3)    +6/

                                  (x
                                   * 2) +              (y
                                                        * 3) 6                /

                                ((x
                                  * 2) +               (y
                                                        * 3))             /       6

  Because of the precedence rules, some of the brackets are unnecessary; the final version could be written as:

                                    (x       *    24+ y*         3)   /       6




  WORKED EXAMPLE 20.02


  Using a syntax tree to convert an expression to RPN
  In the syntax analysis stage, an expression is represented as a syntax tree. The expressiona + b * c
  would be presented as shown in Figure 20.11.




 LN
                4 \,
  Figure 20.11 Syntax tree for an infix expression


  To create this tree, the lowest precedence operator (+) is positioned at the root. If there are several
  with the same precedence, the first one is used. The RPN form of the expression can now be
  extracted by a post-order traversal. This starts at the lowest leaf
                                                                    to the left of the root and then uses
  left-right-root ordering which ensures, in this case, that the RPN representation is:

                                                 abc*
                                                    4+
                                                                                        Part 3: Chapter 20: System software




WORKED EXAMPLE 20.03


Using a stack with an RPN expression



        RPN                                         Infix
     expression                                  expression
        line                                        line




                              Stack
                               line

Figure 20.12 Shunting-yard algorithm


To convert an infix expression to RPN using a stack, the shunting-yard algorithm is used (Figure 20.12).

Converting an expression to RPN

The rules of the algorithm are to consider the string of tokens representing the infix expression. These
represent the railroad wagons that are to be shunted from the infix line to the RPN line. The tokens are
examined one by one. For each one, the rules are as follows.

e        lfitis an identifier, it passes straight through to the RPN expression line.
e        |fitis an operator, there are two options.

         o   Ifthe stack line is empty or contains a lower precedence operator, the operator is
             diverted into the stack line.

         o   Ifthe stack line contains an equal or higher preference operator, then that
             operator is popped from the stack into the RPN expression line and the new
             operator takes its place on the stack line.

e        When all tokens have left the infix line, the operators remaining on the stack line are
         popped one by one from the stack line onto the RPN expression line.
Consider
      the infix expressiona + b * c. Table 20.02 traces the conversion process. The first
operator
       to enter the stack line is the + so when the higher precedence * comes later it too enters the
stack line. At the end the * is popped followed by the +.

    Infix line                         Stack line                      RPN line


    +b*oe                                                              a

    b*¥e                               +                               a

    koo                                +                               ab

    Cc                                 +     *                         ab
                                       +     *                         abc

                                       +                               abc     *

                                                                       abc     *   +



Table 20.02 Trace of the conversion process


Had the infix expression beena * b + c then * would have been first to enter the stack line but it
would have been popped from the stack before + could enter.
Cambridge International AS & A Level Computer Science




Evaluating an RPN expression
A stack can be used to evaluate an RPN expression. Let’s consider the execution of the
following RPN expression when x has the value 3 and y has the value 4:

                                                    x2*   y3*4+6/


The rules followed here are that the values are added to the stack in turn. The process is
interrupted if the next item in the RPN expression is an operator. This causes the top two
items to be popped from the stack. Then the operator is used to create a new value from
these two and the new value is added to the stack. The process then continues. Figure 20.13
shows the successive contents of the stack with an indication of when an operator has
been used. The intermediate states of the stack when two values have been popped are
not shown.

                                  *                       *        +                 /


                                                     3
                  2                                  4        12                E
| 3   |               3                [6 |          G        G        | 18 |   18       | 3   |

Figure 20.13 Evaluating a Reverse Polish expression using a stack




  TASK 20.01

   Practise your understanding of RPN.

  1   Convert the following infix expressions into RPN using the methods described in
      Worked Examples 20.01, 20.02 and 20.03:
          (x - y)             / 4
      3   *   (2+ x /                 7)

  2   Convert the following RPN expressions into the corresponding infix expressions:
      4ab+c+dadte+                              *
                  A               A
          y   2           z   3        +   6/

      Note that the caret (4) symbol represents ‘to the power of’.
  3   Using simple values for each variable in part 2, use the infix version to evaluate
      the expression. Then use the stack method to evaluate the RPN expression and
      check that you get the same result.




The use of RPN would be of little value if the simple processor with a limited instruction
set discussed in Chapter 6 was being used. Modern processors will have instructions in the
instruction set that handle stack operations, so a compiler can convert expressions into RPN
knowing that conversion to machine code can utilise these and allow stack processing in
program execution.


Reflection Point:
Have you learned that two data structures illustrated here, the binary tree and the stack,
have many different uses in computer science?
The operating system provides resource management including scheduling of processes, memory
management and control of the I/O system.

For the user, the operating system provides an interface, a file system and application programming
interfaces.

A modular approach provides a flexible structure for the operating system.

There are five states for a process: new, ready, running, waiting and terminated.

A process may be interrupted by an error, a need for an I/O activity or the scheduling algorithm.

Avirtual memory system uses paging and a memory management unit that uses a page table.

Compiler operation has a front-end program providing analysis and a back-end program providing
synthesis.
Backus-Naur form is used to represent the rules of a grammar.

Reverse Polish Notation is used for the evaluation of expressions.




  Ina multiprogramming environment, the concept ofa process has been found to be
  very useful in controlling the execution of programs.

  i      Explain the concept of a process.

  ii     |none model for the execution ofa program, there are five defined process states.
         Identify three of them and explain the meaning of each.

  The transition of processes between states is controlled by a scheduler.

  i      Identify two scheduling algorithms and for each classify its type.

  ii     Ascheduling algorithm might be chosen to use prioritisation. Identify two criteria
         that could be used to assign a priority to a process.

  Three memory management techniques are partitioning, scheduling and paging.

  i      Give definitions of them.                                                                       a
                                                                                                      Ses)

  ii     Identify two ways in which they might be combined.

  Some systems use virtual memory.

  i      Identify which of the techniques in part a is used to create virtual memory.
                                                                                                         |
                                                                                                      NON




  ii     Explain two advantages of using virtual memory.

  iii    Explain one problem that can occur ina    virtual memory system.
                                                                                                         a




  A compiler is used to translate a program into machine code.

  i      Acompileris modelled as containing a front end and a back end. State the overall
         aim of the front end and of the back end.
                                                                                                      NNN




  ii     |dentify two processes which are part of the front end.

  iii    |dentify two processes which are part of the back end.

  Complete the following Backus-Naur definition ofa signed integer:

  i     = <Digit>::=

  ii     §=<Sign> =

  iii    }<Unsigned integer> ::=

  iv     <Signed integer> ::=
Cambridge International AS & A Level Computer Science




    c        Give the Reverse Polish notation equivalent of the expression             (a + 6)    +b/c.                   [2]

    d_—      Give
              the infix notation equivalent
                                        of the Reverse Polish expression                    a3 b*6c*            - +4,     [2|

4   The following
            syntax diagrams, fora particular programming language, show the syntax of:

    e      anassignment statement

    e      avariable

    e      aletter

    e      an operator



     Assignment statement >| Variable L>(= > Variable --»| Operator >| Variable aes



                  Variable                    Letter        >|   Letter          >    Letter       y




                                                                                                       v
                                         Vv




                  Letter                                          Operator
                                    099¢



    a___    The following assignment statements are invalid.

            Give the reason in each case.

            i       a=biea                                                                                                [1]
            ii      a-=b -          2;

                                                                                                                          el


                                                                                                                           =
            ili     a = dd *          cce;                                                                                (1

    b       Write the Backus-Naur Form (BNF) for the syntax diagrams shown above.

            i       <assignmentstatement> ::=

            ii      <variable> ::=

            iii     §=<letter>::=

            iv      <operator> ::=                                                                                        [6]

    c        Rewrite the BNF rule for a variable so that it can be any number of letters.

             <variable>             ::=                                                                                   [2|


    d      = Programmers working for a software development company use both interpreters and compilers.

            i       Theprogrammers prefer to debug their programs using an interpreter,

                    Give one possible reason why.                                                                         (1]

            ii      Thecompany sells compiled versions of its programs.

                    Give a reason why this helps to protect the security of the source code.                              (1]

                                                Cambridge International
                                                                     AS & A Level Computer Science 9608 Paper 31 QI June 2015
                                                                             .                              ay


                                                                                                         __ oe

&   Anumbder of processes ere being exec uted in a computer,

    @    &xplain the difference between a program an CG a process.

    A process can be in one of three states: running, ready or blocked,


    Bb   For each of the following, the process is rmoved from the first state to the secon
                     he conditions that cause each offthe following changes of the state of a process:
                                                                              ec




         i     =6From running to ready

         #f   = From ready to running
                                    "2



         HE   | From running to biocke ral
                                         wd




    ¢    &xplain why a process cann ot be moved from th e bio CKEC
                                                                a
                                                                   State to the runn          State,


    d
Chapter 21:
Security

By the end of this chapter you should be able to:

m   show understanding of how encryption works
m   showunderstanding of digital certification
= show awareness of the Secure Socket Layer (SSL)/Transport Layer Security (TLS) protocols.
                                                                                              Part 3: Chapter 21: Security




21.01 Encryption fundamentals
Encryption can be used as a routine procedure when storing data within a computing
system. However, the focus in this chapter is on the use of encryption when transmitting data
overa network.

There are three issues that will be considered in this chapter:

e   isthe encryption algorithm sufficiently robust to prevent the encrypted data being
    decrypted by some unauthorised third-party?

¢   how is it possible to ensure that a secret key remains secret?

e   howcan the receiver of         acommunication be sure who sent the communication?

The use ofencryption is illustrated in Figure 21.01.The process starts with original data
referred to as plaintext, whatever form it takes. The plaintext is encrypted by an encryption
algorithm which makes use ofa key. The product of the encryption is ciphertext, which
is transmitted to the recipient. When the transmission is received it is decrypted using a
decryption algorithm and a key to produce the original plaintext.


/ ante» Encryption Hof ciphertoe A> Decryption Ho Peintent /

                        / Key /                                     / Key /
Figure 21.01 Overview of encryption and decryption


    KEY TERMS




    Ciphertext:   the result of   applying an encryption algorithm to data




Security concerns
There are a number of security concerns relating to a transmission.

¢   Confidentiality: Only the intended recipient should be able to decrypt the ciphertext.

e   Authenticity: The receiver must be certain who sent the ciphertext.

e   Integrity: The ciphertext must not be modified during transmission.

e   Non-repudiation: Neither sender nor receiver should be able to deny involvement in
    the transmission.

¢   Availability: Nothing should happen to prevent the receiver from receiving the transmission.

This chapter will consider only confidentiality, authenticity and integrity.

The confidentiality concern arises because a message could be intercepted during
transmission and the contents read by an unauthorised person. The concern about integrity
reflects the fact that the transmission might be interfered with deliberately but also that
there might be accidental corruption of the data during transmission.



Encryption methods
The fundamental principle of encryption is that the encryption algorithm must not be
a secret: it must be in the public domain. In contrast, an encryption key must be secret.
Cambridge International AS & A Level Computer Science




However, there are two alternative approaches. One is symmetric key encryption, and the
other is asymmetric key encryption also known as public key encryption.


Qo
    Symmetric key encryption: one private key is held by both sender and receiver and is used for both
    encryption and decryption

    Asymmetric key encryption: there is a public key and a private key one of which is used for
    encryption and the other for decryption



In symmetric key encryption there is just one key. This key is a secret shared by the sender
and the receiver ofa message. The sender uses the encryption algorithm together with the
key to encrypt some plaintext. The receiver decrypts the ciphertext using the same key.

The issue with symmetric key encryption is delivery of the secret key. The sender needs the
key to encrypt but how can the key be securely delivered to the receiver to allow decryption?

In asymmetric key encryption two different keys are used, one for encryption and the other
one for decryption. Only one of these is a secret.

Ifasymmetric encryption is to be used the process is initiated by someone in possession of
two keys. One ofthese is a public key which is sent to anyone who is going to partake in an
encrypted communication. The other is a secret private key which is never sent to anyone.
Having a means of secure transmission of a secret key is no longer an issue.

The most likely scenario is that the holder of the two keys wishes to receive a transmission. In
this case a sender uses the public key to encrypt some plaintext and sends the ciphertext to
the receiver. The receiver is now the only person who can decrypt the message because the
private and public keys are a matched pair. The public key can be provided to any number of
different people allowing the receiver to receive a private message from any of the different
people. There are two points to note here.

e   if two people require two-way communication, both communicators need a private key
    and must send the matching public key to the other person.

e   There are two requirements to ensure confidentiality should the transmission be
    intercepted and the message extracted: the encryption algorithm must be complex and
    the number of bits used to define the key must be large.


Question 21.01
One method used by an unauthorised person attempting
                                                   to decrypt a message is called a
brute-force attack where all possible values for the key are tried. Calculate how long it would
take to try all possibilities for a 64-bit or 128-bit key, assuming each attempt took 1 second.

The above account does not completely answer the question of how encryption works.
The missing factor is an organisation to provide keys and to ensure their safe delivery to
individuals using them. This will be discussed in the next section.



21.02 Digital signatures and digital certificates
Using asymmetric encryption, the decryption-encryption works if the keys are used the
other way round. An individual can encrypt a message with a private key and send this to
a recipient who has the corresponding public key and who can then use this to decrypt
the received ciphertext. This approach would not be used if the content ofa message was
                                                                                                Part 3: Chapter 21: Security




confidential because anyone might be in possession of the public key. However, it could be
used if it was important to verify who the sender was. Only the sender has the private key
and the public key only works with that one specific private key. Therefore, if the recipient
finds that the decryption is successful, the message has in effect been received with a digital
signature identifying the sender.


                         Cryptographic
     Message                    hash                Digest
                            function


                                               Vv

               / Sender’s /[ »| Encryption                   ; / Digital /
                  private key                                   signature




Figure 21.02 Sender using a one-way hash function to send a digital signature


There is a disadvantage in using this method ofapplying a digital signature: it is associated
with an encryption of the whole ofa message. An alternative is for the sender
                                                                            to use a public
cryptographic one-way hash function which creates a number that is uniquely defined for
the particular message, called a ‘digest’. The process at the sender’s end of the transmission
is outlined in Figure 21.02. The private key is used to encrypt the digest. The encrypted
digest is the digital signature. The message can be transmitted as plaintext together with
the encrypted digest as a separate file. Because the digest is much smaller than the whole
message the encryption and the transmission are faster processes than if the whole message
were encrypted.

The processes that take place at the receiver end are outlined in Figure 21.03. The same
public one-way hash function is used to create a digest from the received message. Then the
encrypted version ofthe original digest is decrypted using the public key.

If the two digests are identical the receiver can be confident that the message is authentic
and has been transmitted unaltered.

Note that the digital signature is different each time this process is used. This is because the
digest is uniquely defined by the hash function being applied to that particular message.


                       Cryptographic
     Message                hash              Digest
                          function




/ signature
    Digital
            pe
             Decryption
                  came
                    .
                        Digest
                         .
                               /

                          Sender’s
                         public key



Figure 21.03 Receiver checking that the received transmission is authentic and unchanged
Cambridge International AS & A Level Computer Science




However, the authenticity only confirms to the receiver that the message was sent from the
person who had sent them the public key. It does not consider the fact that someone might
create a public key and pretend to be someone else.

Therefore, a more strict way of ensuring authentication is needed. This can be provided by a
Certification Authority (CA) as part ofa Public Key Infrastructure (PKI).


                                                                   Certification
      PersonA                  Person A’s public key                Authority
    (the receiver)                                             >         (CA)


                                                           Person A’s|     | CA’s
    Person A’s                                             public key]      [Private
      digital                                                                 key
    certificate               digital certificate                        a
                  Vv                                                     Digital
      Person A’s                                                     certificate
        website                                                       creation
                                                                      process



Figure 21.04 Processes involved in obtaining a digital certificate


Let’s consider a would-be receiver who has a public-private key pair. The receiver wants to
be able to receive secure messages from other individuals, and these individuals want to be
confident about the identity of the receiver. The public key must be made available in a way
that ensures authentication. The steps taken by the would-be receiver
                                                                    to obtain a digital
certificate to allow safe public key delivery are illustrated in Figure 21.04. The process can be
summarised as follows.

1     An individual (person A) who is a would-be receiver and has a public-private key pair
      contacts a local CA.

      The CA confirms the identity of person A.

      Person A’s public key is given to the CA.

      The CA creates a public-key certificate (a digital certificate) and writes person A’s public
      key into this document.

5     The CAuses encryption with the CA's private key to add a digital signature to this document.

6     The digital certificate is given to person A.

7     PersonA      posts the digital certificate on a website.

Figure 21.04 shows person A placing the digital certificate on that person’s website but another
option is to post it on a website designed specifically for keeping digital certificate data.

Anyone who wishes to extract the public key from the certificate has to use the CA’s public key.

For this overall process to work there is a need for standards to be defined regarding the
public key infrastructure and the production ofthe digital certificate. As ever, the name for
the standard, X.509, is not very memorable.



0     TIP

      There are two similar processes that have been discussed. In one case someone with a private key
       sends a public key to someone else. In another case the CA sends a digital certificate containing a
       public key. Try not to confuse these two.
                                                                                            .           “s




The following are a few notes to surmmarise the options available.

e       The starting position is someone who has a public-private key pair which are associated
        with a specific asymmetric key encryption algorithm.

e       This person could just make the public key available to anyone who Is going to be either a
        sender or a receiver,

e       Foroptimum security the person instead sends the public key to a Certification Authority.

e       The Certification Authority creates 4 digital certificate which contains the public key with
        proof of the ownership of the public key.

e       Anyone wishing to use the public key obtains it from this digital certificate.

e       Amessage encrypted with the public key could be sent to the owner of the private key.

e       Amessage encrypted with the private key could be sent to anyone having the public key.

e       The owner of the private key could use it to create a digital sienature that could be used to
        authenticate an email as was suggested in Chapter 9 (Section 9.03).



& dole
    2       :   .
                    YP   Se LG      RAY ESE YP ESL SRSS eS SEER RES
                                       ey        ~        =        mt     :    -

                    ~                       »~        ~       >




For many years the Data Encryption Standard (DES) was the normal choice for symmetric key
encryption. As the weakness of DES became a problem, Triple DES took its place. In 2001 the
Advanced Encryption Stancard (AES) was introduced as a superior approach. For education
purposes only a simplified DES (S-DES} was introduced which allowed the sort of operations
performed in encryption to be better understood. The following is an overview of S-DES.

S-DES is an example of a block cloher which means encrypting blocks of bits. in S-DES 8-bit                  —
blacks are encrypted. A 10-bit key is chosen. The first stage is to create two 8-bit keys from               |
be illustrated by the following.

        Suppose that the 10-bit key is chosen to be                           0101010101

        when subjected to a perrnutation which can be represented by               35274101986



The numbering of the bit positions is read from left to right
                                                            so the new 10-bit version has the




the first of the two 8-bit keys to be used in the encryption is createc using the permutation




The second stage is the encryption, which is a five step process.

        An initial permutation.
ke
Ri




        Application ofa function using the permuted cade and the first encryption key.

        A switch of the first and last 4-bit parts.
GW




        A repeat application of the function but this tire with the second encryption key.
R
is




        A finai permutation using the reverse of the initial permutation sequence.

The decryption by the receiver of a transmission uses the same penerated 8-bit keys and
follows the reverse of the above process.
                                                                                               |
     The AES standard definess the block length as 128 bits.The user can choose to use 128, 192 or
     256 pits for the key.1Tne chances of the key being identified from the transmitted ciphertext
     are small.”Fhe main concern is the safety of the metnod used to provide thekey to both
     sender and receiver,




     “SE ff Dasiklie
     Sado eiS@? PUES
      :              bey amecrwrbiog sacthacs
              RIESE. GRE RPS eh.d YRS GSLPSS PEPE LE Pe
                                     aby       gs                      =



                                           “          o   :




     RSA (Rivest-Sham
                      ir-A                                     thod for public key encryption, is named after
     the three people who created if. The rnajor features ofthe metshod are the key generation
                                  dieman), the        usual met!
                                                              o 4




                             2p
     algorithrn andd the encryption function.

     The key generation can be summarised as follows.

     4     Two very large prime numbers p and q are chosen andtheir product nis calculated,

     ya    The product (p-1){q-1) is cate ulat

     3     Aprime number e less than (p-1)(q-1) and
                                                  not a factor
                                                            of it is chosen (65537 is theusual choice).
     4     Another number dis found which satisfies the condition that the product
                                                                                 of d times e
           when divided by{(p- I}(q-1) gives a remainder of 1.

     &     The public key becomes the pair (n,e).


uo
           The private key becomes tne pair (n,c).
     os




     The security oftne 3eerithm depends on the fact that finding factors of a verylarge number
     is not feasible
                   wi               y reasonable time scale. Computing n from p and q is straightforward
     but deducing p anc q given nis not!

     The encryption works on numbers so a text to be encrypted mustfirst have the cha racters
     replaced by numbers according toa sensible coding scheme. lf such a number
                                                                              x is to be
     encrypted as y then y is calculated so that the following relationship holds:

                                                              y=xemod n

     A similar relationship involving d rather than eis used for decryption.

     Public key encryption is inherently more secure than symmetric key encryption but the
     alzoritams are not as fast. it is quite common for public key encryption to be usec to deliver
     securely a key that can then be used for symmetric key encryption.


     Shy     Sty   Ge   ae         SSA         athe
      ee £38 afaik
             Soy ERE
     Soothe tliat  se Pegs
                       ERE “ee  Be
                            F Baad


     When we access 2 website, we have two concerns. The first is whether or not the website
     is genuine. The second
                          is whetherwe can transfer sensitive personaldata to the website,
     for example to buy a procuct offered for sale on the website. TheSecure Socket Layer (SSL)
     protocol was created to give assurance to a website user when a client-server application is
     underway. As described in Chapter 17 (Section 17.04), the interface between an application
     and TCP uses a port number. in the absence of a security protocol, TCP services an
     application using the port number. The combination of an IP address and a port number
                                                                                         is
     called
          a ‘socket’. When the Secure Socket Layer protocolis implemented it functions as an
     additionallayer between TCPin the transport layer and the application layer. When the SSL
     protocol is in place, the application protocol HTTP becomes HTTPS.
                                                                                                   Part 3: Chapter 21: Security




The following are some facts concerning SSL.

e   Although SSL is referred to as a protocol, it is in fact a protocol suite.

e   There is a Record Protocol that deals with the format for data transmission.

e   There is also a Handshake Protocol responsible for security.

e   The operation of SSL happens without any action from the user.

e   Thestarting point for SSL implementation is a connection between the client and the
    server being established by TCP.

e   Theclient browser then invokes the Handshake Protocol from the SSP suite.

e   The Handshake Protocol requests from the server its SSL certificate which is a digital
    certificate confirming its identity.

e   Theserver sends this SSL certificate plus its public key.

e   The browser uses this public key to encrypt a key which is to be used as a one-off session
    key for symmetric key encryption to be used for the data transfer during the session.

e   There may also bea need at this time to agree which encryption algorithms are to be used.

SSL was originally a proprietary protocol. However, it was taken over by the Internet
Engineering Task Force (IETF) in order for a standardised version to be produced. This
progressed to version 3.0. When the IETF realised that an improved version was required it
decided that a new name was appropriate. Transport Layer Security (TLS) is an upgraded
version of SSL recommended for use because of some security concerns with the use of SSL.
Despite this SSL is still in general use.


Discussion Point:
The use of encryption has always been a controversial subject. There are two important
aspects to this. The first is whether powerful, unbreakable encryption algorithms should be
made available to the public. The second relates to the key escrow scheme, which allows
governments access to all secret keys. You might wish to consider how the content here has
relevance to some ofthe topics in Chapter 9 and Chapter 10.



21.06 Quantum cryptography
Quantum mechanics provides fundamental laws of physics applicable to the behaviour of
particles. The particles that transmit light are called photons. Photons demonstrate wave
behaviour, so that each photon appears to vibrate in a particular direction at right angles
to its direction of travel. The direction each photon vibrates in is called its polarisation,
and is represented in a diagram as a double-ended arrow. A photon can be created with a
specific polarisation to represent a value for a bit. If we allow four possibilities for the state of
polarisation there are two ways to represent a 1 and two ways to represent a 0. This can be
illustrated as follows:


pe: <> =-0 77-1                    \=0

This scheme can be used to enable a sender and receiver to create a ‘shared secret’ code
consisting of a number of bits. Table 21.01 illustrates the process.
Cambridge International AS & A Level Computer Science




 Bit values sent

 Polarisation basis



 Polarisation chosen by receiver



 Bit values confirmed


Table 21.01 Creation of a ‘shared secret’ code

In Table 21.01 the first row indicates the bit sent, the second row shows the basis used for
this with + representing the one using vertical and horizontal and x representing the diagonal
pair. The sender chooses the bit pattern at random and also the polarisation basis for each
value at random. The third row shows the receiver’s choice for the polarisation basis for
each value. Again this is a random choice. Following the transmission the sender informs the
receiver about the polarisation basis used for each value. The receiver responds by saying
which ones were chosen to match. For these matches there is now a stored value for a bit. In
the example shown a ‘shared secret’ code 1001 has been created.

The above scheme has been incorporated in Quantum Key Distribution (QKD) systems.
Earlier in this chapter it was mentioned how a key might be transferred using asymmetric key
encryption for subsequent use in symmetric key encryption. QKD offers an alternative for the
key transfer. The key is still to be used in the normal way. The advantage of QKD is that the
transfer does not involve defined values just photons. Anyone trying to intercept the flow of
photons in an attempt to discover their polarisation will by the laws of quantum mechanics
destroy the photons. A photon cannot be detected and measured then sent on again. The
main drawback of quantum cryptography is that it cannot be implemented using standard
communication media. It requires a dedicated, special purpose ‘quantum channel’ between
sender and receiver. The costs of providing this are very high so routine use is unlikely.

There are ambitious hopes for the future of quantum computing but progress is slow. QKD is
one of the few examples where there has been significant success evidenced.



  TASK 21.01

  The concept of a ‘shared secret’ has been used in traditional encryption schemes.
  An example is the Diffie-Hellman key agreement method. Investigate the principles
  behind how this works.



Reflection Point:
Chapter 21: Security has some difficult concepts. Have you made sure that you understand
the overriding principles and definitions used?
    m=       Encryption converts plaintext to ciphertext; decryption reverses the process.
    m=       The five main security concerns when transmitting messages are: confidentiality, authenticity, integrity,
             non-repudiation and availability.

    =        Alternatives for encryption are symmetric, using one key, or asymmetric, using two different keys.
    m=       Authentication can be achieved using a digital signature and a digital certificate.
    m=       Adigital certificate is provided by a certification authority within a public key infrastructure.
    m        DES and AES are examples of symmetric key encryption.
    m=       RASis an important asymmetric key method.

    m        Secure Socket Layer (SSL) which became Transport Layer Security (TLS) provides security when accessing a website.
    =        Quantum Key Distribution systems use polarised photons.




1    a         When transmitting data across a network three concerns relate to: confidentiality,
               authenticity and integrity.

                Explain each of these terms.

     b = Encryption and decryption can be carried out using a symmetric or an asymmetric
               key method.

               Explain how keys are used in each of these methods. You are not required to
               describe the algorithms used. Your account must include reference to a public key,
               a private key and a secret key.

     c         Digital signatures and digital certificates are used in message transmission.

               Give an explanation of their use.

2    Secure socket layer (SSL) and its upgraded version named Transport Layer Security
     (TLS) is described as a protocol suite.

               Explain the meaning of the description ‘protocol suite’.
                                                                                                                        a wakw
     aor9»




               Describe the type of activity where SSL or TLS would be used.
               Explain how digital certificates are used in the protocol suite.

               Explain how encryption keys are used in the protocol suite.
     a




3    Digital certificates are used in Internet communications. A Certificate Authority (CA) is
     responsible for issuing digital certificates.

     a         Name three data items present in a digital certificate.

     b         Themethod of issuing a digital certificate is as follows.
               i     Auserstarts an application for a digital certificate using their computer. On this
                     computer a key pair is generated. This key pair consists of a public key and an
                     associated private key.

               ii    Theusersubmits the application to the CA. The generated oe (eee
                     key and other application data are sent. The key and data are encrypted using the CA’s
                     sisseteeneesnen (li) occ KEY.

               iii   The CAcreates a digital document containing all necessary data items and signs
                     itusing the CA'S vee (1) ee key.
                                                                                                                                    a




                 iy    The CAsends the digital certificate to the individual.

                 In the above method there are three missing words. Each missing wordis either
                 ‘public’ or ‘private’.

                 State the correct word. Justify your choice,                                                                 ‘Gl
        <    Alexa sends an ernail to Beena,

             Alexa’s emailprogram:

             ®         producesa message digest (hash)

             *         uses Alexa’s private key to encrypt the message digest

             *         acids the encrypted message digest to the plain text of hermessage

             ®         encrypts the whale message with Beena’s public “

             *         sends the encryptedmessage with a copy of Alexa’s           digital certificate.
             Beena’s email program decrypts the encrypted message using her private key,

             §         State the name givento the encrypted message digest,                                                  [1]
             fi       = Explain how Beena can besure thatshe has          received a message that is authentic
                       (not corrupted or tampered with} andthatit came from Alexa,                                           2|
             fii       Name two uses where encrypted message digests are advisable.                                          2|
                                               Cambridge international
                                                                    AS & A Level Computer Science     9608 paper 31 Q2 June 2016

    4   Bothclients and serversuse theSecure Socket Layer (SSL)protocol anc its successor, the
        Transport Layer Security {TLS} protocol.

“       a    i         Whatis a protocol?                                                                                    2]
             Hi = Narne
                   a    the client        panplication
                                            Di GIO usedac] in this context.
                                                                         A                                                   |a |
             Hii       =Narne the server usedin this context,                                                                [1
             iv        identify twe problems that the SSL and TLS protocols can help
                                                                                   to overcome.                              2|
        b    Before any application data is transferred between the client andthe server,a handshake
             ee ess taxes place. Part of this process is to agree the security parameters to be used.

                 escrib
                    two of e these security paramete                                                                         iA]
        c    N ame two applications of computersystems where“itwoule be appropriate to use

                 ne SSLOf TLS protocol. These applications should be different from the ones you
            namec in part (aj(H} anc part (ay(ip.                                                                            2|
                                          Camaridge international AS & A Level Computer Science 9608 paper 32 04 Novernber 2016
                                                                                                                >




                                                                                                                     “4
                                                                                                                -

                                                                                                                oe

                                                                                                                al


                                                                                                                oe

                                                                                                                -

                                                                                                                oe




Chapter 22:
Artificial Intelligence (Al)

By the end of this chapter you should be able to:

   show understanding of how graphs can be used to aid Artificial Intelligence (Al)
   show understanding of how artificial neural networks have helped with machine learning
   show understanding of Deep Learning, Machine Learning and Reinforcement Learning and the reasons for using
   these methods
   show understanding of back propagation of errors and regression methods in machine learning.
      Cambridge International AS & A Level Computer Science




      22.01 An overview
      It is not easy to define ‘Artificial Intelligence’. A key issue is the definition of intelligence. For
      example, you could argue that a person needs intelligence to do mental arithmetic, such as
      43 x 13. You could use a calculator
                                       to get the answer, though, and would not describe the
      calculator as having artificial intelligence. This means that a definition such as:

               Artificial intelligence involves the automation of intelligent behaviour.

      is not entirely satisfactory.

      There is agreement that Al is a part of computer science. It is also clear that the subject has
      many distinct sub-sections some ofwhich will be considered in this chapter. The conclusion
      is that a vague definition is best. For example:

               Artificial Intelligence is concerned with “how to make computers do things at which,
               at the moment, people are better,”

                                                        (E. Rich. Artificial Intelligence. McGraw-Hill, 1983)



      22.02 How graphs can be used in Al
      A graph is a collection of nodes or vertices between which there can be edges. Each node
      has aname. An edge can have an associated label which is a numerical value. An example is
      presented in Figure 22.01.



398




          o
              omc
      Figure 22.01 An example of a graph with labelled edges


      A graph can be used to represent a variety of scenarios. One common representation is
      that the nodes represent places and the edge labels represent the distances between those
      places. Edges are only included in the graph when there is a route available for direct travel
      between the pair of nodes. Such graphs can, for example, find the shortest route between
      two nodes that are not adjacent to each other.

      We could use our intelligence to find the shortest route between node A and node D by
      considering all of the possible routes and calculating the overall distance for each route.
      Using Figure 20.01, we would calculate the following values:

               ForAtoBtoCtoD                         overall distance is 40 + 10+ 40 = 90

               ForAtoBtoFtoE toD                     overall distance is 40 + 15+ 20+ 5=80, which is

                                                     the shortest
         ForAtoFtoEtoD                         overall distance is 69+ 20+5=85

         ForAtoFtoBteCtoD                      overall distance is 60+ 15+ 10+40= 1275

Fora grapoh containing 100 nodes this could be quite time consuming, Fort unately, a humber
ofartificial intelligence alsorithrns have been developed to salvethis type of problem.




thisis aleo rithm finds the shortest path to each of the other neces starting from one of the
nodes

The following is a Structured English design for a simplified version of the algorithm:

identifythe source node (S) where the path starts.

Create anempty set calledthe Shortestathset.

Create another set called RemainingNodes and put ail of the nodes into this including the
source node (S).

Create a record that stores:

         node names

         calculated values ter the distance to the node from the source node                         —
                                                                                                     oe
         the sequence of nodes in the route to the node,

Set the distance value for the source node S to be Q.

Set the distancevalue
                    for ail other nodes to be INFINITY
                                                 where this is to be set as a lare
vaiue greater than any value that will be calculated,

While the ShortestPath set does not include all of the nodes do thefollowing:

         Pick the node (N} fromthe RemainingNodes set that has the lowest distance value.

         Move this node inte the ShortestPath set.

         For each node in the RermainingNades set that is adjacent to N:

                   Calculate a new distance value by addingthe value given by the label of the
                   edge connecting
                              the two nodes to the already stored distance
                                                                         for N,

                   lf this value
                              is lasst” nthe    value currently   stored repiace
                                                                           |     this stored value
                   by the newone that   nas been calculated.

                   ia new value has been stored enter the sequence of nodes used to obtain
                   this value.

Fable22.01 shows how the algorithm progresses for the graph shown in Figure22.01, The
rode names are presented in red when they are still in the RemainingNodes set. At each
stage the node N is represented in black. The distance anc route cata is presented in grey
when itis no longer changeablebecause the nodehas been moved to the ShortestPatn set.
Cambridge International AS & A Level Computer Science




  Shovtocrpath oct                                    Content of the record
                                                                      D             E             1
             (}                A          B            C

                                                      °°              °°            co            or)
                                0         “

                               A          B            C              D             FE             '
            {A}                                                                                   60
                                0         40          co              co            co
                               A         A-B                                                     A-F


                                          B            C              D              E             F
           AB}                                        50              oo            co            55
                                          40
                                         A-B        A-B-C                                        A-B-F
                                                                      5              :             :
                                                       C
          {A,B,C}
                                                                      90            ©             55
                                                      50

                                          \         A-B-C          A-B-C-D                       A-B-F
                                                                      D              :             :
         {A,B,C,F}
                                                                      90            75            55

                                                     A-D-{         A-B-C-D        A-B-F-E        A-B-F
                                                                      D              :             -
         {A,B,C,E,F}
                                                                                    75            55
                                                                      80

                                                                  A-B-F-E-D       A-B-F-E        \-B-F
                                                    A-B-
                                                                      D               :            =
     {A,B,C,D,E,F}
                                                                      80                5              5

                                                                  A-B-F-E-D         3 FE         \-B-F



Table 22.01 Dijkstra’s algorithm applied to the graph in Figure 22.01

Note the general feature that some data don’t change once defined as is the case for nodes
C and E, but in other cases such as for nodes D and F the data has to be changed at a later
stage,



A* algorithm
Dijkstra’s algorithm finds the best route from one node to all of the remaining nodes. In many
cases the only requirement is to find the best route from one node tojust one other node.
It would be possible to modify the Dijkstra algorithm to make it stop once the optimum
route to the target destination node had been established. However, the modified algorithm
would still be likely to carry out far more calculations than were necessary. In particular, the
algorithm could initially be exploring routes that were notin the right direction.

The A* algorithm is a modification of the Dijkstra algorithm designed to improve matters. The
design of the A* algorithm is different in that the following step:

                       Calculate a new distance value by adding the value given by the label of the
                       edge connecting
                                    the two nodes to the already stored distance for N.

is expanded to the following:

                       Calculate a new distance value by adding the value given by the label of the
                       edge connecting the two nodes to the already stored distance for N.

                       Calculate an estimated value for the distance of N from the destination
                       node and add this to the new distance value.
                                                                           Part 3: Chapter 22: Artificial Intelligence (Al)




The extra calculation ofthe distance still to be travelled requires the use of a heuristic
function. When this function is chosen it must guarantee that any estimated value will be
lower than the actual value.

As an example ofthe use ofthe A* algorithm we can consider a simple example of finding the
shortest route between two towns using the existing roads. Figure 22.02 shows a basic map
showing the locations of seven towns identified as       A-G.



                        oC




       @A                                  @E




        OF



Figure 22.02   Asimple map showing the positions of seven towns.


This map is included because it has been drawn by using a pair of x-y coordinates defining the
position of each town. These coordinates are the basis of the heuristic function to be used.

Pythagoras’s theorem can be used to calculate the direct distance between two positions
as follows:

        Direct distance = y((difference in x coordinates) + (difference in y coordinates”)

This calculated distance must be less than any actual distance travelled using existing roads.
The coordinates used are shown in Table 22.02.



    40,20           30,30          80,35        130,30          120,20     45,5         100,30


Table 22.02 The x-y coordinates for the towns A- G


The graph for this problem is shown in Figure 22.03. This is drawn as before using edges to
define which towns have an existing road linking the town to another town. The label for each
edge shows the distance of travel along that road.




               50              (<) 35
WL KG    13                    7                    wea 15



Figure 22.03 The graph used to illustrate the A* algorithm.

it must be understood that there are a variety of versions of the A* algorithm. The application of
the algorithm demonstrated here does not match any specific version found in the literature.
       The algorithm is documented bythefol(lowing Structured English.

       Create three lists: the initial list,the open list and the closed list.
       Insert an empty record for each node in the graph into the initial list.

       Store thex andy coordinates of the node in each record ofthe initial list,
       Initialise      the value for distance travelled to zero in each recore of theinitial list.
       Createa look-
                 table that includes
                             up an entry for each pair                       of nodes that have
                                                                                              a direc
       connecting road.
       store the distance oftravel along that road for each pair of nodes in the table.
       Icentity the target node for the travel.
       centify the starting node for the travel and copy the record for this node inta the open list.
       Delete the record for the starting node from the initial list.

       Now recursively apply the following algarithrn until ail possibilities have been examined:

       For the parent nade in the open list identify all adjacent nodes in the initial list,
       Copythe record far each of the adjacent nodes into the open list,
       Delete the records forthe adjacent nodes from the initial list,
       Check if the target nodeis now in the apen list.

       If the target node is not in the open list continue with the following:

                    For each adjacent node now added to the open        listuse the value
                                                                                        in the look-up table
                    to Getermine
                              the cistance of travelframthe
                                                          parent node.
                    | options exist calculate a value for each route and choose the smallest value,
                    For each adjacent node updatethe value storedfor distance travelled in the record .

                    For each adjacent node update the path sequence stored in the record
_ oo                For each adjacent node use the heuristic function to calculate a vaiue for estimated
                    aistance
                          to travel.
                    For each adjacent node calculate a value for estimated total distance from start node
                    to target node by adding the valuefor distance travelled to the valuefor estimated
                    cistance to travel.
                    Identify the adjacent node with the lowestvalue for total distance frorm start mode
                    to target noce. Leave the recordfor this node in the open     list as a parent node. Copy
                    the recordsfor the remaining nodes into the closed list. Delete these records from the
                    open list.
                    Continue witn the next iteration
                                                   ofthe recursion.

       | the target nodeis in the open list,
                                          do the following
                                                        for this node only:

                    Usetne valuein the look-up table ta find the actual distance fromthe parent node to
                    the target node.
                    Calculate the total distance travelled.
                    | the recard for the target node has zero for the    valuefordistancetravelled enter the
                    vaiue now calculated and enter the path sequence into the record.
                    I the record alreacly has a value for distance travelled compare the new value and  if
                    this indicates a sharter route update the valuein the record for distance travelled and
                    enter the new path sequence.
                    Copy the record for the target nade into the initial list.
                    Deiete the record for the target node from the open list.
                    |f there is another adjacent node in the cpen list continue with the actions listed above
                    for when the target node is not in the open fist.
                    If the openlist is now empty rewind to check nodes in the closed list that have not
                    been includedin previous path sequences. For each of these calculate a value for
              estimated total distance from start node to target node. if this estimate is greater than
              the value stored for distance travelled in the target rnode record continue to rewind. if
              the estimate is less than this stored value copy the record for the node into the open
              list as a parent node and continue witn the actions listed above tor when the target
              node is notin the open list.

We can consider how the aigorithm will progress if the start node is chasen to be town A and
the target node to be town D.

With A the parent nade, B, C and F become                   the adjacent nodes whose records are brought
into the open list, The caicutations are:


For C distance travelled = 45, estimated further distance is 51, total 96
For F distance travelled = 20, estimated further distance is 89, total 109


direct route is the shortest.)
Band F are now moved to the closed list and C becomes the new parent. The only adjacent
node in the initial list is G which is brought into the apen list,
G becomes the parent for the adjacent nodes D anc £.
D is identified as the target node. The actual distance of travel from A to D using this route is
calculated as 110. When the data has been stored in the record for D this is moved to the Initial list.

Eis the only adjacent node left In the open list so this automatically becomes the new parent
node. The only nade in the initial list is BD which is again brought into the open list as an
adjacent node. The actual distance oftravei from Ato Dis now calculated as 105. Thisisa
lower vale than the one previously calculated so this data is stored in the record for node D.                   _
This record is then moved once again into the initial list.                                                      _
The rewinding will now consider nodes B anc F. The calculations for these were carried out
earlier, The estimated distances for Ato D via B and for                Ato D via F were found to be 109
and 113 respectively. Both of these values are greater than the actual distance found tor a
different route so these nodes can be ignored. The problem has been solved. The shortes
route has been found te be A-C-G-E-D with a total distance of 105.




hE           TR     Re     San       =         .        :
    2Boor
        of   RRae
             ESs    GAR
                      SS So RR Se Sa SS
                    RASA                   EP Ge
                            SRS EPRSR ESR TREES EEE SE
aie he oS we EVEGEE.PT
                    SSS SES          RESSEE EREE 3 Bee
                                                   aS




The requirements for machine learning can be summarised as:

e        acomputer-based system has a defined task or tasks to perform

e        knowledge is acquired through the experience of performing the tasks

e        asaresult of this experience and the knowledge gained the performance offuture tasks is


The ability to learn from experience is an indication of intelligence, Machine learning           is therefore
ane of the many individual approaches defined under the umbrella of artificial intelligence.

There are a number of ways to describe how the learning can take place. Three of these will
be considered here.
Cambridge International AS & A Level Computer Science




In unsupervised learning the system has to draw its own conclusions from its experience of
the results of the tasks it has performed. For this, algorithms are needed that can organise or
categorise the knowledge acquired. An example is where ‘conceptual clusters’ are identified
which are based on a hierarchical framework. In this approach the knowledge is initially
all placed in the root of a tree structure. Then, depending on attributes of the knowledge,
selected groups are moved into branches of the tree.

Nowadays unsupervised learning is a dominant activity. Powerful computer systems having
access to massive data banks are regularly used to make decisions based on previous
actions recorded. We all have our activity on the world wide web recorded and stored. This
stored data is then used to make decisions about what products or services should be
recommended to us in future Internet use. There is no theoretical frameworkfor this; it is
rather as though the intelligence is built-in to the data.

In supervised learning the system is fed knowledge with associated classification. For
example, an Al program might be under development for marking exam paper questions. In
the supervised learning, answers to examination questions could be provided together with
a grade for each one or with categorised comments.

A special case of supervised learning is where an expert system is being developed. An expert
system always has a focus on a narrowly defined domain of knowledge. In this case human
experts are given samples of data requiring analysis. The experts provide the conclusions
to be drawn from the data. The data and conclusions are input to the knowledge base. The
effectiveness of the system can be tested by a human expert providing sample data and
checking the accuracy of the conclusions provided by the expert system. If performance is
poor, then further data and conclusions are input to the system. Although an expert system
is an example of Al it is not an example of machine learning because there is no expectation
that the system will improve its performance unaided.

Reinforcement learning has some features similar to unsupervised learning and other
features similar to supervised learning. The method has its own specific vocabulary. The
following statements use this vocabulary in describing aspects of how a reinforcement
learning algorithm works.

e   Anagent is learning how best to perform in an environment.
e   The environment
                 has many defined states.
e   Ateach step the agent takes an action.
e   Anagenthas a policy that guides its actions.

e   The policy is influenced by the recorded history and the knowledge of the current state of
    the environment.
e   Anaction changes the environment to a new state.

e   The agent receives a reward following an action which is a measure of how effective the
    action was in relation to the achievement of the overall goal.
e   The policy will guide the agent in deciding whether
                                                     the next action should be exploiting
    knowledge already known or exploring a new avenue.


Qo
    Machine learning: where a system improves its performance through analysis of previous performance

    Unsupervised learning: where the machine learning takes place entirely through the system
    analysing and categorising the available data

    Supervised learning: where sample data is supplied to the system with associated data relating to
    the outcome of its use

    Reinforcement learning: where an agent learns by receiving graded rewards for actions taken
                                                                           Part 3: Chapter 22: Artificial Intelligence (Al)




In summary, the aim is to maximise the reward values by improving the quality of the policy.
It is a trial-and-error search for optimum performance. It requires many repeated attempts at
the same problem.

This description is an abstraction. The concept becomes clearer if some instances of the
application of the approach are considered. One area of application is playing logic games
such as backgammon. Another is robotics where a robot has to learn how to become
effective at a task. Another option is where the machine has to learn how to navigate a
maze. In this last case when the agent chooses a left turn which will eventually lead to the
destination the reward is given a positive numeric value. If instead it chooses a right turn the
reward is given a negative value.


Regression analysis methods
In some applications the aim of the Al is to predict and provide, as output numerical values
for some defined quantity, on the basis of data values for different quantities that have been
input to the Al algorithm. If regression analysis is to be used, the first step is for the system
to be provided with some actual values for both the input data and for what will become
output data when the Al system is operational. This data can be used to investigate if there
is any correlation between these sets of values. If a correlation is established which can be
represented by a mathematical formula, then this formula can be used to output predicted
values when new data is input.


                   KEY TERM




The simplest application of regression analysis is when values for only one quantity are to
be input and whena linear relationship is expected between these values and the values to
be predicted. An example could be an Al system being used to predict marks for candidates
in an A Level Computer Science exam. There may be an expectation that there would be a
correlation between a candidate’s marks in an A Level Computer Science exam and their
marks in an IGCSE Mathematics exam. Figure 22.04 shows what might be found when some
historic data is input and analysed.

                              804

                              704
A Level Computer




                              60+
               Science mark




                              50+

                              40
                               -

                              304

                              20+

                              10
                               -

                              0       q           LJ          q    LJ
                                  0   20         40           60   80
                                           IGCSE Maths mark

Figure 22.04 An example of a linear regression analysis

There is good correlation between the two sets of marks. The straight line in Figure 22.04
is the one that has been calculated as the best fit to the data. The formula for the line can
sensibly be used to predict future marks for the A Level Computer Science paper from the
marks scored in an IGCSE Mathematics paper.
Cambridge International AS & A Level Computer Science




The regression analysis could be more complicated. For example, a similar fitting to a
mathematical formula can be carried out if marks for three different exams are used as
input. In other cases, a non-linear relationship might be appropriate as might happen when
a prediction of future sales of anew product was needed where the growth in sales was
expected to be exponential.



22.04 Artificial neural networks
The neural networks in our brains provide our intelligence. It therefore seems obvious that
artificial neural networks should be considered as a foundation for artificial intelligence
systems. Figure 22.05 shows a representation of two nerve cells.

                     Dendrites

       AY,              Cell body
              LZ                                       Synapse                          BZ
                            Nucleus         Signal           GPCG         5, a a,
                                                                               3 ee
                     Axon hillock          direction        (j
              \\                      _
                                      mY               SS
                »)


Presynaptic cell SS.Seq

                                  Myelin sheath Be               Postsynaptic cell
                     Axon                 Synaptic                    yep
                                          terminals


Figure 22.05 Two nerve cells showing howa signal is transmitted


At the one end ofa nerve cell there are many dendrites which can receive signals. At the
other end of the cell there are many axon terminal buttons that can transmit signals. The
synapse is the region between an axon terminal button and a dendrite which contains
neurotransmitters. When a nerve cell receives input signals the voltage in the axon increases.
At some threshold value ofthis voltage neurotransmitters are activated and signals are sent
to the dendrites of adjacent cells.




Figure 22.06 A schematic representation of a simple artificial neural network


An artificial neural network could be created in software or hardware. The components ofthe
network can be represented by a diagram as illustrated in Figure 22.06. The triangles are the
nodes in the network which represent artificial neurons. (Sometimes these are represented
as circles). In general,       anode can receive one or more inputs and can provide an output to
one or more ofthe other nodes. The modelling of the action of the node involves applying
a weighting factor
                 to each input. The weighted input values are summed and then an
activation function is used to compute a value for the output of the node. If the input is not a
numerical value it must be converted to one so that the weighted values can be summed.
                                                                                              Part 3: Chapter 22: Artificial Intelligence (Al)




Figure 22.06 shows a very simple network structure consisting of three layers. The column
of three nodes on the left receive input. The column on the right provides output. The two
nodes in between form what is referred to as a hidden layer. Some artificial neural networks
will contain several hidden layers.

An example of an Al system using an artificial neural network is one which estimates the
cost-effectiveness of batteries based on the initial price paid and the lifetime of use. Each
input node would represent one example of a battery. The inputs would be specific data that
identified the battery and the price. One of the nodes in the hidden layer could be concerned
with the type of device the battery was to be used in. The other node in the hidden layer
could relate to the type of user of the device. Each node in the output layer would compute
an estimated value for the cost per unit of time for a specific battery.

In this system there are adjustable factors for each node. These are the weighting factors
for each input and the activation function. When the initial learning is taking place, these
adjustable factors need to be tuned to achieve the optimum predictive capability of the system.
The method that can be used for this is back propagation of errors. There is a need for some
battery lifetime data from some real use of the batteries. The Al system is created with a set of
trial values for all of the adjustable factors. The system is run with the input data that matches
the real use. There will then be an error identified for each output node. The error is the
difference between the output value and the real-use value for the battery lifetime. The system
is then re-run with different values for the weighting factors and activation functions applying
to the output nodes. This will determine the dependency of the accuracy of the output value on
the adjustable factors associated with the performance ofthe nodes in the output layer.


   KEY TERM




   parameters which   are adjustable. It is applied first to the nodes     in the   output layer and   then works
    yackward   tnrougntne nodes
                              In      nidden layers   Until MNarly   tne INDUC   NOdeS   are CONSIGEred




The next step is to carry out a similar investigation for the nodes in the hidden layer. Finally,
the adjustable factors for the nodes in the input layer are tackled. This process of learning
should now be sufficient for the system to be applied to some new input data to predict the
cost-effectiveness of some different batteries. When more real-use data becomes available
then the back propagation of errors learning can be applied again to achieve improved
performance ofthe system.


Extension Question 22.01
An early successful application of an artificial neural network was NETtalk. This was able to
take a text as input and output a synthesised sound reading of the text. The network had 7
times 29 input nodes and 26 output nodes. Can you investigate why that number of input
nodes was chosen and what was the function of some ofthe 80 nodes in the hidden layer?


Deep Learning
itis understood that in the brain there is a layer structure of neurons where lower layers
have readily understandable functions but where higher layers are concerned with more
abstract processing of information. With the increasing computing power now available,
artificial neural networks are being introduced with large numbers of hidden layers which are
attempting to achieve something similar. These are known as Deep Learning systems.
Cambridge International AS & A Level Computer Science




rr
    Deep learning: where a system uses an artificial neural network with an exceptionally large number of
    hidden layers




Reflection Point:
Could you create a hierarchical chart to show how the various approaches discussed in this
chapter are related to each other?




    Summary




Exam-style Questions

1   The diagram below shows a graph representing the cost of journeys between railway stations
    identified by A, B, C, D, E and F.




         ~X ome                       4



    Dijkstra’s algorithm is to be used to find the total cost for journeys from station A to each
    of the other stations. A record structure is to be used to store for each station the cost for
    the travel so far and the list of stations so far visited in the order visited. Complete the
    table below to record the progress ofthe algorithm by identifying which nodes are in the
    ShortestPath set and what would be stored in the record at each step of the algorithm.
                                                                               Part 3: Chapter 22: Artificial Intelligence (Al)




    The first two rows of the table have been completed for you.


         Content of the
        ShortestPath set                               Content of the record


                  if               A            B          C            D           E            F
                                   0           fore)                   fore)       rove)        fore)




                  {A}              A            B          C            D           E            F
                                   0           10                      co          co          25
                                   A          A-B                                              A-F

                                   A            B          C            D           E            F




                                   A            B          C            D           E            F




                                   A            B          C            D           E            F




                                   A            B          C            D           E            F




                                   A            B          C            D           E            F



                                                                                                             [7]

2   The diagram below represents an artificial neural network.

    a     Giveas full a description as you can of what the parts of the diagram represent. If
          you wish you can label the diagram then use the labels in your answer.                             [5]




    b     identify the steps involved when a backward propagation of errors algorithm is used.               [4]

3   a     Givea    brief explanation of each of the following terms:

          Machine learning

         Artificial neural network

          Deep learning
                                                                                                             ‘Oo




    b   = Explain which approach uses back propagation of errors.
                                                                                                             NS
                                           =              a                                                                >
                               =                          i                                             .                  am                   7
                                                           a                                             7


                                                            ‘                                            *                  a                        *



                                                                                                                            t


                                                                                      a                 ae




Chapter 23:
Algorithms


By the end of this chapter you should be able to:

   show understanding of linear and binary searching methods             write algorithms to:
   write a linear search algorithm                                       *   implement an insertion sort
   write a binary search algorithm                                       ¢   implementa bubble sort
   show understanding of the conditions necessary for the use of a       -   find an item in each of the following: linked list, binary tree
   binary search
                                                                         *   insert an item into each of the following: stack, queue, linked list,
   show understanding of how the performance of a binary search varies
                                                                             binary tree
   according to the number of data items
                                                                         *   delete an item from each of the following: stack, queue, linked list
   show understandingof insertion sort and bubble sort methods
                                                                         show understanding that a graph is an example of an ADT
   show understanding that performance of a sorting routine may depend
                                                                         describe the key features of a graph and justify its use for a given
   on the initial order of the data and the number of data items
                                                                         situation
   show understanding of and use Abstract Data Types (ADT)
                                                                         show understanding that different algorithms which perform the same
   show how it is possible for ADTs to be implemented from another ADT
                                                                         task can be compared by using criteria such as time taken to complete
   describe the following ADTs and demonstrate how they can be
                                                                         the task and memory used
   implemented from appropriate built-in types or other ADTs: stack,
                                                                         show understanding of Big O notation for time and space complexity.
   queue, linked list, dictionary, binary tree
Cambridge International AS & A Level Computer Science




23.01 Linear search
in Chapter 13, we developed the algorithm for a linear search (Worked Example 13.02).


Discussion Point:
What were the essential features of a linear search?



  TASK 23.01

  Write program code for the linear search algorithm. Assume that the items to be
  searched are stored in a 1D array with n elements.




23.02 Bubble sort
In Chapter 13, we developed the algorithm for a bubble sort (Worked Example 13.03).


Discussion Point:
What were the essential features of a bubble sort?



  TASK 23.02

  Write program code for the most efficient bubble sort algorithm. Assume that the
   items to be sorted are stored in a 1D array with n elements.




23.03 Insertion sort
Imagine you have a number of cards with a different value printed on each card. How would
you sort these cards into order of increasing value?

You can consider
              the pile of cards as consisting ofa sorted part and an unsorted part. Place
the unsorted cards ina pile on the table. Hold the sorted cards as a pack in your hand. To
start with only the first (top) card is sorted. The card on the top of the pile on the table is the
next card to be inserted. The last (bottom) card in your hand is your current card.

Figure 23.01 shows the sorted cards in your hand as blue and the pile of unsorted cards as
white. The next card to be inserted is shown in red. Each column shows the state ofthe pile
as the cards are sorted.

Position
number


   :
   0


   2         54                                                                                       Key

   4
   3
             93
             17
                             93
                             17
                                                                                                      re Next card
                                                                                                            Sorted

   5         28              28                                                                             Unsorted

Figure 23.01 Sorting cards
                                                                                               Part 4: Chapter 23: Algorithms




Repeat the following steps until all cards in the unsorted pile have been inserted into the
correct position.

1 ~— Repeat until the card to be inserted has been placed in its correct position.

1.1      Compare the current card with the card to be inserted.

1.2.     Ifthe card to be inserted is greater than the current card, insert it below the
         current card.

1.3.     Otherwise, if there is a card above the current card in your hand, make this your new
         current card.

1.4      |f there is no new current card, place the card to be inserted at the top of the sorted pile.

What happens when you work through the sorted cards to find the correct position for the
card to be inserted? In effect, as you consider the cards in your hand, you move the current
card down a position. If the value of the card to be inserted is smaller than the last card you
considered, then the card is inserted at the top of the pile (position 1).

This method is known as an insertion sort. It is a standard sort method.

We can write this algorithm using pseudocode. Assume the values to be sorted are stored in
a 1D array, List:

    FOR Pointer < 1 TO NumberOfitems              -   1

           ItemToBeInserted < List[Pointer]

           CurrentItem < Pointer - 1 // pointer to last item in sorted part of list
          WHILE    (List[CurrentItem]      > ItemToBeInserted)        AND   (CurrentItem > -1)      DO
                List[CurrentItem + 1]        < List[CurrentItem]       // move current item down
                CurrentItem < CurrentItem - 1             //   look at the item above
           ENDWHILE

           List[CurrentItem + 1]       < ItemToBeInserted //         insert item
    NEXT    Pointer



    TASK 23.03

    1     Dry-run the insertion sort algorithm using a trace table. Assume the list consists
          of the following six items in the order given: 53, 21, 60, 18, 42, 19.
    2     Write program code for the insertion sort algorithm. Assume that the items to be
          sorted are stored in a 1D array with n elements.




Extension Question 23.01
Investigate the performances of the insertion sort and the bubble sort by:

e   varying the initial order of the items
e       increasing
                the number
                       of items to be sorted.


23.04 Binary search
In Section 23.01 we considered the algorithm for a linear search. This is the only way we can
systematically search an unordered list. However, if the list is ordered, then we can use a
different technique.
Cambridge International AS & A Level Computer Science




Consider the following real-world example.

if you want to look up a word in a dictionary, you are unlikely to start searching
                                                                              for the word
from the beginning of the dictionary. Suppose you are looking for the word ‘quicksort’. You
look at the middle entry ofthe dictionary (approximately) and find the word ‘magnetic’.
‘quicksort’ comes after ‘magnetic’, so you look in the second half of the dictionary. Again, you
look at the entry in the middle ofthis second half of the dictionary (approximately) and find
the word ‘report’. ‘quicksort’ comes before ‘report’, so you look in the third quarter. You can
keep looking at the middle entry of the part which must contain your word, until you find the
word. If the word does not exist in the dictionary, you will have no entries in the dictionary left
to find the middle of.

This method is known as a binary search. It is a standard method.


Qt
   Binary search: repeated checking of the middle item in an ordered search list and discarding
                                                                                             the half
   of the list which does not contain the search item




We can write this algorithm using pseudocode. Assume the values are sorted in ascending
order and stored in a 1D array, List of sizeMaxItems.

  Found <«         FALSE

  SearchFailed <                  FALSE

  First       <    0

  Last < MaxiItems                  -    1    //       set    boundaries                   of   search area

  WHILE       NOT          Found AND NOT                SearchFailed DO

        Middle <              (First          +       Last)   DIV 2             //    find middle of          current   search area

         IF       List[Middle]               =    SearchItem

              THEN

                   Found <«         TRUE

              ELSE

                   IF      First        >=    Last       //   no    search area                    left

                           THEN

                             SearchFailed < TRUE

                           ELSE

                             IF   List[Middle]                >    SearchItem

                                  THEN           //    must    be       in          first       half

                                    Last < Middle                   -       1        // move upper boundary

                                  ELSE           //    must    be       in          second half

                                    First < Middle                      +       1     //    move       lower boundary

                             ENDIF

                   ENDIF

         ENDIF

  ENDWHILE

  IF   Found           =   TRUE

       THEN

         OUTPUT Middle                   //       output position where                            item was   found

       ELSE

         OUTPUT             "Item not             present         in        array"

  ENDIF
                                                                                                          Part 4: Chapter 23: Algorithms




  TASK 23.04

  1    Dry-run the binary search algorithm using a trace table. Assume the list consists
       of the following 20 items in the order given: 7, 12, 19, 23, 27, 33, 37, 41, 45, 56, 59,
       60, 62, 71, 75, 80, 84, 88, 92, 99.
  2    Search for the value 60. How many times did you have to execute the While loop?
  3    Dry-run the algorithm again, this time searching for the value 34. How many times
       did you have to execute the While loop?




Discussion Point:
Compare the binary-search algorithm with the linear-search algorithm. If the array contains
n items, how many times on average do you need to test a value when using a binary search
and how many times on average do you need to test a value when using a linear search? Can
you describe how the search time varies with increasing n?



23.05 Abstract Data Types (ADTs)
in Chapter 13 (Section 13.07 to 13.10), we introduced ADTs using conceptual diagrams and
how ADTs can be implemented using arrays.



23.06 Linked lists
Look back at Chapter 13 Section 13.10. Figure 13.25 shows an empty linked list. The
StartPointer variable contains the Null pointer. The free list links all empty nodes.

We now code the basic operations discussed using the conceptual diagrams in Figures 13.11
to 13.16.



Create a new linked list
  // NullPointer            should be         set   to   -1   if using array element with index             0

  CONSTANT NullPointer               =   -1

  //   Declare    record type            to    store data and pointer

  TYPE      ListNode

         DECLARE       Data      :       STRING

         DECLARE       Pointer   :       INTEGER

  ENDTY PE

  DECLARE       StartPointer         :   INTEGER

  DECLARE       FreeListPtr          :   INTEGER

  DECLARE       List    :   ARRAY[O       :   6]    OF   ListNode


  PROCEDURE       InitialiseList

         StartPointer < NullPointer                                //   set   start pointer

         FreeListPtr < 0                                           //   set   starting position of   free   list

         FOR Index < 0 TO 5                                        //   link all nodes   to make   free   list

                List [Index].Pointer <               Index    +     1

         NEXT    Index

         List[6].Pointer < NullPointer                        //    last node of     free   list

  ENDPROCEDURE
Cambridge International AS & A Level Computer Science




Insert a new node into an ordered linked list
  PROCEDURE        InsertNode(NewlItem)

       IF    FreeListPtr             <>   NullPointer

            THEN     //       there       is   space   in    the        array

              //   take node              from free     list           and    store          data       item

              NewNodePtr < FreeListPtr

              List [NewNodePtr].Data < NewlItem

              FreeListPtr < List[FreeListPtr].Pointer

              //   find       insertion point

              ThisNodePtr < StartPointer                               //    start          at beginning of               list

              PreviousNodePtr < NullPointer

              WHILE ThisNodePtr                  <> NullPointer                    //    while not             end of     list

                   AND    List[ThisNodePtr].Data                        <   NewlItem DO

                     PreviousNodePtr <« ThisNodePtr                                    //    remember          this      node

                     //       follow      the pointer             to    the       next      node

                     ThisNodePtr <               List[ThisNodePtr].Pointer

              ENDWHILE

              IF    PreviousNodePtr               =    StartPointer

                   THEN        //    insert      new node          at       start       of       list

                     List[NewNodePtr].Pointer <                             StartPointer

                     StartPointer < NewNodePtr

                   ELSE        //    insert      new node between previous                                  node   and    this   node

                     List [NewNodePtr].Pointer <                            List[PreviousNodePtr].Pointer

                     List[PreviousNodePtr].Pointer < NewNodePtr

              ENDIF

       ENDIF

  ENDPROCEDURE


After three data items have been added to the linked list, the array contents are as shown in
Figure 23.02.

                                                                                        List
                                                                            Data                 Pointer

                                                            [0]               B                         1

StartPointer              0                                 [1]               D                         2

                                                            [2]               L                     -1


 FreeListPtr              3                                 [3]                                      4

                                                            [4]                                         5

                                                            [5]                                         6

                                                            [6]                                     -1


Figure 23.02 Linked list of three nodes and free list of four nodes


Find an element in an ordered linked list
  FUNCTION FindNode(DataItem)                     RETURNS              INTEGER              //   returns pointer to node

       CurrentNodePtr < StartPointer                               //       start       at beginning of                  list

       WHILE       CurrentNodePtr               <> NullPointer                    //    not      end of        list

            AND List[CurrentNodePtr].Data                              <>   DataItem DO             //       item not      found

              //   follow           the pointer        to    the        next       node

              CurrentNodePtr <« List[CurrentNodePtr].Pointer
                                                                                                              Part 4: Chapter 23: Algorithms




       ENDWHILE

       RETURN CurrentNodePtr              //    returns NullPointer if               item not       found

 ENDFUNCTION




Delete a node from an ordered linked list
 PROCEDURE       DeleteNode(DatalItem)

       ThisNodePtr < StartPointer                                     //   start at beginning of               list
       WHILE ThisNodePtr          <> NullPointer                      // while not     end of          list

         AND List[ThisNodePtr].Data <> DataItem DO                          //   and item not          found

            PreviousNodePtr < ThisNodePtr                      //    remember this node

            //   follow the pointer to the next node

            ThisNodePtr < List[ThisNodePtr].Pointer

       ENDWHILE

       IF ThisNodePtr          <> NullPointer          //   node exists          in list

         THEN

            IF ThisNodePtr =           StartPointer          //     first node     to be deleted

                 THEN

                   // move      start pointer to the next node                     in list

                   StartPointer < List[StartPointer].Pointer

                 ELSE

                   //   it    is not   the     start node;

                   //   so make    the previous node’s pointer point                       to

                   //   the    current    node’s      ‘next!      p pointer;     thereby Y removing all

                   //   veferences       to    the   current pointer             from the    list

                   List[PreviousNodePtr].Pointer < List[ThisNodePtr].Pointer

            ENDIF

            List[ThisNodePtr].Pointer < FreeListPtr

            FreeListPtr < ThisNodePtr

       ENDIF

 ENDPROCEDURE




Access all nodes stored in the linked list
  PROCEDURE      OutputAllNodes

       CurrentNodePtr < StartPointer //                     start at beginning of               list

       WHILE CurrentNodePtr <> NullPointer DO // while not end of                                      list

            OUTPUT List[CurrentNodePtr].Data

            //   follow the pointer to the next node

            CurrentNodePtr < List[CurrentNodePtr].Pointer

       ENDWHILE

  ENDPROCEDURE




  TASK 23.05

  Convert the pseudocode for the linked-list handling subroutines to program code.
  Incorporate the subroutines into a program and test them.



Note that a stack ADT and a queue ADT can be treated as special cases of linked lists. The
linked list stack only needs to add and remove nodes from the front ofthe linked list (see
Section 23.08). The linked list queue only needs to add nodes to the end of the linked list and
remove nodes from the front ofthe linked list (see Section 23.09).
      Cambridge International AS & A Level Computer Science




      23.07 Binary trees
       In the real world, we draw tree structures to represent hierarchies. For example, we can draw
      a family tree showing ancestors and their children. A binary tree is different to a family tree
       because each node can have at most two ‘children’.

       In computer science binary trees are used for different purposes. In Chapter
                                                                                  20 (Section 20.06),
      you saw the use of
                       a binary tree as a syntax tree. In this chapter, you will use an ordered binary
      tree ADT (such as the one shown in Figure 23.03) as a binary search tree.

                                                            Root node




        Parent/child node




                                                    NN
      Left subtree                                  Leaf node                      Right subtree

      Figure 23.03 Conceptual diagram of an ordered binary tree


      Nodes are added to an ordered binary tree in a specific way:
418

              Start at the root node as the current node.

              Repeat

                 If the data value is greater than the current node’s data value, follow the right branch.

                 If the data value is smaller than the current node’s data value, follow the left branch.

              Until the current node has no branch to follow.

              Add the new node in this position.

      For example, if we want to add a new node with data value D to the binary tree in Figure 23.03,
      we execute the following steps.

              Start at the root node.
      oF




              D is smaller than F, so turn left.
       W NY




              D is greater than C, so turn right.

              D is smaller than E, so turn left.

              There is no branch going left from E, so we add D as a left child from E (see Figure 23.04).

      This type of tree has a special use as a search tree. Just like the binary search applied to an
      ordered linear list, the binary search tree gives the benefit ofa faster search than a linear
      search or searching a linked list. The ordered binary tree also has a benefit when adding a
      new node: other nodes do not need to be moved, only a left or right pointer needs to be
      added to link the new node into the existing tree.
                                                                                                                                 Part 4: Chapter 23: Algorithms




Figure 23.04 Conceptual diagram of adding a node to an ordered binary tree


We can store the binary tree in an array of records (see Figure 23.05). One record represents a
node and consists of the data and a left pointer and a right pointer. Unused nodes are linked
together to form a free list.

                                                                                       Tree

RootPointer|           -1                               LeftPointer                    Data       RightPointer

                                           [0]                    1

                                           [1]                    2

     FreePtr           0                   [2]                    ;
                                           [3]                    4

                                           [4]                    5

                                           [5]                    6

                                           [6]                   -1



Figure 23.05 Binary tree before any nodes are inserted


Create a new binary tree
  // NullPointer should be                                  set to     -1    if using array element with index 0

  CONSTANT NullPointer                         =   -1

  // Declare record type to store data and pointers

  TYPE    TreeNode

         DECLARE       Data       :    STRING

         DECLARE       LeftPointer                      :       INTEGER

         DECLARE       RightPointer                         :    INTEGER

  ENDTYPE

  DECLARE       RootPointer                :       INTEGER

  DECLARE       FreePtr       :       INTEGER

  DECLARE       Tree    :   ARRAY[O                 :       6]   OF   TreeNode

  PROCEDURE       InitialiseTree

         RootPointer < NullPointer                                    //    set    start pointer

         FreePtr < 0                                                  //    set     starting position of           free   list

         FOR    Index <«      0       TO       5                      //     link      all    nodes   to make     free   list

                Tree[Index].LeftPointer <                                   Index +      1

         NEXT    Index

         Tree[6].LeftPointer < NullPointer                                        //   last    node   of   free   list

  ENDPROCEDURE
                                                    PROCEDURE                               Insert Node (Ne
                                                                                                                                          wItem)
                                                                   IF             PreePtr                     es        NuliPointer

                                                                          THEN
                                                                                                  t

                                                                                                 // //        there               is      space         in    the     arr ay
                                                                                   //       take               noda              from        frea        list ,       Store    data        item,      set   null
                                                                                   NewNodePtr                                                                                                                        pointers
                                                                                                                             «   BreePrr

                                                                                   PreePtr                    «         Tree (FreePtr]
                                                                                                                                                        LeftPointer
                                                                                  Tree (NewNodeP
                                                                                                                                 tr] Data          an
                                                                                                                                                        Newlram
                                                                                  Tree[NewNodePtr
                                                                                                                                      ] .LeftPointer
                                                                                                                                                                  =   Nul iLPointer
                                                                                  Tree[NewNodePtr
                                                                                                                                   ].RigtioPointer
                                                                                                                                                                    « NMyl lPointer
                                                                                                               if            eatipty        tree

                                                                                  If        RootPointer
                                                                                                                                      =   NullPoi nter

                                                                                       THEN                   //        ins ark             new    pode        at     root
                                                                                            RootPointer                                « NewNodePtr

                                                                                    ELSE                      //        find           insertion             point
                                                                                            ThisNodePtr                                « RoctPointer
                                                                                                                                                                        //    Start        at   the    root    of    the
                                                                                            WHILE                                                                                                                          tree
                                                                                                                   ThisNodePtr                     <>        NullPointer
                                                                                                                                                                                po         // while not         a
                                                                                                             PreviousNode
                                                                                                                                                                                                                     Leaf node
                                                                                                                                             Ptr        «     ThisNodePtr
                                                                                                                                                                                      //    remember this nod
                                                                                                             Te         Tree[ThisNodePt
                                                                                                                                                                                                              e
                                                                                                                                                            rl] Data     >    Newltem
                                                                                                                  THEN                //    £ollow           left     pointer
                                                                                                                         TurnedLeft                 <       ‘TRUE

                                                                                                                         ThisNodePtr                    « Tres[T hisNod
                                                                                                                                                                        e Ptr              ] .LefttPointer
      hres




                                                                                                               BLSE               //      follow
                   Me
    san




                        mn
              aa




                                                                                                                                                        bight       pointer
                   Be
        BRE




8
                                                                                                                        TurnedLeft
                                                                                                                                                   «        PALSE

                                                                                                                        ThisNodePtr                     «    Tree[ThisNode
                                                                                                                                                                                     Ptr] .RightPoi
                                                                                                                                                                                                            nter
                                                                                                         ENDIF

                                                                                        ENDWHILE

                                                                                        If        Turnediefr
                                                                                                                                            TRUE

                                                                                                 THEN

                                                                                                      Tree[Previou
                                                                                                                                           sNodept vr] beftPo
                                                                                                                                                                         inter        aa

                                                                                                                                                                                           NewNodePrr
                                                                                                ELSE

                                                                                                      Tree [Previous
                                                                                                                                            NodePtr] Right
                                                                                                                                                                        Pointer           < NewNodePtr
                                                                                    ENDIP

                                                                    ENDIF

                                                     ENDIF

                                   ENDPROCEDURE



                             ~~             >        .             Fan
                             Bed
                             P
                                   Se   ork

                                        x
                                                wy   oy   PAST
                                                                         OR   Te            x                           Se
                             SOREN
                                                                              FER
                                                ~                                      ay

                                  E oF
                                                          &   Ae                            Ba

                                                     See ee
                                                                         Tk                       ese    oe
                                                                              &        a
                                                                                                              ye


                                                                              pss ag SSE SAS
                                                                                                                         Fee     es
                                                                                                         .         Ny

                                                                                                                   Fue ae
                                                                                                                             wna




                                  FUNCTION                               FindNode (Searc
                                                                                         hItem)                                             RETURNS            INTEGER          //    reLurns         pointer
                                                ThisNodePtr                                      «                                                                                                                   to   node
                                                                                                         RootPointer
                                                                                                                                                        //    start     at     the    root       of   the     tree
                                                WAILE                     ThisNodePtr
                                                                                                                        <s       NullPointer
                                                                                                                                                                // while a pointe
                                                         AND                                                                                                                      r to                      follow
                                                                          Tree [ThisNode
                                                                                                                         Ptr]             Data    <>        Searchitem         DO    //    and     sea roeh
                                                              IF              Tree [ThisNode                                                                                                                   item   nor    found
                                                                                                                             Prr)

                                                                          THEN                   //          Follow               left       pointer
                                                                                  ThisNodePtr                                «. Tree[This Yod
                                                                                                                                              ePrtr}                    LeftPointer
                                                                         ELSE               //        follow                     right      pointer
                                                                                  ThisNodePtr <
                                                                                                Tree[T nisNodePt
                                                                                                                 r].                                                    Right Pointer
                                                              ENDIF

                                                ENDWHILE
                                                                                                                             Part 4: Chapter 23: Algorithms




        RETURN ThisNodePtr                  // will                return null pointer                  if   search item not      found

    ENDFUNCTION




    TASK 23.06

    Write program code to implement a binary search tree.




23.08 Stacks
In Chapter 13 (Section 13.08) we looked at the conceptual data structure of a stack.                                     Astack
can be implemented using a 1D array. Figure 23.06 shows a stack containing four data items.
For conceptual reasons the array elements are numbered from the bottom up.

Note that BaseofStackPointer will always point to element 0 of the array.
TopOfStackPointer will vary. It will increase when an item is pushed onto the stack
and it will decrease when an item is popped off the stack. When the stack is empty,
TopOfStackPointer will have the value -1.
~




6
5
4


3      D      < TopOfStackPointer
2      C
1      B
0      A      < BaseOfStackPointer


Figure 23.06 A stack


Create a new stack
    // NullPointer       should be               set         to    -1    if using array element with index                    0

    CONSTANT       EMPTYSTRING      =       ""

    CONSTANT NullPointer            =       -1

    CONSTANT MaxStackSize               =    8

    DECLARE BaseOfStackPointer                           :    INTEGER

    DECLARE TopOfStackPointer                        :       INTEGER

    DECLARE    Stack    :    ARRAY[1         :       MaxStackSize            -       1]   OF       STRING


    PROCEDURE       InitialiseStack

           BaseOfStackPointer < 0                                            //       set base of            stack pointer

           TopOfStackPointer < NullPointer                                   //      set   top of        stack pointer

    ENDPROCEDURE




Push an item onto the stack
    PROCEDURE       Push(NewlItem)

           IF TopOfStackPointer                  <       MaxStackSize            -    1

             THEN           //   there       is          space on the            stack

                            //   increment                   top    of   stack pointer

               TopOfStackPointer < TopOfStackPointer                                           +    1

                            //   add item to top of                        stack

               Stack [TopOfStackPointer]                            < NewItem

           ENDIF

    ENDPROCEDURE
      Cambridge International AS & A Level Computer Science




      Pop an item off the stack
          FUNCTION           Pop()

                   DECLARE      Item          :    STRING

                   Item <      EMPTYSTRING

                   IF   TopOfStackPointer                         >       NullPointer

                        THEN             //       there       is          at    least          one       item on          the   stack

                                         // pop          item off                   the   top of           the       stack
                            Item <       Stack[TopOfStackPointer]

                                         //       decrement                top       of    stack pointer
                         TopOfStackPointer < TopOfStackPointer                                                       -    1

                   ENDIF

                   RETURN      Item

          ENDFUNCTION




          TASK 23.07

           1   Write a program to implement the above pseudocode subroutines. Add a menu
               to test the subroutines.
           2   Write a program to implement a stack as a linked list. Note that the adding and
               removing of nodes is much simpler than for an ordered linked list.




      23.09 Queues
      In Chapter 13 (Section 13.09) we looked at the conceptual data structure of a queue. A queue
fee   can be implemented using a 1D array. Figure 23.07 shows a queue containing five data items.

      FrontOfQueuePointer always points to the first element in the queue, that is the next
      element to be taken from the queue. EndofQueuePointer always points to the last element in
      the queue. Before another element joins the queue, the EndoO£QueuePointer is incremented.
      Note that when adjusting either pointer the possibility of wrap-round has to be tested.

      To make it easier to test whether the queue is empty or full, a counter variable can be used.

      0        A    | < FrontOfQueuePointer                                                     0          |
      1        B                                                                                1          J
      2        C                                                                                2                    <    EndOfQueuePointer

      3        D                                                                                3
      4        E        <    EndOfQueuePointer                                                  4

      5                                                                                         5          F         <    FrontOfQueuePointer

      6                                                                                         6          G
      7                                                                                         7          H



      Figure 23.07 A queue before wrap-round                                                    Figure 23.08 A queue with wrap-round


      Create a new queue
          //   NullPointer           should be                    set          to   -1    if    using array element                     with    index    0

          CONSTANT          EMPTYSTRING              =       ""

          CONSTANT          NullPointer             =        -1

          CONSTANT          MaxQueueSize                 =    8

          DECLARE        FrontOfQueuePointer                               :    INTEGER

          DECLARE        EndOfQueuePointer                            :    INTEGER

          DECLARE        NumberInQueue                   :    INTEGER

          DECLARE        Queue       :   ARRAY[O              :    MaxQueueSize                      -    1]    OF       STRING

          PROCEDURE          InitialiseQueue

                FrontOfQueuePointer                          < NullPointer                           //        set   front      of   queue     pointer
                                                                                                                                                  Part 4: Chapter 23: Algorithms




       EndOfQueuePointer < NullPointer                                                          //          set   end of          queue pointer
       NumberInQueue <                   0                                                          //      no    elements            in queue
 ENDPROCEDURE




Add an item to the queue
 PROCEDURE         AddToQueue (NewItem)

       IF   NumberInQueue                    <    MaxQueueSize

            THEN           //       there                 is    space         in       the      queue
                           //       increment                       end of         queue pointer

              EndOfQueuePointer < EndOfQueuePointer                                                               +   1

                           //       check                 for wrap-round
              IF    EndOfQueuePointer                                >   MaxQueueSize                        -    1

                   THEN              //          wrap           to beginning                        of      array
                     EndOfQueuePointer <                                  0

                                         //       add           item to end of                           queue
              ENDIF

              Queue [EndOfQueuePointer]                                   < NewItem

               //    inerement                   counter

               NumberInQueue                          <« NumberInQueue                          +       1

       ENDIF

 ENDPROCEDURE




Remove an item from the queue
 FUNCTION      RemoveFromQueue()

       DECLARE       Item       :    STRING

       Item   <     EMPTYSTRING

       IF   NumberInQueue                    >        0

            THEN    //    there          is       at           least      one          item         in       the      queue
                    //    remove             item              from the            front            of       the      queue

              Item < Queuve[FrontOfQueuePointer]

              NumberiInQueue                     <«       NumberInQueue                     -       1

              IF    NumberInQueue                          =    0

                   THEN    //       if    queue                 empty,        reset             pointers
                     CALL       InitialiseQueue

                   ELSE

                     //    increment                       front         of   queue pointer
                     FrontOfQueuePointer <                                     FrontOfQueuePointer                                +   1

                     //    check             for wrap-round
                     IF    FrontOfQueuePointer                                     >       MaxQueueSize                   -   1

                          THEN       //          wrap           to beginning                        of      array
                          FrontOfQueuePointer <                                        0

                     ENDIF

              ENDIF

       ENDIF

       RETURN       Item

 ENDFUNCTION




  TASK 23.08

  1   Write a program to implement the above pseudocode subroutines. Add a menu
      to test the subroutines.
  2   Write program code to implement a queue as a linked list. You may find it helpful
      to introduce another pointer that always points to the end of the queue. You will
      need to update it when you add a new node to the queue.
Cambridge International AS & A Level Computer Science




23.10 Graphs
In Computer Science a graph is an ADT consisting of vertices (nodes) and edges. Graphs
are used to record relationships between things. For uses of graphs in Al see Chapter 22
Section 22.02. A simple graph is shown in Figure 23.09. It represents a small part of the
London Underground map shown in Figure 12.02 in Chapter 12.




Figure 23.09 Graph showing part of the London Underground map


The vertices labelled A to F are the underground stations and the edges represent train
lines connecting
              the stations. For example, you can take a train directly from B to D. To get
from B to F, you have to travel via C or E. Two vertices connected by an edge are known as
neighbours.

A labelled (weighted) graph has edges with values representing something. In our example,
we can add weights to Figure 23.10 to show the time it takes to travel between stations:




OO
Yd
Figure 23.10 Weighted graph showing travelling times between stations



Graphs can be directed or undirected (as in Figure 23.10). Travel times may vary depending
on the direction of travel. This can be shown in a directed graph (see Figure 23.11).




re
      <=O--@
Figure 23.11 Directed graph



Sometimes one direction may not be available. For example, if the line from B to D is blocked,
this could be represented as shown in Figure 23.12.
                                                                                               Part 4: Chapter 23: Algorithms




EAP
oaths
Figure 23.12 Directed graph


We can use a graph to plan a journey. Using Figure 23.12, we want to travel from C to D, so we
can either use the route C     BAD   (11 minutes) or the route C F E D (9 minutes). For the return
journey we can use D BC      (7 minutes).



  TASK 23.09

  Draw the labelled edges for a directed graph of a road system where:
  e   Ato Bis2km, and it is a one-way system
  e   DtoAis1km, and is one-way
  ¢   Bto Dis 3 km and is one-way
  e   BtoCis4km
  e   CtoEis7km
  e   DtoEis5km.




To implement a graph, we can use an adjacency matrix or an adjacency list.

An adjacency matrix stores the relationship between every vertex to all other vertices. For an
unweighted graph, a 1 represents an edge, a0 no edge. When weights are to be recorded, the
weight replaces the 1. Instead ofa 0, we use the infinity symbol




Table 23.01                                         Table 23.02

Adjacency matrix for Figure 23.09                   Adjacency matrix for Figure 23.12
Cambridge International AS & A Level Computer Science




An adjacency list stores the relationship between every vertex to all relevant vertices. An
entry is made only when there is an edge between two vertices. For a weighted graph, the
connection as well as the weight is stored in the list.

         connected to                               connected to
                                                    B, 3;D,5

                                                    A, 3; C, 3; E,
                                                                 4

                                                    B,3;F,2

                                                    A, 5; B, 45 E, 2

                                                    B, 4; D, 4; F, 2

                                                    C,3;E,3


Table 23.03                                    Table 23.04

Adjacency list for Figure 23.09                Adjacency list for Figure 23.12


    TASK 23.10

    Construct an adjacency matrix and an adjacency list to represent your graph from
    Task 23.09.




23.11 Hash tables
lfwe want to store records in an array and have direct access to records, we can use the
concept of a hash table.

The idea behind a hash table is that we calculate an address (the array index) from the
key value of the record and store the record at this address. When we search for a record,
we calculate the address from the key and go to the calculated address to find the record.
Calculating an address from a key is called ‘hashing’.

Finding a hashing function that will give a unique address from a unique key value is very
difficult. If two different key values hash to the same address this is called a ‘collision’. There
are different ways to handle collisions:

e   chaining: create a linked list for collisions with start pointer at the hashed address
e   using overflow areas: all collisions are stored in a separate overflow area, known as
    ‘closed hashing’

e   using neighbouring slots: perform a linear search from the hashed address to find an
    empty slot, known as ‘open hashing’.



    WORKED EXAMPLE 23.01


    Calculating addresses in a hash table

    Assume we want to store customer records ina 1D array HashTable[o : n].Each customer has a unique
    customer ID, an integer in the range 10001 to 99999.

    We need to design a suitable hashing function. The result of the hashing function should be such that every
    index of the array can be addressed directly. The simplest hashing function gives us addresses between 0
    and n:

                                                                                                                  (Continued)
                                                                                                                         Part 4: Chapter 23: Algorithms




 FUNCTION Hash(Key)             RETURNS              INTEGER

       Address       <« Key MOD(n           +       1)

          RETURN Address

 ENDFUNCTION



  For illustrative purposes, we choose n to be 9. Our hashing function is:
                                        Index <«               CustomerID      MOD     10



 We want to store records with customer IDs: 45876, 32390, 95312, 64636, 23467. We can store the first three
 records in their correct slots, as shown in Figure 23.13.


    [0]       [1]        [2]          [3]                [4]        [5]      [6]           [7]       [8]       [9]
 | 32390 |           | 95312 |                  |               |         | 45876 |              |         |         |

 Figure 23.13 A hash table without collisions

 The fourth record key (64636) also hashes to index 6. This slot is already taken; we have a collision. If we store
 our record here, we lose the previous record. To resolve the collision, we can choose to store our record in
 the next available space, as shown in Figure 23.14.


    [0]       [1]        [2]          [3]                [4]        [5]      [6]           [7]       [8]       [9]
 | 32390 |           | 95312 |                  |               |         | 45876 | 64636 |                |         |

  Figure 23.14
             A hash table with a collision resolved by open hashing

 The fifth record key (23467) hashes to index 7. This slot has been taken up by the previous record, so again we
  need to use the next available space (Figure 23.15).


    [0]       [1]        [2]          [3]                [4]        [5]      [6]           [7]       [8]       [9]
 | 32390 |           | 95312 |                  |               |         | 45876 | 64636 | 23467 |                  |

  Figure 23.15 A hash table with two collisions resolved by open hashing

 When searching for a record, we need to allow for these out-of-place records. We know if the record we are
 searching for does not exist in the hash table when we come across an unoccupied slot.

 We will now develop algorithms to insert a record into a hash table and to search for a record in the hash
 table using its record key.

 The hash table is a 1D array HashTable[0                           : Max]    OF Record.

 The records stored in the hash table have a unique key stored in field Key.



Insert a record into a hash table
 PROCEDURE        Insert (NewRecord)

      Index < Hash(NewRecord.Key)

      WHILE       HashTable[Index]                  NOT        empty DO

             Index < Index +                1       //    go    to next      slot     to    check     if   empty

             IF     Index      > Max    //          beyond table boundary?

                  THEN   //    wrap     around to beginning of                         table

                     Index <      0

             ENDIF

      ENDWHILE
               HashTabletindex]                                « MewRecord

     ENDPROCEDURE



=         3          .         g   3         §            Be       Grandad
Re ESSE
      E       SR   SRSYENS SEE     eR   ME   Pave bs
SP            af PRS               Ee gb FP ASSS
                                                                   Pode iss
                                                                   PASS


     FUNCTION FindRecord(SearchkKey)                                                       RETORNS           Record
               Index « Hash(SearchKey)

               WHILE           (HashTable[iIndex].Key                                      <>        SaarchKey}
                    AND        (HashTable{Index]                                  NOT       empty)          bo

                          Index «            Index                  +       1   //    go    to        next       slot

                          If    Index            >    Max               //      beyond           table       boundary?

                               THEN      //      wrap                 around           to beginning                 of       table

                                   Index «                     0

                          BNDIE

               ENDWHILE

               If        HashTablelindex}                               NOT       empty          //    if    record          found

                    THEN

                          RETURN         HashTablefIndex]                                   //       return       the    record

              ENDIF

     ENDFUNCTION



                         _     4                     2
PR     OAR RS     edhe on, SE oth gs oh
 fo     8 & SSES YESS      Ss Se Pee
Geet a ofkiahs ESE. ER ERSS SEES Eee aS


A reat-world dictionary is a collection of key-value pairs. The key is the term you use to look
up the required value. For example, if you use an English-French dictionary to look up the
English word ‘book’, you will find the French equivalent word ‘livre’. A real-world dictionary is
organised in alphabetical order of keys.

An ADT dictionary in cornputer science is implemented using a hash table (see Section 23.11),
so that a value can be looked up using a cirect-access method.

Python, VB.NET and Java have 4 built-in ADT dictionary class.



          BnglishFrench =                            {}         #    empty dictionary

          EnglishFrench["book"}]                                        =       "livre"          #    add    a    key-value        pair   to   the    dictionary
       BnglishFrench["pen"]                                         =       "stylo"

       print(BnglishFrenchi"book"})                                                   #     access          a value          in   the   dictionary

       #       alternative                   method                  of         setting up             a    dictionary

       ComputingTerms                            =       {"Boolean"                    :    "can be TRUE                 or   FALSE",     "Rit"   :   "o   or   1°}
       print (ComputingTe
                        ["Bit"])
                          rms




       Dim          EnglishFrench                              As    New         Dictionary{Of                   String,       String)

       BnglishFrench                         Add("hook",                         °Liusrre®)

       BnglishFrench .Add("pan",                                                “styie*)

      Console WriteLine (EnglishFrench Ibem(book')})

       Him          ComputingTerms
      y




                                                                As      New          Dictionary(Of                Strina,

      ComputingTerms.Add("Boolaan",                                                         “e               v          OF

      ComputingTerms Add(*Sii®,                                                  Oo   axe

      Console .WriteLine (ComputingTerms.Item("S8ir")})

      Console. Readbine()
                                                                                                                                     Part 4: Chapter 23: Algorithms




Here are some examples of Java dictionaries (the Dictionary class is obsolete, use HashMap
instead):

  import       java.util.Map;

  import       java.util.HashMap;

         Map<String,                String>          englishFrench                      =    new HashMap<String,         String>();

         englishFrench.put("book",                             "livre");

         englishFrench.put("pen",                          "stylo");

         System.out.printin(englishFrench.get("book"));

         Map<String,                String>           computingTerms                         =   new HashMap<String,         String>();

         computingTerms.put("Boolean",                                      "can be              TRUE   or   FALSE");

         computingTerms.put("Bit",                             "0       or       1");

         System.out.println(computingTerms.get("Bit"));

There are many built-in functions for Python, VB and Java dictionaries. These are beyond the
scope of this book. However, we need to understand how dictionaries are implemented. The
following pseudocode shows how to create a new dictionary.

  TYPE    DictionaryEntry

         DECLARE       Key               :   STRING

         DECLARE       Value             :   STRING

  ENDTYPE

  DECLARE       EnglishFrench                    :   ARRAY[O            :    999]           OF   DictionaryEntry        //   empty
  dictionary



   TASK 23.11

   Write pseudocode to:

   e    insert a key-value pair into a dictionary

   e    look up a value in a dictionary.
   Use the hashing function from Worked Example 23.01.




23.13 Big O notation
A problem can be solved in different ways, with different algorithms. Clearly, we want to
use time and memory efficiently. A way of comparing the efficiency of algorithms has been
devised using order of growth as a function of the size of the input. Big O notation is used to
classify algorithms according to how their running time (or space requirements) grows as the
input size grows. The letter O is used because the growth rate of a function is also referred
to as ‘order of the function’. The worst-case scenario is used when calculating the order of
growth for very large data sets.

Consider
      the linear search algorithm in Chapter 13, Worked Example 13.02. The worst case
scenario is that the item searched for is the last item in the list. The longer the list, the more
comparisons have to be made. If the list is twice as long, twice as many comparisons have to
be made. Generally, we can say the order of growth is linear. We write this as O(n), where n is
the size of the data set.

Consider the bubble sort algorithm for the worst case scenario.

  Unsorted « n             -    1

  FOR    i<    0   TO n         -    2
         FOR   j   <   0       TO Unsorted             -   1

               IF MyList[j]                  >   MyListij           +       1]
Cambridge International AS & A Level Computer Science




                          THEN

                            Temp < MyList[j]

                           MyList[j]      < MyList[j           +   1]

                           MyList[j      +   1]       < Temp

                     ENDIF

         NEXT         3

         Unsorted < Unsorted                      -   1

  NEXT      i

The basic operation
               for this algorithm
                                is the comparison IF MyList[j]                             > Mybistij      + 1]


 n       | Number of comparisons
     1          0

     2          1

     3          3         =1+2

     4          6         =1+2+3

     5          10    | =14+24+3+4

     6          15    | =14+2+3+4+4+5


Table 23.05 Number of comparisons in bubble sort

We can see that the total number of comparisons is the sum of the first (n - 1) whole
numbers. This leads us to the formula:

Ye*n* (n-1)=%* (n?=n)

For very large n we can disregard all factors except the largest and we get n*. So the order of
growth is n?.

Consider
      the binary search algorithm in Section 23.04. With each iteration this algorithm
halves the numberof values in the data set. This iterative halving of data sets produces a
growth curve that peaks at the beginning and slowly flattens out as the size of the data sets
increase. This type of algorithm is described as O(log,n)

Table 23.06 shows a summary of standard algorithms and their order of growth (time
complexity).

 Order of growth | Example                                                            | Explanation
 O(1)                            FUNCTION GetFirstItem(List             :   ARRAY)   | The complexity of the algorithm does not change
                                 RETURN List [1]                                       regardless of data set size

 O(n)                            Linear search                                         Linear growth
                                 Bubble sort performed on an already sorted list

 O(log,n)                        Binary search                                         The total time taken increases as the data set size
                                                                                       increases, but each comparison halves the data set.
                                                                                       So the time taken increases by smaller amounts and
                                                                                       approaches constant time.

 O(n?)                           Bubble sort                                           Polynomial growth
                                 Insertion sort                                        Common with algorithms that involve nested iterations
                                                                                       over the data set

 O(n?)                                                                                 Polynomial growth
                                                                                       Deeper nested iterations will result in O(n’), O(n’), ...

 Q(2")                           Recursive calculation of Fibonacci numbers            Exponential growth


Table 23.06 Order of growth (time complexity) for data input set of size n

Space complexity refers to the amount of memory required for a growing number of values n in
the dataset.
                                                                                                          Part 4: Chapter 23: Algorithms




The ADT operations discussed in this chapter have space complexity O(n). This means that
they only take the space required for the data set. Bubble sort and insertion sort have space
complexity of O(1). This means they do not require extra memory for sorting larger lists.


Reflection Point:
List the standard algorithms you have met in this chapter. Can you give the essential features
of each of these?




    Summary




Exam-style Questions

1   a    Complete the algorithm for a binary search function FindName.

        The data being searched is stored in the array Names[0                 :   50].

        The name to be searched for is passed as a parameter.
         FUNCTION     FindName(s         :   STRING)       RETURNS      INTEGER

              Index <       -1

              First <       0

              Last    <    50

              WHILE       (Last    >=   First)       AND     2...   ccc ccc   ccc cence een e eee eneeeeaen   DO

                     Middle <       (First     +     Last)    DIV   2

                     IF   Names[Middle]          =   s

                          THEN

                            Index < Middle

                          ELSE




                                 ELSE

                                   Cd




                     ENDIF

              ENDWHILE


        ENDFUNCTION                                                                                                    [3]

    b   The binary search does not work if the data in the array being searched is ............0...6.                  [1]

        State the return value ofthe function FindName return when:

        i    thename searched for exists in the array.

        ii   thename searched for does not exist in the array.                                                         [2]
Cambridge International AS & A Level Computer Science




2   Aqueue Abstract Data Type (ADT) is to be implemented as a linked list of nodes. Each
    node is a record, consisting ofa data field and a pointer field. The queue ADT also has
    a FrontOfQueue pointer and an EndOfQueue pointer associated with it. The possible queue
    operations are: JoinQueue and LeaveQueue.
    a    i       Writelabels on the diagram to show the state of the queue after three data items
                 have been added to the queue in the given order: Apple, Pear, Banana.




         ii     Write labels on the diagram to show how the unused nodes are linked to form a list
                 of free nodes. This list has a StartofFreeList pointer associated with it.                   [2]
    b    i       Write program code to declare the record type Node.                                          [3]

         ii     Write program code to create an array Queue with 50 records of type Node.
                Your solution should link all nodes and initialise the pointers FrontofQueue,
                 EndOfQueue and StartOfFreeList.                                                              [7]
    c    The pseudocode algorithm for the queue operation JoinQueue is written as a
         procedure with the header:
                                    PROCEDURE      JoinQueue(NewlItem)

         where NewItem is the new value to be added to the queue. The procedure uses the
         variables shown in the following identifier table:

             Identifier                      Data type                     Description
             NullPointer                     INTEGER                       Constant set to -1

                                                                           Array to store queue data
                                             STRING                       Value to be added

                                                                           Pointer
                                                                                 to next free node in array

                                                                           Pointer
                                                                                to first node in queue

                                                                           Pointer
                                                                                 to last node in queue

                                                                           Pointer
                                                                                 to node to be added
                                                                                                              D NS




         i       Complete
                    the identifier table.

         ii      Complete the pseudocode using the identifiers from the table in part (c) (i).
                 PROCEDURE        JoinQueue(Newltem       :   STRING)

                      //   Report    error    if   no   free nodes      remaining

                      IF    StartOfFreeList        =    ... eee
                                                              eee eee eee

                           THEN

                             Report    Error

                           ELSE
                           //     new data     item placed           in    node   at   start   cf   free   list

                           NewNodePointer            «+       StartOfFreebist

                           Queue (NewNodePointer]
                                              Data «= NewItem

                           //     adjust    free     List pointer

                           StartOffreebist            <« Queue[NewNodePointer].Pointer

                           Queue [NewNodePointer!]
                                             Pointer « NullPointer

                           //     if   first   item       in queve        then adjust     front     of   queue pointer

                           IF     FrontofQueue            =   NullPointer

                                THEN




                           ENDIF

                           //     new node     is    new       end   of   queue

                           QUEUE LL Le     eee cee eee eee       et POUNEGE   ©    loca
                                                                                     eee e cee enee

                           EnGOEQUGUE          ©   Lecce cece r rece n see eesverenseeenaeeenaeneenresen

                     ENDIF

               ENDPROCEDURE


3   Aprogram is required that sorts a list of words into alphabetical order, The list of words is
    supplied as a text file,

    a    Write é program to declare a string array, WordList, that can hold 500 elements.
         initialise the array so all elements contain the empty string.




                                                                                                                           Pend)
                                                                                                                         CO)
                                                                                                                           B
         Write a procedure, OurputList, to cutout all elements in index order.




                                                                                                                         GoL
         Write a procedure, LoadWords, that asks the user for a filename and reads the contents
         of the text file, storing each tine of text (word) in a separate array element. The procedure
         should output a relevant error message if:

         e   the fle doesn’t exist

         e   the array is full.

         Write 2 procedure, SortWords, to perform a bubbie sort on all non-empty array elements,



         Write program code to cail LoadWords, then outputList, followed by SortWords and
         then CutputList
                     again,

         Test your program by running if first with a non-existing file, and then with @ text file
         containing 20 words in random order.

         Take screenshots of your test runs that show your code works correctly.
|   |      im        -_                 in     (Cad           i 060 ele                     4




        Chapter 24:
        Recursion


        By the end of this chapter you should be able to:

           show understandingof the essential features of recursion
           show understanding of how recursion is expressed in a programming language
           trace recursive algorithms
           write recursive algorithms

           show understanding of when the use of recursion Is beneficial
           show awareness of what a compiler has to do to translate recursive programming code, including the use of stacks
           and unwinding.
                                                                                             Part 4: Chapter 24: Recursion




24.01 Concept of recursion
In mathematical logic and computer science, a function or procedure is said to bea
recursive routine if it is defined in terms of itself.




The classic mathematical example is the factorial function, n!, which is defined in Figure
24.01. This definition holds for all positive whole numbers.



       _ The base case }
Ol=1


    nl!=nx(n-1)!
                               _f The general case
                     een
                       Oe

Figure 24.01 Mathematical definition of the factorial function


Figure 24.02 shows expressions of the factorial function for the first four numbers.



                                                Here is the recursive
                                                function, with a smaller number (3)

4l=4x (4-1)l=4x 3!


31=3x (3-1)! =3x2!

                                           The number for the recursive
2}=2x (2-1)!=2x1!
                                           function keeps getting smaller, until
                                           we reach 0!, which is explicitly defined.
lb=1x(1-1)!=1x0!


Figure 24.02 Expressions of the factorial function


Because 0! = 1:

                                     4l.=4x3x2x
                                           1x 1 = 24

Recursive solutions have a base case and a general case. The base case gives a result
without involving the general case. The general case is defined in terms of the definition
itself. It is very important that the general case must come closer to the base case with each
recursion, for any starting point.
Cambridge International AS & A Level Computer Science




24.02 Programming a recursive subroutine

    WORKED EXAMPLE 24.01


    Coding the factorial function

    We could program the function Factorial iteratively, using a loop:

    FUNCTION     Factorial(n             :    INTEGER)      RETURNS    INTEGER

         Result      <   1

         FOR    i<«1TOn

                Result < Result                 *   i

         NEXT    i

         RETURN      Result

    ENDFUNCTION



    Alternatively, we can define the function Factorial recursively (Figure 24.03).

    FUNCTION     Factorial(n             :    INTEGER)      RETURNS    INTEGER


         IF n= 0                                        This is the base case |
            THEN

                Result       <   1
                                                                          This is the general case ]
            ELSE

                Result <« n          *       Factorial(n     -   1)

         ENDIF

         RETURN      Result

    ENDFUNCTION                                          This is the recursive cal



    Figure 24.03 The factorial function defined recursively

    The recursive pseudocode resembles the original mathematical definition of the factorial function. The dry
    run in Figure 24.05 (Section 24.03) shows how this works.




Discussion Point:
Carefully examine the two solutions to the factorial function. What happens if the iterative
function is called with parameter 0? What happens if the recursive function is called with
parameter 0? What changes would need to be made so the mathematical definition holds for
all values of n?

When writing a recursive subroutine, there are three rules you must observe. A recursive
subroutine must:

e    have abase case

e    havea general case

e    reach the base case after a finite (limited) number of calls to itself.



    TASK 24.01

    Write program code to implement the recursive algorithm for the factorial function.
                                                                                               Part 4: Chapter 24: Recursion




Question 24.01
What happens when the function is called with Factorial(-2)? Which rule is not satisfied?



   WORKED EXAMPLE 24.02


  Coding a recursive procedure

  Consider a procedure to count down from a given integer. We can write the solution as an iterative algorithm:

  PROCEDURE                 CountDownFrom(n               :   INTEGER)

          FOR       i       < n DOWNTO       0

                    OUTPUT         i

          NEXT          i

  ENDPROCEDURE



  We can also write the solution as a recursive algorithm. Consider what happens after the first value has been
  output. The remaining numbers follow the same pattern of counting down from the next smaller value. The
  base case is when n reaches 0. 0 will be output but no further numbers. The general case is outputting n and
  then counting down from (n - 1). This can be written using pseudocode:

  PROCEDURE                 CountDownFrom(n               :   INTEGER)

          OUTPUT             n

          IF    n>           0

               THEN

                    CALL         CountDownFrom(n               —-   1)

          ENDIF

  ENDPROCEDURE




24.03 Tracing a recursive subroutine

Tracing a recursive procedure
Dry-running the recursive procedure from Worked Example 24.02, we can complete a trace
table as shown in Table 24.01.

 Call number | Procedure call                                            |   OUTPUT   | n>0
       1                     CountDownFrom (3)                                 3      TRUE

       2                     CountDownFrom (2)                                 2      TRUE

       3                     CountDownFrom (1)                                 1      TRUE

       4                     CountDownFrom (0)                                 0       FALSE


Table 24.01 Trace table for CALL CountDownFrom(3)

it is more complex to trace a subroutine that contains statements to execute after the
recursive call. Look at the slightly modified algorithm:

PROCEDURE           CountUpTo(n          :   INTEGER)

     IF    n    >       0

          THEN

               CALL          CountUpTo(n         -   1)

     ENDIF

     OUTPUT             n

ENDPROCEDURE
      Cambridge International AS & A Level Computer Science




      Note that the statements after CALL CountUpTo(n - 1) are not executed until control
      returns to this statement as the recursive calls unwind.

      What is the effect of moving the ouTPuT statement to the end of the procedure? Figure 24.04
      traces the execution of CALL CountUpTo
                                          (3)


      Call number                  Procedure call                     n>0           OUTPUT
                1                   CountUpTo(3)                      TRUE
                2                   CountUpTo(2)
                3                    CountUpTo(1)                     TRUE
                                                                      TRUE                      =F Base case reached ]
                4                   CountUpTo(0)                          FALSE     |O    —TM   |
                (3)                 CountUpTo(1)                      TRUE         | 1)
                (2)                 CountUpTo(2)

                (1)                  CountUpTo(3)                     TRUE | 3U ~ | Sfrecursive calls unwind]
                                                                      TRUE         |2




      Figure 24.04 Trace table for CALL CountUpTo (3)


      When the base case is reached, the fourth call of the procedure is complete and the
      procedure is exited. Control then passes back to the third call and so on. Note how we show
      the trace as the recursive calls unwind. Don’t go back up the table and fill in the OUTPUT
      column as this will not make it clear enough when the output occurred.


      Tracing a recursive function
      A recursive function has a statement after the recursive call to itself: the RETURN statement.
      Again we show what happens when the recursive calls unwind by filling in more rows in the
438   trace table. Let’s consider
                               the factorial function again.

        FUNCTION           Factorial(n           :    INTEGER)        RETURNS        INTEGER

                IF    n    =   0

                     THEN

                          Result     <   1

                     ELSE

                          Result < n         *   Factorial(n              -   1)

                ENDIF

                RETURN         Result

        ENDFUNCTION



       Call               Procedure call | n=0 | Result                                         Return
       number                                                                                   value
          1           Factorial
                             (4)                     |FALSE|4     *   Factorial
                                                                             (3)
          2           Factorial
                             (3)                     |FALSE|]3    *   Factorial
                                                                             (2)

                                                                                                              A Base case reached }
          3           Factorial
                             (2)                     |FALSE|2     *   Factorial
                                                                             (1)
          4                                        (0)
                             (1) |FALSE]1 * Factorial
                      Factorial
          5           Factorial
                             (0) | TRUE                      /1                                      1    4
          (4)         Factorial
                             (1)                     |FALSE/1     *   1                             1)
          (3)         Factorial
                             (2)                     |FALSE|2     *   1                             2
          (2)         Factorial
                             (3)                     |FALSE|3     *   2                             6                    .            ind
          (1)         Factorial
                             (4) |FALSE|4                         * G                               742            Recursive calls unwin


      Figure 24.05 Trace table for CALL Factorial (4)


      Another way to illustrate how the function calls unwind is by framing each call with a box (see
      Figure 24.06). When the innermost box is completed the result is fed to the next one out. And
      so on until the outermost box has been completed.
                                                                                                  Part 4: Chapter 24: Recursion




Factorial
       (4)
   Result < 4        *    Factorial
                                 (3)

        Factorial
               (3)
             Result < 3                *    Factorial
                                                   (2)

                    Factorial
                           (2)
                         Result             < 2      *    Factorial
                                                                 (1)

                                         (1)
                                  Factorial
                                           Result < 1             *   Factorial
                                                                             (0)

                                                Factorial
                                                       (0)

                                                         Result       <   1

                                                Return        1

                                      Return         1

                         Return             2
             Return       6

    Return    24



Figure 24.06 Diagrammatic view of recursive calls of Factorial



  TASK 24.02

  Consider the following recursive algorithm:
  PROCEDURE X(n               :   INTEGER)

        IF    (n
               = 0) OR                     (n   = 1)

             THEN

               OUTPUT             n

             ELSE

               CALL X(n DIV 2)

               OUTPUT(n MOD 2)

        ENDIF

  ENDPROCEDURE


  Dry-run the procedure call x(19) by completing a trace table. What is the purpose of
  this algorithm?




24.04 Running a recursive subroutine
Recursive subroutines can only be executed if the compiler produces object code that uses a
stack to push return addresses and local variables when calling a subroutine repeatedly.



  WORKED EXAMPLE 24.03


  Running the factorial function

  Consider
        the following program, written in pseudocode:

  010   PROGRAM

  020

  030   FUNCTION Factorial(n                              :   INTEGER)        RETURNS   INTEGER

  040           IF   n    =       0

  050                THEN

  060                    Result <                1

  070                ELSE



                                                                                                                     (Continued)
Cambridge International AS & A Level Computer Science




  080                      Result <« n         *   Factorial(n   -   1)

  090               ENDIF

  100               RETURN     Result

  110     ENDFUNCTION

  120

  130     //       main program

  140

  150     DECLARE          Answer     :       INTEGER

  160     Answer < Factorial(3)

  170     OUTPUT       Answer

  180

  190     ENDPROGRAM


 The first program statement to be executed is line 160. The actual parameter
                                                                            n has the value 3. The function call
 causes the return address to be put on the stack, as shown in Figure 24.07. Program execution jumps to line 30.

 When line 80 is reached, the function call causes the return address to be stored on the stack, together with
 the current contents of the local variables. The locations used to store these values are referred to as a stack
 frame (represented by the blue borders in Figure 24.07). Each recursive call will add another stack frame to
 the stack until the base case is reached.

 When the base case is reached, the result of the function call Factorial(o) is returned by pushing it onto
 the stack. The result is popped off the stack by the previous call of the function. With each return from a
 function call, the corresponding stack frame is taken off and the values of the local variables are restored,
  Eventually, control is returned to line 160 with the result of the function call on the top of the stack. The value
  of Answer is output in line 170.

                                Stack                                Description

   160                                                               1st call is made (n=3)



   160}    080]       3                                              2nd call is made (n=2)



   160]    080 |       3      080 |       2                          3rd call is made (n=1)



   160} 080 | 3               080}        2 | 080 | 1                Ath call is made (n=0)
                                                                     Base case reached; push result onto stack
   160 | 080 | 3 | 080]                   2 | oso       I   1 | Retu
                                                                   to call
                                                                       rn3
                                                                     Pop result and stack frame; push new result.
   160}    080 | 3          J 080|        2        1                 Return to call 2


                                                                     Pop result and stack frame; push new result.
   160}    080 |      3        2                                     Return to call 1



                                                                     Pop result and stack frame; push new result.
   160}        6                                                     Return to main program


  Figure 24.07 Stack contents during recursive calls of Factorial
                                                                                             Part 4: Chapter 24: Recursion




  TASK 24.03

   Use your program code from Task 24.01 and add the main program as shown in
  Worked Example 24.03.
  Amend your code in the following ways (line numbers are relative to the pseudocode
   in Worked Example 24.03):

   e   Add a global integer variable callNumber
   e   Initialise CallNumber to zero (line 155).
   e   Increment CallNumber (line 35).

   e   Add astatement to output the values of CallNumber and n       (line 36).
   e   Add astatement to output the value of Result (line 95).
   Run the program and study the output.




24.05 Benefits and drawbacks of recursion
Recursion is an important technique in different programming paradigms (See Chapter 29,
Section 29.08). When designing a solution to a mathematical problem that is recursive by
nature, the easiest way to write a solution is to implement the recursive definition. Some
optimising compilers will change a recursive subroutine to an iterative one when producing
object code.

Recursive solutions are often more elegant and use less program code than iterative
solutions. However, repeated recursive calls can carry large amounts of memory usage and
processor time (see Section 24.04). For example, the procedure call count DownFrom(100)
will require 100 stack frames before it completes.


Reflection Point:
How can you tell from a function or procedure definition whether or not it is recursive?




  Summary
                                                                                                               Li
BE eee te        ane thing we “    Sa bhi aft Be Se aes ete, fe




2   a       Outline the cifferences between iteration and recursion.

    b       Give one advantage anc one disadvantage of using recursive subroutines.
2   The following:is a recursively definec function which calculates the result of Basebpenen
    For exarrpHe, 2715&,


            IF     Exponent              =    0

                 THEN




                     Resuit             « Base            *    Power (Base,    Exponent     -   2)

            ENDIF

            RETURN           Result




    a       State whatis meant by ‘recursively defined’,
    b       Complete
                a trace tablefor the execution of the function cali Power (2,4) showing for each
            re-entry into the Power function, the values passed to the function anc the results returned,
            Explain the role of the stack in the execution of the Power function,
    a)




            Writea pseudocode non-recursive (iterative)version of the Power function.
    a.




            i        Give ome reason why a nor-recursive Power function may be preferred to
                     a recursive one,

            ii       Give         one reason
                                          why a recursive Powerfunction maybe preferred to 4
                     non-recursive one,

3   The following is a recursively defined function which calculates the nth integer in the sequence
    of Fibonacci numbers
    Ol      FUNCTION               Fibonacci(n                     INTEGER)    RETURNS     INTEGER

    02                TF     (n     =    9)   OR          (m   =   4)

    03                     THEN

    04                            Result          «   1

    05                     BLSE

    06                            Result <« Fibonacci(n -                     1)   +   Fibonacci(n   ~-   2)

    O7               ENDIF

    08               RETURN             Result

    09      ENDPONCTION

    @       i        Give the line number
                                      of the line                             containing the
                                                                                           base case.
            ii    = Givethe line number
                                      of the line containing
                                                          the general case.

    6       Complete a tracetableforthe function call Fibonacci(4).
Chapter 25:
Programming paradigms

By the end of this chapter you should be able to:

m show understanding of what is meant by a programming paradigm
m show understanding of the characteristics of a number of programming paradigms:
   « low-level, imperative, object-oriented and declarative.
 Cambridge International AS & A Level Computer Science




 25.01 Programming paradigms
 A programming paradigm is a fundamental style of programming. Each paradigm will support
 a different way of thinking and problem solving. Paradigms are supported by programming
 language features. Some programming languages support more than one paradigm. There are
 many different paradigms, and some overlap. Here are just a few different paradigms.


CB ere
    Programming paradigm: A fundamental style of programming



 Low-level programming paradigm
 The features of low-level programming languages give us the ability to manipulate the
 contents of memory addresses and registers directly and exploit the architecture of a given
 processor. We solve problems in a very different way when we use the low-level programming
 paradigm than if we use a high-level paradigm. See Chapter 6 and Chapter 28 for low-level
 programming examples. Note that each different type of processor has its own programming
 language. There are ‘families’ of processors that are designed with similar architectures
 and therefore use similar programming languages. For example, the Intel processor family
 (present in many PC-type computers) uses the x86 instruction set.

 Imperative programming paradigm
 Imperative programming involves writing a program as a sequence of explicit steps that are
 executed by the processor. Most of the programs in this book use imperative programming
 (Chapters 12 to 15 and Chapters 23, 24 and 26). An imperative program tells the computer
 how to get a desired result, in contrast to declarative programming where a program
 describes what the desired result should be. Note that the procedural programming
 paradigm belongs to the imperative programming paradigm. There are many imperative
 programming languages, Pascal, C and Basic to name just a few.

 Object-oriented programming paradigm
 The object-oriented paradigm is based on objects interacting with one another. These
 objects are data structures with associated methods (see Chapter 27). Many programming
 languages that were originally imperative have been developed further to support the object-
 oriented paradigm. Examples include Pascal (under the name Delphi or Object Pascal) and
 Visual Basic (the .NET version being the first fully object-oriented version). Newer languages,
 such as Python and Java, were designed to be object-oriented from the beginning.

 Declarative programming paradigm
 Programming languages such as Pascal, VB and Python are referred to as ‘imperative
 programming languages’ because the programmer writes sequences of statements that
 reflect how to solve the problem. When a programmer uses a declarative programming
 language, the programmer writes down (in the language of logic) a declarative specification
 that describes the situation of interest: what the problem is. The programmer doesn’t tell the
 computer what to do. To get information, the programmer poses a query (sets a goal). It’s up
 to the logic programming system to work out how to get the answer.

 Declarative programs are expressed as formal logic and computations are deductions from
 the formal logic statements (see Chapter 29). Declarative programming languages include
 SQL (see Chapter 11) and Prolog (Chapter 29).

 Reflection Point:
 Why are there different paradigms?
                                                                       Part 4: Chapter 25: Programming paradigms




After you have studied Chapters 26 to 29 do Tasks 25.01 and 25.02



  TASK 25.01

  Draw a line between a statement on the left and its matching programming
  paradigm on the right.



    Commands available depend on
                                                                    Declarative
    the type of processor




    Information hiding is used to
    protect internal properties of an
    object




    Statements operate on data                                      Imperative




   Answer a question via a search
   for a solution




    Data is combined with
                                                                    Low-level
    procedures




    First do this and then do that




   The basic concept is a relation                                  Object-oriented




  TASK 25.02

  For each of the four programming paradigms in this chapter, give one programming
  statement example that is characteristic for this paradigm. State the programming
  language you used for each example.
                                                              ~ Cade
Chapter 26:
File processing and exception handling


By the end of this chapter you should be able to:

m   write code to perform file-processing operations:
    *   opena file (in read, write or append mode)
    ¢   read a record from a file
    *   write a record toa   file
    *   onserial, sequential and random files
    show understanding of an exception and the importance of exception handling
    show understanding of when it is appropriate to use exception handling
    write code to use exception handling.
                                                                                      Part 4: Chapter 26: File processing and exception handling




26.01 Records
Records are user-defined types (discussed in Chapter 16, Section 16.01). See also Section 13.02.


   WORKED    EXAMPLE 26.01


  Using records
  A car manufacturer and seller wants to store details about cars. These details can be stored ina
  record structure:

  TYPE    CarRecord

         DECLARE VehicleID                                    :       STRING             // unique      identifier and record key

         DECLARE Registration                                 :       STRING

         DECLARE DateOfRegistration                           :       DATE

         DECLARE     EngineSize                               :       INTEGER

         DECLARE     PurchasePrice                            :       CURRENCY

  ENDTYPE


  To declare a variable of that type we write:

  DECLARE    ThisCar        :    CarRecord




Note that we can declare arrays of records. If we want to store the details of 100 cars,
we declare an array of type CarRecord

DECLARE    Car   :   ARRAY[1:100]        OF   CarRecord



             Python does not have a record type. However, we can use a class definition with only a constructor to assign initial
             values. (See Chapter 27 for more about classes).
             The pseudocode example of a car record described in Worked Example 26.01 can be programmed as follows:
             class CarRecord:                                         # declaring a class without other methods
                     def     init     (self):                         #       constructor
                           self.VehicleID             =       ""
                           self.Registration =                            ""
                           self .DateOfRegistration =                                 None
                           self.EngineSize                =       0
                           self.PurchasePrice                         =       0.00
             ThisCar         =   CarRecord()              #       instantiates               a    car   record
             ThisCar.EngineSize                   =    2500               #       assign a value        to a   field
             Car =         [CarRecord()           for         i       in range(100)]               # make a      list   of   100   car records
             Car[1].EngineSize = 2500 # assign value to a field of the 2nd car in list


 VB.NET      Structure           CarRecord
                     Dim VehicleID As                 String
                     Dim Registration As                      String
                     Dim DateOfRegistration As                                    Date
                     Dim EngineSize As                 Integer
                     Dim PurchasePrice As                         Decimal
             End      Structure
             Dim ThisCar As              CarRecord                            '    declare   a variable        of   CarRecord      type
             Dim Car(100)           As    CarRecord                           '    declare   an   array of     CarRecord      type
             ThisCar.EngineSize                   =    2500                   '    assign value      to a   field
             Car(2).EngineSize                =       2500                '       assign value      to a    field of     2nd car     in array



                                                                                                                                                 (Continued)
Cambridge International AS & A Level Computer Science




                Java does not have a record type. However, we can use a data structure. A class definition without methods is a data
                structure that can be used like a record. (See Chapter 27 for more about classes).
                The pseudocode example of a car record described in Worked Example 26.01 can be programmed as follows:
                class         CarRecord

                {
                        String vehicleID;
                        String      registration;
                        String      dateOfRegistration;
                        int    engineSize;
                        double      purchasePrice;


                        public      CarRecord
                                            ()                           //    declare       a    constructor without                     other methods

                        {
                              vehicleID        =       "XX";
                              registration                 =       "";
                              dateOfRegistration                          =    "01/01/2010";
                              engineSize           =       0;
                              purchasePrice                    =    0.00;



                }
                CarRecord           thisCar            =       new       CarRecord();             //    instantiates             a   car    record
                thisCar.engineSize                         =       2500;       //    assign       a value     to       a    field


                CarRecord[]              car   =       new          CarRecord[100];                //   declare            an   array      of    car    record   type


                car[2]         =   new   CarRecord();                         //    instantiate         a   car
                car[2].engineSize                      =       2500;          //    assign       a value     to    a       field     of    2nd    car    in   array




26.02 File processing
in Chapter 13 (Section 13.06) we used text files to store and read lines of text. Text files only allow
us to write strings in a serial or sequential manner. We can append strings to the end of the file.

When we want to store records in a file, we create a binary file (see Chapter 16, Section 16.02).
We can store records serially or sequentially. We can also store records using direct access to
a random file. Table 26.01 lists the operations we use for processing files.



Qa
    Random file: a file that stores records at specific addresses that can be accessed directly




 Structured English                                                            | Pseudocode
 Create
     a file and open it for writing                                                OPENFILE <filename> FOR WRITE

 Open a file in append mode                                                        OPENFILE <filename> FOR APPEND

 Open a file for reading                                                           OPENFILE       <filename>           FOR READ

 Open a file for random access                                                     OPENFILE <filename> FOR RANDOM

 Close
     a file                                                                        CLOSEFILE <filename>

 Write a record to a file                                                          PUTRECORD <filename>,                   <identifier>

 Read a record from afile                                                          GETRECORD <filename>,                   <identifier>

 Move to a specific disk address within the file                                   SEEK <filename>,          <address>

 Test for end of file                                                              EOF (<filename>)


Table 26.01 Operations for file processing
                                                                               Part 4: Chapter 26: File processing and exception handling




Sequential file processing
If we have an array of records, we may want to store the records on disk before the program quits,
so that we don’t lose the data. We can open a binary file and write one record after another
                                                                                           to the
file. We can then read the records back into the array when the program is run again.


   WORKED EXAMPLE 26.02


  Processing records in a sequential file
  Table 26.02 shows the pseudocode for storing the car records from Worked Example
  26.01 in a sequential file and accessing them.

   Saving contents of array                                                               Restoring contents of array
   OPENFILE CarFile FOR WRITE                                                             OPENFILE CarFile FOR READ
   FOR i < 1 TO MaxRecords                                                                FOR i < 1 TO MaxRecords

         PUTRECORD CarFile,                Car[i]                                             GETRECORD CarFile,        Car[i]
   NEXT i                                                                                 NEXT i

   CLOSEFILE CarFile                                                                      CLOSEFILE CarFile


  Table 26.02 Pseudocode for processing records


  Processing records sequentially in Python, VB.NET and Java

                 import pickle # this                            library is required to create binary files
                 Car =      [CarRecord()                    for i       in range(100)]

                 CarFile = open('CarFile.DAT',                                  'wb')    # open file for binary write

                 for    i   in range(100):                       #    loop     for each array element
                       pickle.dump(Car[i],                           CarFile)     # write a whole record to the binary file

                 CarFile.close()                        #   close       file

                 CarFile = open('CarFile.DAT',                                  'rb')     # open file for binary read

                 Car =      []       #    start with empty list
                 while True:                  #   check          for end of       file
                       Car.append(pickle.load(CarFile))                                   # append record from file to end of list

                 CarFile.close()


                 Option Explicit                    On
                 Imports         System.IO


                 Dim CarFileWriter As                            BinaryWriter
                 Dim CarFileReader As                            BinaryReader
                 Dim CarFile As                    FileStream
                 Dim Car(100)                 As CarRecord               '   declare an array of       CarRecord type
                 Dim    i   As       Integer


                 'link      file         to       the       filename
                 CarFile = New FileStream("CarFile.DAT",                                     FileMode.Create)
                 '   create a new file and open it                                for writing
                 CarFileWriter = New BinaryWriter(CarFile)
                 For    i=       1    To      100            '   loop    for each array element
                       CarFileWriter.Write(Car(i).VehicleID)                                    '   write a field to the binary file
                       CarFileWriter.Write(Car(i).Registration)
                       CarFileWriter.Write(Car(i).DateOfRegistration)
                       CarFileWriter.Write(Car(i).EngineSize)
                       CarFileWriter.Write(Car(i).PurchasePrice)


                                                                                                                                  (Continued)
Cambridge International AS & A Level Computer Science




            Next


            CarFileWriter.Close()                                                 '       close           file      channel
            CarFile.Close()

             'link                   file      to       the       filename
            CarFile                   =    New      FileStream("CarFile.DAT",                                            FileMode.Open)
             '   create                   a   new           file          and             open           it   for     reading
            CarFileReader                           =       New       BinaryReader (CarFile)
            i=0

             '   loop                until          end          of       binary                   file       reached
            i=               0
            Do       While                CarFile.Position                                 <       CarFile.Length
                         '       read         fields             from             the          binary           file
                     Car(i).VehicleID                                 =       CarFileReader.ReadString()
                     Car(i).Registration                                          =       CarFileReader.ReadString()
                     Car(i).DateOfRegistration                                                      =    CarFileReader.ReadString()
                     Car(i).EngineSize                                    =       CarFileReader.ReadInt32
                                                                                                        ()
                     Car(i).PurchasePrice                                             =    CarFileReader.ReadDecimal
                                                                                                                   ()
                     d=i¢i1
            Loop


            CarFileReader.Close ()                                                'close                file     channel

            CarFile.Close()

            writing records to a file:

            import                   java.io.DataOutputStream;
            import                   java.io.FileOutputStream;
            import                   java.io.EOFException;
            import                   java.io.FileInputStream;
            import                   java.io.FileOutputStream;
                     try

                     {           // set up file stream and link to file name
                                 FileOutputStream                                 fos          =    new       FileOutputStream("CarFile.DAT")
                                                                                                                                            ;
                                 //       link      file          stream to                         data       stream
                                 DataOutputStream                                 dos          =    new       DataOutputStream(fos)
                                                                                                                                  ;
                                 for       (int         i    =    1;          i       <    100;          i++)    //    loop   for   each    array    element

                                 {
                                          dos.writeUTF(car[i].vehicleID);                                                //   write   a    field    to   the   file
                                       dos.writeUTF(car[i] .registration) ;
                                       dos.writeInt
                                            (car[i] .engineSize) ;
                                       dos.writeUTF
                                           (car [i] .dateOfRegistration) ;
                                       dos.writeDouble
                                             (car [i] .purchasePrice) ;

                                 }
                                 dos.close();                     //          close                data       stream

                     }
                     catch                (Exception x)

                     {
                                 System.out.printin("IO                                             error");

                 }
            reading records back into array:
                     CarRecord[]                     car         =     new                CarRecord[100];
                     try

                     {           // set up file stream and link to file name
                                 FileInputStream                              fis          =       new    FileInputStream("CarFile.DAT")
                                                                                                                                       ;
                                 //    link         file         stream to                          data      stream
                                 DataInputStream                              dis          =       new    DataInputStream(fis)
                                                                                                                             ;
                                 int
                                  i = 1;
                                 while         (true)            //           loop             for       each    array element

                                 {

                                                                                                                                                                      (Continued)
                                                                       Part 4: Chapter 26: File processing and exception handling




                thisCar            =    new CarRecord()
                                                      ;
                thisCar.vehicleID                              =       dis.readUTF();         //   read      fields   from the   file
                thisCar.registration                                    =       dis.readUTF()
                                                                                            ;
                thisCar.engineSize                                 =    dis.readInt();
                thisCar.dateOfRegistration                                          =   dis.readUTF();
                thisCar.purchasePrice                                       =   dis.readDouble();
                car[i]         =       thisCar;                //      assign record to next                 array element
                1    +=   1;



     }
    catch       (EOFException x)

     {
          System.out.printin("End                                      of       File    reached")
                                                                                                ;

     }
    catch       (Exception x)

     {
          System.out.println(x);                                        //      output    error message

     }
Alternative method using Date data type (which is an object in Java):
write to file

import     java.io.*;

import     java.util.Date;


class     CarRecord            implements                  java.io.Serializable                    //   to   allow writing   and   reading

                                                                                                   //   objects



    String vehicleID;

    String          registration;

    Date    dateOfRegistration;

    int    engineSize;

    double      purchasePrice;



    public      CarRecord()                           //   declare               constructor



          vehicleID            =       "XxX";

          registration                  =       "";

          dateOfRegistration                           =   new Date();

          engineSize               =    0;

          purchasePrice                     =    0.00;




class     Program

{
public     static void main(String[]                                        args)

{
    CarRecord[]           car          =     new       CarRecord[100];

    CarRecord          thisCar;



    try

    {      //Write array to file.


          FileOutputStream                        fos      =       new          FileOutputStream("cars.ser");


                                                                                                                                        (Continued)
Cambridge International AS & A Level Computer Science




                        ObjectOutputStream oos                                     =    new ObjectOutputStream(fos);

                        for         (int   i       =    1;    i       <       100;     i++)    //     loop    for   each       array element

                        {
                                oos.writeObject(car[i].vehicleID);
                                                (                                                            //   write    a   field    to    the    file

                                oos.writeObject ( (car[i].registration);

                                oos.writeObject (car[i].engineSize);

                                oos.writeObject(car[i].dateOfRegistration);

                                oos.writeObject(car[i].purchasePrice);
                                                (

                        }
                        oos.close();

                  }
                  catch         (EOFException x)

                  {
                        System.out.println("End                                    of       File    reached");



                      catch          (Exception x)



                        System.out.printin(x);



             }
             }

            reading file into array:

            CarRecord[]              car       =       new    CarRecord[100];

            try


             {
                  //Read array from file.

                  FileInputStream                       fis       =       new      FileInputStream("cars.ser");

                  ObjectInputStream ois                                   =   new ObjectInputStream(fis);

                  int       i   =   1;

                 while          (true)

                  {
                        car[i].vehicleID                      =       (String)              ois.readObject();             //   read    the    first    item   from the
                                                                                                                          //   file   to     the    field

                        car[i].registration=
                             ].                                               (String)        ois.readObject();

                        car[i].engineSize                         =       (int)        ois.readObject();

                        ear [i ].dateOfRegistration                                     =    (Date)    ois.readObject();

                        car[i].purchasePrice
                             ].                                               =    (double)         ois.readObject();




            catch       (EOFException x)

            {
                  System.out.printin("End                                     of   File       reached");

            }
            catch       (Exception x)

            {
                 System.out.println(x);
                                                             Part 4: Chapter 26: File processing and exception handling




  TASK 26.01

   1   Write a complete program to save several car records to a sequential file.
  2    Write another program to read the file and display the contents on screen.



Random-access file processing
instead of storing records in an array, we may want to store each record in a binary file as the
record is created. We can then update the record in situ (read it, change it and save it back in the
same place). Note that this only works forfixed-length records. We can use a hashing function
to calculate an address from the record key and store the record at the calculated address in
the file (this is similar
                        to using a hash table, see Chapter 23, Section 23.11). Just as with a hash
table, collisions may occur and records need to be stored in the next free record space.


   WORKED EXAMPLE 26.03


  Processing records in arandom-access file
  Table 26.03 shows the pseudocode for storing a car record from Worked Example 26.01
  in a random-access file and accessing it.

   Saving a record                                                    | Retrieving a record
   OPENFILE     CarFile    FOR RANDOM                                  OPENFILE          CarFile    FOR RANDOM

   Address < Hash(ThisCar.VehicleID)                                   Address < Hash(ThisCar.VehicleID)

   SEEK CarFile,      Address                                          SEEK CarFile,             Address

   PUTRECORD     CarFile,       ThisCar                                GETRECORD          CarFile,       ThisCar

   CLOSEFILE     CarFile                                               CLOSEFILE          CarFile


  Table 26.03 Pseudocode for random-access file operations



  SEEK moves a pointer to the given record address. The PUTRECORD and GETRECORD commands access the
  record at that address. After the command has been executed the pointer points to the next record in the file.

  Processing random-access records in Python, VB.NET and Java

   Python        import pickle        # this library is required to create binary files
                 ThisCar    =    CarRecord()


                 CarFile    =    open('CarFile.DAT','rb+')                   #    open    file    for binary read and write
                 Address    =    hash(ThisCar.VehicleID)
                 CarFile.seek (Address)
                 pickle.dump(ThisCar,           CarFile)      #       write       a whole       record   to   the binary   file
                 CarFile.close()          #   close   file


                 to find a record from a given VehiclelD:
                 CarFile    =    open('CarFile.DAT','rb')                #       open    file    for binary read
                 Address    =    hash(VehicleID)
                 CarFile.seek (Address)
                 ThisCar    =    pickle.load(CarFile)             #    load       record    from    file
                 CarFile.close()


                 In Python, the hash function needs to allow for the record size in bytes. For example, if the record size
                 is 58 bytes, then the second record slot starts at position 59. The nth record slot starts at position
                 (n-1)x 5841.



                                                                                                                                  (Continued)
Cambridge International AS & A Level Computer Science




            Dim       CarFileWriter As                             BinaryWriter
            Dim       CarFileReader As                             BinaryReader
            Dim       CarFile       As       FileStream
            Dim       ThisCar,          MyCar             As        CarRecord
             '   link    the       file          to        the       filename
            CarFile       =       New    FileStream("CarFile.DAT",                                  FileMode.Open)


             '   create       a    new       file              and       open     it    for    writing
            CarFileWriter                =       New           BinaryWriter(CarFile)
             '   get    starting             address                 for      record
            CarFile.Position                          =   Hash(ThisCar.VehicleID)


             '   write    fields             to           the      binary         file


            CarFileWriter.Write(ThisCar.VehicleID)
            CarFileWriter.Write(ThisCar.Registration)
            CarFileWriter.Write(ThisCar.DateOfRegistration)
            CarFileWriter.Write(ThisCar.EngineSize)
            CarFileWriter.Write(ThisCar.PurchasePrice)


            CarFileWriter.Close()                                    ‘close           file    channel
            CarFile.Close()


            to find a record from a given VehiclelD:
            CarFile       =       New    FileStream("CarFile.DAT",                                  FileMode.Open)
            CarFileReader                =       New           BinaryReader (CarFile)
             '   get    starting             address                 for      record
            CarFile.Position                         =    Hash(VehicleID)


             '   read    fields          from              the       binary           file
            MyCar.VehicleID                      =        CarFileReader.ReadString()
            MyCar.Registration                             =       CarFileReader.ReadString()
            MyCar.DateOfRegistration                                      =   CarFileReader.ReadString()
            MyCar.EngineSize                         =     CarFileReader.ReadInt32()
            MyCar.PurchasePrice                                =    CarFileReader.ReadDecimal
                                                                                            ()


            CarFileReader.Close()                                    'close           file    channel
            CarFile.Close()


            In VB.NET, the hash function needs to allow for the record size in bytes. For example, if the record size is 58
            bytes, then the second record slot starts at position 59. The nth record slot starts at position (n — 1) x 58 +1.

            CarRecord             thisCar;

            int       recordSize             =       50;

            try //      set up          a        file with                100     dummy records

            {
                  RandomAccessFile                             writer         =   new       RandomAccessFile("CarFile.DAT",    "rw");
                  for    (int       i   =        1;       i    <    100;      i++)      //   loop   for   each array element

                  {
                        thisCar          =       new CarRecord();

                        thisCar.vehicleID                            =    "A"     +    i;

                        writer.seek(i                      *       recordSize);

                        writer.writeUTF(thisCar.vehiclelID);

                        writer.writeUTF(thisCar.registration);

                        writer.writeUTF(thisCar.dateOfRegistration);

                        writer.writeInt(thisCar.engineSize);

                        writer.writeDouble(thisCar.purchasePrice);




                                                                                                                                        (Continued)
                                                                  Part 4: Chapter 26: File processing and exception handling




                     writer.close();

                 }
                 catch   (IOException x)

                 {
                 }

                to find a record from a given VehiclelD:
                try


                 {
                     RandomAccessFile        writer          =   new RandomAccessFile("CarFile.DAT",     "rw");

                     RandomAccessFile        reader          =   new   RandomAccessFile("CarFile.DAT",   "r");

                      reader.seek(hash(vehicleID));

                      thisCar   =   new   CarRecord();

                      thisCar.vehicleID      =   reader.readUTF();

                      thisCar.registration           =       reader.readUTF()
                                                                            ;

                      thisCar.engineSize         =   reader.readInt()
                                                                    ;
                      thisCar.dateOfRegistration                  =    reader.readUTF();
                      thisCar.purchasePrice              =   reader.readDouble()
                                                                               ;
                      reader.close();

                 }
                catch    (IOException x)

                 {

                 }




  TASK 26.02

  Write a complete program to save several car records to a random-access file. Write
  another program to find a record in the random-access file using the record key.
  Display the record data on screen.




26.03 Exception handling
Run-time errors can occur for many reasons. Some examples are division by zero, invalid
array index or trying to open a non-existent file. Run-time errors are called ‘exceptions’. They
can be handled (resolved) with an error subroutine (known as an ‘exception handler’), rather
than let the program crash.

Using pseudocode, the error-handling structure is:

  TRY

        <statementsA>

  EXCEPT

        <statementsB>

  ENDTRY


Any run-time error that occurs during the execution of <statementsAs is caught and handled
by executing <statementsB>. There can be more than one ExcEPT block, each handling a
different type of exception. Sometimes a FINALLY block follows the exception handlers. The
statements in this block will be executed regardless of whether there was an exception or not.

VB.NET is designed to treat exceptions as abnormal and unpredictable erroneous situations.
Python is designed to use exception handling as flow-control structures. You may find you
need to include exception handling in the code for Worked Example 26.02. Otherwise the end
of file is encountered and the program crashes.
Cambridge International AS & A Level Computer Science




Python distinguishes between different types of exception, such as:
e   0Error: for example, a file cannot be opened

e   ImportError:
        Python cannot find the module

°   ValueError: an argument has an inappropriate value

°   KeyboardInterrupt: the user presses Ctrl+C or Ctrl+Del

e   EOFError: a file-read meets an end-of-file condition
e   ZeroDivisionError: a division by zero has been attempted


Java distinguishes between different types of exception, such as:
e   IOException: for example, a file cannot be opened

°   ArithmeticException: an arithmetic error occurred, such as division by zero
e   ArrayIndexOutOfBoundsException: the program tries to access an array element
    outside the boundary



    WORKED EXAMPLE 26.04


    Here is a simple example of exception handling. Asking the user to key in an integer could
    result in a non-integer input. This should not crash the program.

     Python           NumberString               =   input("Enter            an   integer:     ")
                      try:

                            n    =       int (NumberString)
                            print (n)
                      except:

                            print ("This             was   not    an    integer")

    VB.NET            Dim NumberString As                   String
                      Dim n As             Integer
                      Console.WriteLine ("Enter an                           integer")
                      NumberString               =   Console.ReadLine
                                                                    ()
                      Try

                            n    =       Int (NumberString)
                            Console.WriteLine
                                           (n)
                      Catch
                            Console.WriteLine("This                         was   not   an   integer")
                      End       Try

                      import             java.util.Scanner;

                      {
                            public          static void main(String[]                    args)

                            {
                                     Scanner console             = new Scanner (System.in) ;
                                     try

                                     {
                                           System.out.print ("Enter an                   integer:        ");
                                           int   n   =   console.nextInt()j;
                                           System.out.printin(n)
                                                               ;

                                     }
                                     catch(Exception e)                //    catches     any exception
                                     {
                                           System.out.printlin("This was                     not    an   integer")
                                                                                                                 ;
                                                           Part 4: Chapter 26: File processing and exception handling




    TASK 26.03

    Add exception-handling code to your programs for Task 26.01 or Task 26.02. Test
    your code handles exceptions without the program crashing.



Reflection Point:
Can you explain the difference between serial, sequential and random access files? Give an
example of when each is appropriate.




    Summary




Exam-style Questions

1   Acompany stores details about their customers in a binary file of records.

    e   The key field of a customer record is the customer ID (a number between 100001 and
        999999).

    «   Thename of the customer is stored in a 30-character field.

    e   The customer’s telephone number is stored in a 14-character field.

    e   The total value of orders so far is stored in a currency (decimal) field.

    a    i     Writethe declaration statement for the record data type CustomerRecord required
               to store the data. Write program code.                                                        [6]

         ii    Write the declaration statement for an array CustomerData[o            :   999]   tostore
               customer records.                                                                             [2]

    b = The array CustomerData is to be used as a hash table to store customer records.
         The function Hash is used to calculate the address where a record is to be stored.
         FUNCTION Hash(CustomerID           :   INTEGER)   RETURNS       INTEGER

               Address    <   CustomerID    MOD   1000

               RETURN Address

         ENDFUNCTION


         i     Write program code to implement the function Hash.                                            [3]

         ii    Write a procedure AddRecord(Customer         :       CustomerRecord)       to adda customer
               record to the hash table customerData. Your solution should handle collisions by
               using the next available slot in the hash table.                                              [7]

         iii   Write a function FindRecord(CustomerID           :    INTEGER)   that returns the index of
               the hash table slot where the record for the customer with CustomerID is stored.              [7]

    c    Before the program stops, the hash table records must be stored in a sequential file, so
         that the records can be restored to the array when the program is re-entered.

         Write program code to store the records of the array CustomerData sequentially into a
         binary file CustomerData.DAT                                                                        [6|
                                                                               i ]
    dad   instead of using a hash table, the company decide they want to store customer recorcs
          in a clrect-access binary file.

          Explain what changes need to be made to your program to do this.                          GI

2   Aprogram allows a user to enter a filename for accessing a data file. if the user types ina
    filename that does not exist, the program crashes. Write program code that includes exception
    handling to replace the following pseudocode:                                                   5
    OUTPUT    "Which    file   do you want   to use?   "

    INPUT    FileName

    OPENFILE     FileName      FOR RANDOM
Na




     Chapter 27:
     Object-Oriented Programming (OOP)

     By the end of this chapter you should be able to:

     m   show understanding of the terminology associated with OOP: objects, properties, methods, classes, inheritance,
         polymorphism, containment/aggregation, encapsulation, getters, setters and instances
         show understanding of how to solve a problem by designing appropriate classes
         show understanding of and write code that demonstrates the use of OOP.
Cambridge International AS & A Level Computer Science




27.01 Concept of OOP
Chapters 14 and 26 covered programming using the procedural aspect of our programming
languages. Procedural programming groups related programming statements into
subroutines. Related data items are grouped together into record data structures. To use a
record variable, we first define a record type. Then we declare variables of that record type.



Example of using a record
A car manufacturer and seller wants to store details about cars. These details can be stored
in arecord structure (see Chapter 16, Section 16.01 and Chapter 26, Section 26.02):

  TYPE     CarRecord
         DECLARE   VehicleID                      :   STRING
         DECLARE    Registration                  :   STRING
         DECLARE    DateOfRegistration            :   DATE
         DECLARE    EngineSize                    :   INTEGER
         DECLARE    PurchasePrice                 :   CURRENCY
  ENDTYPE


We can write program code to access and assign values to the fields of this record.
For example:

  PROCEDURE     UpdateRegistration(BYREF              ThisCar     :   CarRecord,   BYVALUE    NewRegistration)
         ThisCar.Registration < NewRegistration
  ENDPROCEDURE


We can call this procedure from anywhere in our program. This seems a well-regulated way
of operating on the data record. However, we can also access the record fields directly from
anywhere within the scope of ThisCar:

  ThisCar.EngineSize         <   2500



Classes in OOP
OOP goes one step further and groups together the data structure and the subroutines
that operate on the data items in this data structure. Such a group is called an object.
The data of an object are called attributes and the subroutines acting on the attributes
are called methods. The idea behind OOP is that attributes can only be accessed through
methods. The direct path to the data is unavailable. Attributes are referred to as ‘private’.
The methods to access the data are made available to programmers, so these are ‘public’.
The feature of data being combined with the subroutines acting on this data is known
as encapsulation. To use an object, we first define an object type. An object type is called
a Class.

Classes are templates for objects. When a class type has been defined it can be used to
create one or more objects of this class type. Therefore, an object is an instance of a class.


Qo
   Object: an instance of a class

   Attributes: the data items of a class (also sometimes referred to as fields)

   Methods: the subroutines of aclass

   Encapsulation: combining data and subroutines into a class and restricting external access to
   the data

   Class: a type that combines a data structure with the methods that operate on the data structure
                                                            Part 4: Chapter 27: Object-Oriented Programming (OOP)




The first stage of writing an object-oriented program to solve a problem is to design the
classes. This is part of object-oriented design. From this design, a program can be written
using an object-oriented programming (OOP) language.

The programming languages the syllabus prescribes can be used for OOP: Python 3, VB.NET
and Java.



Advantages of OOP over procedural languages
The advantage of OOP is that it produces robust, more reliable code. The attributes can only
be manipulated using methods provided by the class definition. This means the attributes
are protected from accidental changes. Classes provided in module libraries are thoroughly
tested. If you use tried and tested building blocks to construct your program, you are less
likely to introduce bugs than when you write code from scratch.



27.02 Designing classes and objects
When designing a class, we need to think about the attributes we want to store. We also
need to think about the methods we need to access the data and assign values to the data
of an object. A data type is a blueprint when declaring a variable of that data type. A class
definition is a blueprint when declaring an object of that class. Creating a new object is
known as ‘instantiation’.

Any data that is held about an object must be accessible, otherwise there is no point in
storing it. We therefore need methods to access each one of these attributes. These methods
are usually referred to as getters. They get an attribute ofthe object.

When we first set up an object ofa particular class, we use a constructor. A constructor
instantiates the object and assigns initial values to the attributes.

Any attributes that might be updated after instantiation will need subroutines to update their
values. These are referred to as setters. Some attributes get set only at instantiation. These
don’t need setters. This makes an object more robust, because you cannot change attributes
that were not designed to be changed.

Python and VB.NET allow properties to be declared. A property combines the attribute with
its associated setter and/or getter (See Figures 27.03 and 27.05).


   KEY TERMS
Cambridge International AS & A Level Computer Science




 WORKED     EXAMPLE 27.01


  Creating a class

  Consider
        the car data from Section 27.01.

 When a car is manufactured it is given a unique vehicle ID that will remain the same throughout the car’s existence. The
  engine size of the car is fixed at the time of manufacture. The registration ID will be given to the car when the car is sold.

  In our program, when a car is manufactured, we want to create a new car object. We need to instantiate it using the
  constructor. Any attributes that are already known at the time of instantiation can be set with the constructor. In our
  example, VehicleID and EngineSize can be set by the constructor. The other attributes are assigned values at the time
  of purchase and registration. So, we need setters for them. The identifier table for the car class is shown in Table 27.01.

   Identifier                         | Data Type | Description
   Car                                 Class          Class identifier

  VehicleID                            STRING         Unique ID assigned at time of manufacture

   Registration                        STRING         Unique ID assigned after time of purchase
   DateOfRegistration                  DATE           Date of registration

   EngineSize                          INTEGER | Engine size assigned at time of manufacture
   PurchasePrice                       CURRENCY | Purchase price assigned at time of purchase

   Constructor ()                                     Method to create a Car object and set properties assigned at manufacture
   Set PurchasePrice ()                               Method to assign purchase price at time of purchase
   SetRegistration()                                  Method to assign registration ID
   SetDateOfRegistration ()                           Method to assign date of registration

   GetVehicleID()                                     Method to access vehicle ID
   GetRegistration()                                  Method to access registration ID
  GetDateOfRegistration()                             Method to access date of registration

  GetEngineSize ()                                    Method to access engine size

   Get PurchasePrice ()                               Method to access purchase price


 Table 27.01 Identifier table for car class

 We can represent this information as a class diagram in Figure 27.01.


     Attributes     N                           Car
                        \VehicleID                     :   STRING

                          Registration                 :   STRING            =     _]

                          DateOfRegistration           :   DATE                         Attributes must be

                              EngineSize               : INTEGER                        declared as Private
                              PurchasePrice            :   CURRENCY


                              Constructor
                                        ()
      Methods
                              Set PurchasePrice()
                        ps,


                              SetRegistration
                                            ()

                              SetDateOfRegistration ()                   —e—_]


                               etVehicleID()                                     ~ declared as Public
                                                                                        Methods must be
                          GetVehicleID                                                                  -

                          GetRegistration()

                          GetDateOfRegistration
                                              ()

                          GetEngineSize
                                      ()

                          Get PurchasePrice()



  Figure 27.01 Car class diagram
                                                                         Part 4: Chapter 27: Object-Oriented Programming (OOP)




27.03 Writing object-oriented code

Declaring a class
Attributes should always be declared as ‘Private’. This means they can only be accessed
through the class methods. So that the methods can be called from the main program, they
have to be declared as ‘Public’. There are other modifiers (such as ‘Protected’), but they are
beyond the scope of this book.

The syntax for declaring classes is quite different for the different programming languages. We
will look at the three chosen languages. You are expected to write programs in one ofthese.


Declaring a class in Python
The code below shows how a constructor, getters and setters can be declared in Python.


                    Two underscore characters
                    are required before and after
                    init to define the constructor                     Selfis the first parameter
                               7 /                                     inthe parameter list for
                                                                       every method
                class   Car,


                    def init
                          (self,              n,   e):                   #   constructor
                          self.   VehiclelD    =n
                          self.   Registration =            “”
                          self. DateOfRegistration                    = None
                          self.   EngineSize       =e
                          self.   PurchasePrice         =       0.00

                                                                                 Two underscore characters
                    def SetPurchasePrice(self,                   p):
                                                                                 before an attribute name
                          self.   PurchasePrice         = p
                                                                                 signify it is private
                    def SetRegistration(self,                   r):
                          self.   Registration =            r
                    def SetDateOfRegistration(self,                      d):
                          self. DateOfRegistration = d


                    def GetVehicleID      ID(self)
                          return(self.   VehicleID)


                    def GetRegistration(self):
                          return(self.   Registration)


                    def GetDateOfRegistration(self):
                          return(self.   Dated0fRegistration)


                    def GetEngineSize(self):
                          return(self.   EngineSize)


                    def    GetPurchasePrice (self):
                          return(self.   PurchasePrice)
Cambridge International AS & A Level Computer Science




Python also supports properties:


Python        ’      class Car:
using properties         def init
                               (self,            n,   e):                        # constructor
                               self. VehicleID      =n

                               self.
                                 Registration            =       ""

                               self. DateOfRegistration                  = None

                               self.   EngineSize     =e

                               self.   PurchasePrice         =       0.00


                         @property

                         def    VehicleID(self):

                               return(self.   VehicleID)


                         @property

                         def    EngineSize(self):

                               return(self.   EngineSize)


                         @property

                         def    Registration(self):

                               return(self.   Registration)


                         @Registration.setter

                         def    Registration(self,       r):

                               self.
                                 Registration            =       r


                         @property

                         def    DateOfRegistration(self):

                               return(self.   DateOfRegistration)


                         @DataOfRegistration.setter

                         def    DateOfRegistration(self,                 d):

                               self. DateOfRegistration                  =   d


                         @property

                         def    PurchasePrice (self):
                               return(self.   PurchasePrice)


                         @PurchasePrice.setter

                         def    PurchasePrice(self,          p):

                               self.   PurchasePrice         =       p



                     Note that not all properties provide a setter, only where attribute values are to be changed.
                                                                                 Part 4: Chapter 27: Object-Oriented Programming (OOP)




Declaring a class in VB.NET
The code below shows how attributes, the constructor, getters and setters can be declared
in VB.NET.



                                            Each attribute must be
                                            preceded by Private

VB.NET         Class Car
                     Private     VehicleID As                String
                     Private      Registration As                  String    =    ""
                     Private      DateOfRegistration As                     Date       =    #1/1/1900#
                     Private      EngineSize         As       Integer                                           Every public method header
                     Private      PurchasePrice              As    Decimal        =    0. 0                     must start with Public
                                                                                                            |
                     Public Sub New(ByVal n As String, ByVal e As String)        |
                         VehicleID =n                                 |
                         EngineSize =e                            _     The constructor always
                     End   Sub
                                                                                                                 has identifier New
                     Public      Sub   SetPurchasePrice                 (ByVal         p As     Decimal)
                           PurchasePrice         =       p
                     End   Sub


                     Public      Sub   SetRegistration                 (ByVal         r As     String)
                           Registration      =       r
                     End   Sub


                     Public      Sub   SetDateOfRegistration                      (ByVal        d As    Date)
                           DateOfRegistration                  =   d
                     End   Sub


                     Public      Function GetVehicleID()                    As        String
                           Return      (VehicleID)
                     End   Function


                     Public      Function GetRegistration()                           As    String
                           Return      (Registration)
                     End   Function


                     Public      Function GetDateOfRegistration()                              As    Date
                           Return      (DateOfRegistration)
                     End   Function


                     Public      Function   GetEngineSize()                      As    Integer
                           Return      (Enginesize)
                     End   Function


                     Public      Function GetPurchasePrice()                           As     Decimal
                           Return      (PurchasePrice)
                     End   Function

               End   Class
Cambridge International AS & A Level Computer Science




VB.NET also supports properties:

VB using      Module Modulel
 properties   [jmeammeme                            .                            .
                    Public      Property VehicleID()                 As    String
                    Public      Property Registration()                    As    String      =    TM"
                    Public      Property   DateOfRegistration()                        As   Date        =   #1/1/1900#
                    Public      Property   EngineSize()               As    Integer
                    Public      Property   PurchasePrice()                  As       Decimal      =     0.0


                    Public      Sub New(ByVal            n As      String,       ByVal      e As        String)
                          VehicleID    =n
                          EngineSize       =e
                    End   Sub


              End   Class



              Note that getters and setters are automatically available for any property.
              If some properties should be read-only, getters and setters have to be declared explicitly:

              Class   Car

                Private VehicleID As                          String

                Public       ReadOnly      Property VehicleID()                             As    String

                    Get

                      Return _VehicleID

                    End     Get

                End   Property


                Public       Property Registration()                            As    String

                Public       Property DateOfRegistration()                                  As    Date


                Private EngineSize As                             Integer

                Public       ReadOnly      Property EngineSize()                             As       Integer

                    Get

                      Return _EngineSize

                    End     Get

                End   Property


                Public       Property      PurchasePrice()                       As    Decimal

                Public       Sub   New(ByVal              n As       String,          ByVal       e     As    String)

                    _VehicleID       =n

                    _Registration          =       ""

                    _DateOfRegistration                       =   #1/1/1900#

                    _EngineSize        =e

                    _PurchasePrice             =        0.0

                End   Sub


              End   Class
                                                                          Part 4: Chapter 27: Object-Oriented Programming (OOP)




Declaring a class in Java

The code below shows how attributes, the constructor and methods are declared in Java.

               import    java.util.Date;

               class    Car

               {
                   private     String vehicleID;

                   private     String          registration;

                   private Date        dateOfRegistration;
                   private     int    engineSize;

                   private     float       purchasePrice;



                   public Car(String n,                       int    e)    //   constructor

                   {
                        vehicleID      =       n;

                        registration =                  "";
                        dateOfRegistration                     =    new Date();

                        engineSize         =    e;

                        purchasePrice               =    0;

                   }
                   public void        setPurchasePrice (float                     p)

                   {
                        purchasePrice               =    p;

                   }
                   public void        setRegistration(String                      r)

                   {
                        registration            =       r;

                   }
                   public void        setDateOfRegistration(Date                       d)

                   {
                        dateOfRegistration                     =    d;

                   }
                   public     String getVehicleID()

                   {
                        return (vehiclelID) ;

                   }
                   public     String getRegistration()

                   {
                        return (registration) ;

                   }
                   public Date getDateOfRegistration()

                   {
                        return (dateOfRegistration)
                                                  ;

                   }
                   public     int    getEngineSize()

                   {
                        return (engineSize) ;

                   }
                   public     float    getPurchasePrice()

                   {
                        return (purchasePrice) ;
Cambridge International AS & A Level Computer Science




Instantiating a class
To use an object of a class type in a program the object must first be instantiated. This means
the memory space must be reserved to store the attributes.

The following code instantiates an object ThisCar of class Car.


 Python             ThisCar   =   Car("ABC1234",     2500)

VB.NET              Dim ThisCar As      New Car("ABC1234",         2500)

 Java               Car   thisCar   =   new Car("ABC1234",        2500);




Using a method
To call a method in program code, the object identifier is followed by the method identifier
and the parameter list.

The following code sets the purchase price for an object Thiscar of class Car.


 Python             ThisCar.SetPurchasePrice (12000)
                    ThisCar.PurchasePrice       =   12000    # using properties

 VB.NET             ThisCar.SetPurchasePrice
                                       (12000)
                    ThisCar.PurchasePrice       =   12000    '   using properties

 Java               thisCar.setPurchasePrice
                                      (12000) ;




The following code gets and prints the vehicle ID for an object Thiscar of class Car.

                    print (ThisCar.GetVehicleID()
                                                )
                    print (ThisCar.VehicleID)        #   using properties

                    Console.WriteLine (ThisCar.GetVehicleID() )
                    Console.WriteLine(ThisCar.VehicleID)              '    using properties

                    System.out.print (thisCar.getVehicleID());




  TASK 27.01

  1.    Copy the car class definition into your program editor and write a simple
        program to test that each method works.
  2     A business wants to store data about companies they supply. The data to be
        stored includes: company name, email address, date of last contact.
        a   Design a class Company and draw a class diagram.
        b   Write program code to declare the class. Company name and email address
            are to be set by the constructor and will never be changed.
        c   Instantiate one object of this class and test your class code works.




27.04 Inheritance
The advantage of OOP is that we can design a class (a base class or a superclass) and then
derive further classes (subclasses) from this base class. This means that we write the code for
the base class only once and the subclasses make use of the attributes and methods ofthe
base class, as well as having their own attributes and methods. This is known as inheritance
and can be represented by an inheritance diagram (Figure 27.02).
                                                                    Part 4: Chapter 27: Object-Oriented Programming (OOP)




                  a                                             b


Figure 27.02 Inheritance diagram (a) standard and (b) alternative



— EEE
      Inheritance: all attributes and methods ofthe base class are copied to the subclass




  WORKED EXAMPLE 27.02


  Implementing a library system

  Consider
        the following problem.

  *     Acollege library has items for loan.

  «     Theitems are currently books and CDs.

  «     Items can be borrowed for three weeks.

  «     Ifa book is on loan, it can be requested by another borrower.

  Table 27.02 shows the information to be stored.


                                                       Library item

      Book                                                     cD

      Title of book”                                           Title of CD*

      Author of book*                                          Artist of CD*

      Unique library reference number*                          Unique library reference number*

      Whether it is on loan*                                   Whether it is on loan*

      The date the book is due for return*                     The date the CD is due for return*

      Whether the book is requested by another borrower _ | The type of music on the CD (genre)


  Table 27.02 Library system information


  The information to be stored about books and CDs needs further analysis. Note that we could have a
  variable Title, which stores the book title or the CD title, depending on which type of library item we are
  working with. There are further similarities (marked * in Table 27.02).

  There are some items of data that are different for books and CDs. Books can be requested by a borrower.
  For CDs, the genre is to be stored.

  We can define         aclass LibraryItem and derivea         Book class anda cp class from it. We can draw the
  inheritance diagrams for the LibraryItem, Book and cp classes as in Figure 27.03.



                                                                                                                   (Continued)
Cambridge International AS & A Level Computer Science




                LibraryItem




                          I
        Book                       CD




  Figure 27.03 Inheritance diagram for Libraryltem, Book and CD classes


  Analysing the attributes and methods required for all library items and those only required for books and
  only for CDs, we arrive at the class diagram in Figure 27.04.



                                               LibraryItem


                                  Title                 : STRING                   |_| atttorary items have
                                  Author Artist         :    STRING            =         these attributes
                                   ItemID               :    INTEGER
                                   OnLoan               :    BOOLEAN
                                   DueDate               :   DATE


                                   Constructor
                                             ()
                                   GetTitle()
                                   GetAuthor Artist ()                                   |       .         .
                                                                                             All library items have
                                   GetItemID()
                                   GetOnLoan ()
                                                                        =|                     these methods
                                   GetDueDate
                                            ()
                                   Borrowing
                                           ()
                                   Returning
                                           ()
                                   PrintDetails()




                                                                                    |                  l
   Attribute specific              Book                                     CD                         Attribute specific
    to Book class
                        r IsRequested     :   BOOLEAN|        |Genre_   :      STRING ——1                      to CD class
                         Constructor ()                       Constructor
                                                                        ()
  Methods specific |_| GetIsRequested()                       GetGenre ()                            Methods specific
   to Book class 7 Set IsRequested ()                         SetGenre ()               | Methods spec
  Figure 27.04 Class diagram for Libraryltem, Book and CD



  A base class that is never used to create objects directly is known as an abstract class. LibraryItemis an
  abstract class.



——
EEE
  Abstract class: a base class that is never used to create objects directly
                                                                                    Part 4: Chapter 27: Object-Oriented Programming (OOP)




Declaring a base class and derived classes (subclasses) in Python
The code below shows how a base class and its subclasses are declared in Python.


                                                  -_ The base class
                                                                          definition
Python        import datetime ——
              class LibrarylItem:

                   def    ss   init   (self,              t,       a,    i):                      #   initialiser   method
                         self.   Title     =t
                         self.   Author       Artist                    =a
                         self.   ItemID       =       i
                         self.   OnbLoan      =       False
                         self.   DueDate          =       datetime.date.today
                                                                            ()

                   def    GetTitle(self):
                         return(melf.      Title)


              # other Get methods          go here

                   def    Borrowing(self):
                         self.   OnLoan       =       True
                         self.   DueDate          =       self.          DueDate         +    datetime.timedelta(weeks-3)


                   def    Returning(self):
                         self. OnLoan         -       False

                   def    PrintDetails(self):
                         print (self. Title,',',                          self.      Author Artist,',')
                         print (self.    ItemID',',                       self. OnLoan,',',Self,
                                                                                           DueDate)

              class Book (Libraryltem) / == Asubclass definition
                   def    init
                            (self,                    t,       a,       i):                       #   initialiser   method
                         Libraryltem.
                               init (self, t,                                       a,       i)
                         self.   IsRequested                   =    False

                         self.   RequestedBy = 0                                                        This statement calls the

                   def GetIsRequested (self) :                                                        constructor
                                                                                                               for the base class
                         return(self.      IsRequested)

                   def    SetLiRequested (self) :
                         self.   IsRequested                   =    True


              class   CD(LibraryItem)
                                    :

                   def    init
                            (self,                    t,       a,       i):                       #   initialiser   method
                         Libraryltem.
                               init (self,                                     t,   a,       i)
                         self.   Genre    =       "


                  def     GetGestre(self):
                         return(self.      Genre)

                  def     SetGenre(self,              g):
                         self.   Genre    =g
Cambridge International AS & A Level Computer Science




Python             class      LibraryItem:

using properties
                        def    init
                                 (self,                     t,    a,       i):                      #   constructor   /   initialiser         method
                              self.     Title    =t

                              self.     Author       Artist                =a
                              self.     ItemID      =       i

                              self.     OnLoan      =       False

                              self.    DueDate          =       datetime. date.today()

                        @property

                        def    Title(self):

                              return(self.          Title)


                   #   other getters go here

                       def     Borrowing(self):

                              self.     OnLoan      =       True

                              self.    DueDate          =       self.           DueDate       +    datetime.timedelta (weeks=3)

                       def     Returning (self):

                              self.     OnLoan      =       False

                       def    PrintDetails(self):

                             print(self.        Title,';                   ',    self.        Author Artist,';            ',       end='')
                                                                                                                               f


                             print (self.       ItemID,';                   ',    self.       OnLoan,';        ',   self.          DueDate)

                   class     Book (LibraryItem)
                                              :
                       def    init
                                (self,                      t,   a,        i):                     #    initialiser   method
                             LibraryItem.
                                   init (self, t,                                        a,       i)
                             self.      IsRequested              =     False

                             self.     RequestedBy               =     0

                       @property

                       def    IsRequested(self):

                             return(self.           IsRequested)


                       @IsRequested.setter

                       def    IsRequested(self,                  b):
                             self.     IsRequested               =    b

                       #   print      details   method               for Book

                       def    PrintDetails(self):

                             print ("Book Details")

                             LibrarylItem. PrintDetails (self)

                             print (self. IsRequested)

                   class     CD(LibrarylItem)
                                            :


                       def init (self,                      t,       a,    i):                    #     initialiser method
                             LibraryItem.
                                   init (self, t,                                        a,    i)
                             self.     Genre    =    ""


                       @property

                       def    Genre(self)
                                        :

                             return(self.        Genre)



                       @Genre.setter

                       def    Genre(self,       g):
                             self.     Genre    =g
                                                                                                       Part 4: Chapter 27: Object-Oriented Programming (OOP)




Declaring a base class and derived classes (subclasses) in VB.NET
The code below shows how a base class and its subclasses are declared in VB.NET.



                                                                                                       The base class
                Class      LibraryItem
                                                                                                            definition
                      Private          Title As                  String
                      Private         Author                Artist             As       String
                      Private          ItemID               As       Integer
                      Private          OnLoan As                     Boolean             =       False
                      Private          DueDate                As         Date       =   Today


                      Sub       Create(ByVal                     t       As    String,             ByVal                a As    String,       ByVal         i    As   Integer)
                                Title       =t
                                Author Artist                        =    a
                                ItemID          =       i
                      End       Sub

                      Public          Function GetTitle()                                    As    String
                                Return          (Title)
                      End       Function


                      '    other       Get          method,               go    here


                      Public          Sub       Borrowing
                                                        ()
                                OnLoan          =       True

                                DueDate             =       DateAdd(DatelInterval.Day,                                         21,   Today())          '3       weeks       from Today
                      End       Sub


                      Public          Sub       Returning
                                                        ()
                                OnLoan          =       False
                      End       Sub


                      Sub       PrintDetails()
                                Console.WriteLine
                                             (Title &                                              ",       "       &    ItemID      &   ",    "   &   OnLoan           &     ",   "   &   DueDate)
                      End       Sub
                                                                                                                    The Inherits statement is
                End Class                           Asubclass definition
                                                                                                                        the first statement of a
                Class Book                  .                                                                             subclass definition
                      Inherits          LibrarylItem                                                            |
                      Private          IsRequested As                           Boolean                =    False
                                Public          Sub          SetIsRequested
                                                                          ()
                                       IsRequested                        =    True
                                End    Sub


                End   Class



                Class       CD

                          Inherits              LibrarylItem
                          Private       Genre                 As         String              =    TM


                          Public       Function                      GetGenre()                   As       String
                                 Return                 (Genre)
                          End    Function


                          Public       Sub              SetGenre(ByVal                       g As          String)
                                Genre       =g

                          End    Sub


                End       Class
Cambridge International AS & A Level Computer Science




  ae
WEA           ae Class LibraryItem
 properties             Public Property Title()
                        Public      Property Author Artist                    As       String

                        Public      Property          ItemID As         Integer

                        Public      Property OnLoan As                  Boolean         =   False

                        Public      Property DueDate As                  Date      =   Today


                        Sub Create(ByVal                  t As   String,      ByVal         a As    String,      ByVal    i As    Integer)

                            Title    =t

                            Author Artist             =a

                            ItemID    =       i

                        End   Sub


                        Public      Sub Borrowing
                                                ()

                            OnLoan    =       True

                            DueDate       =       DateAdd(DateInterval.Day,                   21,    Today())       '3   weeks    from today

                        End   Sub


                        Public      Sub Returning
                                                ()

                            _OnLoan       =       False

                        End   Sub


                        Public      Sub       PrintDetails()

                            Console.WriteLine
                                         (Title &                        ";   "    &    ItemID      &   ";   "   & OnLoan   &    ";   "   & DueDate)

                        End   Sub

                      End   Class


                      Class   Book

                        Inherits      LibraryItem

                        Public      Property          IsRequested()           =    False

                      End   Class


                      Class   CD

                        Inherits      LibraryItem

                        Public      Property Genre()               As    String

                      End   Class




Declaring a base class and derived classes (subclasses) in Java
The code below shows how a base class and its subclasses are declared in Java.


              import    java.util.Date;

              class    LibraryItem

              {
                  private     String      title;

                  private     String      author Artist;

                  private     int    itemID;

                  private     Boolean         onLoan;

                  private     Date    dueDate;

                  public LibraryItem(String t,                     String a,            int   i)        //   constructor

                  {
                                                                 Part 4: Chapter 27: Object-Oriented Programming (OOP)




         title    =       t;

         author Artist                  =    a;

         itemID       =       i;

         onLoan       =       false;

         dueDate          =    new Date();

     }
     public     String GetTitle()

     {
         return(title)
                     ;

     }
//   other Get methods                      go here

     public void borrowing
                         ()

     {
         onLoan       =       true;

         //dueDate = dueDate +                        21;

     }
     public     void          returning
                                      ()

     {
         onLoan       =       false;

     }

     public void printDetails()

     {
         System.out.print (title                       +"    ;   "+        author Artist         +"      ;   ")y
         System.out.println(itemID                          +";        "    +   onLoan   +   "   ;   "   +   dueDate)
                                                                                                                    ;




}
class    Book    extends               LibraryItem

{
     private     Boolean               isRequested;

     private     int          requestedBy;


     public     Book(String                  t,   String    a,   int       i)    //   constructor

     {
         super(t,             a,   i);

         isRequested               =    false;

         requestedBy               =    0;

     }

     public     Boolean getIsRequested
                                     ()

     {
         return (isRequested) ;

     }
     public    void           setIsRequested()

     {
         isRequested               =   true;
Cambridge International AS & A Level Computer Science




             }
             class          CD       extends             LibraryItem

             {
                      private             String          genre;


                      public          CD(String                t,    String   a,     int   i)      //    constructor



                            super(t,                a,    i);

                           genre              =    "";

                      }

                      public         String              getGenre()

                      {
                           return (genre) ;

                      }

                  public             void           setGenre (String            g)

                      {
                           genre              =   g;




Instantiating a subclass
Creating an object of a subclass is done in the same way as with any class (See Section 27.03).

 Python          ThisBook             =       Book(Title,             Author,      ItemID)

                 ThisCD          =    CD(Title,                Artist,      ItemID)

VB.NET           Dim ThisBook As New Book()

                 Dim ThisCD As                      New    CD()

                 ThisBook.Create(Title,                               Author,      ItemID)

                 ThisCD.Create (Title,                              Artist,   ItemID)

                 Book       thisBook                =    new    Book("Computing",               "Sylvia",    1234);

                 CD       thisCD          =       new    CD("Let       it   be",     "Beatles",         2345);




Using a method
Using an object created from a subclass is exactly the same as an object created from any class.




  TASK 27.02

  Copy the class definitions for LibraryItem, Book and CD into your program
  editor. Write the additional get methods. Write a simple program to test that
  each method works.
                                                               Part 4: Chapter 27: Object-Oriented Programming (OOP)




  TASK 27.03

  Write code to define a Borrower class as shown in the class diagram in Figure 27.05.

                       Borrower


   BorrowerName           :   STRING

   EmailAddress           :   STRING

   BorrowerlD             :   INTEGER

    ItemsOnLoan           :   INTEGER

              ()
    Constructor

   GetBorrowerName
                 ()

   GetEmailAddress
                 ()

   GetBorrowerID()

    Get ItemsOnLoan
                  ()

   UpdateItemsOnLoan
                   ()

    PrintDetails
               ()



  Figure 27.05 Borrower class diagram

  The constructor should initialise ItemsOnLoan to 0.

  UpdateItemsOnLoan()         should increment ItemsOnLoan by an integer passed as
  parameter.

  Write a simple program to test the methods.




27.05 Polymorphism
Look at Worked Example 27.02 and the code that implements it in Section 27.04. The
constructor method of the base class is redefined in the subclasses. The constructor
for the Book class calls the constructor of the LibrarylItem class and also initialises
the IsRequested attribute. The constructor for the cp class calls the constructor ofthe
Libraryltem class and also initialises the Genre attribute.

The PrintDetails method is currently only defined in the base class. This means we
can only get information on the attributes that are part of the base class. To include the
additional attributes from the subclass, we need to declare the method again. Although the
method in the subclass will have the same identifier as in the base class, the method will
actually behave differently. This is known as polymorphism.


————
EEE
   Polymorphism: the method behaves differently for different classes in the hierarchy



The way the programming languages re-define a method varies.

The code shown here includes a call to the base class method with the same name. You can
completely re-write the method if required.
Cambridge International AS & A Level Computer Science




               #    define      the print details method for Book
               def       PrintDetails(self):

                    print ("Book      Details")                        This line calls the base class
                    LibraryItem. PrintDetails (self)                   method with the same name.
                    print(self.          IsRequested)



VB.NET          '   in base class,         add the keyword Overridable
                '   to    the   method    to   be    redefined
               Overridable
                        Sub PrintDetails()


                '   in    subclass,      add   the    redefined method:

               Public       Overrides      Sub      PrintDetails()
                     Console.WriteLine
                                  ("Book Details")
                    MyBase. PrintDetails() This line calls the base class
                                                                       method with the same name.
                     Console. WriteLine (IsRequested)


               End Sub

               @Override

               public      void printDetails()

               {
                     System.out.printin("Book              Details")
                                                                   ;

                     super. printDetails();              ———              This line calls the base class
                     System.out.printin(isRequested)
                                                   ;                      method with the same name.




  TASK 27.04

  Use your program code from Task 27.02. Re-define the PrintDetail methods for the
  Book class and the cD class. Test your code.




  TASK 27.05

  Use your program code from Task 27.03. Add another attribute, BorrowerID, to the
  LibrarylItem class so that the item being loaned can have the borrower recorded.
  Change the LibraryItem.Borrowing
                     and LibraryItem.Returning methods, so
  that LoanItem.BorrowerID and Borrower.ItemsOnLoan are updated when a library
  item is borrowed or returned.




  TASK 27.06

  Use your code from Task 27.02 or Task 27.04. Add another attribute, RequestedBy, to
  the Book class so that the borrower making the request can be recorded.
  Change the method Book. SetIsRequested, so that Book.RequestedBy is updated
 when a book is requested.
                                                                                Part 4: Chapter 27: Object-Oriented Programming (OOP)




  TASK 27.07

  Use your code from Task 27.06 to write the complete program to implement a
  simplified library system.
  Write code to provide the user with a menu to choose an option. An example of a
  menu that would be suitable is shown in Figure 27.06.
          WN FB




                  -        Add   a   new borrower
   onynoan




                  -        Add   a   new    book

                  —-       Add   a   new    CD
       Ff




                           Borrow     a    book
                  I




                  -        Return     a    book

                  -        Borrow     a    CD

                  -        Return     a    CD

                  —        Reguest        book

    9             -        Print     all    details

    99                 -    Exit     program

   Enter                     your     menu       choice:



  Figure 27.06 Library system menu




27.06 Garbage collection
When objects are created they occupy memory. When they are no longer needed, they
should be made to release that memory, so it can be re-used. If objects do not let go of
memory, we eventually end up with no free memory when we try and run a program. This is
known as ‘memory leakage’.

How do our programming languages handle this?

                             Memory management involves a private heap containing all Python objects and data
                             structures, The management of the Python heap is performed by the interpreter itself.
                             The programmer does not need to do any housekeeping.

                             A garbage collector automatically reclaims memory from objects that are no longer
                             referred to by the running program,

                             The Java runtime environment deletes objects when it determines that they are no
                             longer being used,

Table 27.03 Garbage collection strategies



27.07 Containment (aggregation)
In Section 27.04 we covered how a subclass inherits from a base class. This can be seen
as generalisation and specialisation. The base class is the most general class, subclasses
derived from this base class are more specialised.

We have other kinds of relationships between classes. Containment means that one class
contains other classes. For example, a car is made up of different parts and each part will be
an object based ona                       class. The wheels are objects of a different class to the engine object. The
engine is also made up of different parts. Together, all these parts make up one big object.
Cambridge International AS & A Level Computer Science




QQ
   Containment: a relationship in which one class has a component that is of another class type



The containment relationship is shown in Figure 27.07.


        Car                                                                       Wheel

                     >


Figure 27.07 Containment (aggregation) class diagram


  WORKED      EXAMPLE 27.03


  Using containment

  A college runs courses of up to 50 lessons. A course may end with an assessment. Object-oriented
  programming is to be used to set up courses. The classes required are shown in Figure 27.08.

                                                Course


                           CourseTitle                        STRING

                           MaxStudents                        INTEGER

                           NumberOfLessons                    INTEGER

                           CourseLesson[1           :   50]   OF Lesson

                           CourseAssessment                   Assessment


                                     ()
                           Constructor

                           AddLesson
                                   ()

                                       ()
                           AddAssessment

                           Output CourseDetails ()




                   Lesson                                                 Assessment


    LessonTitle                  STRING                        AssessmentTitle              STRING

    DurationMinutes              INTEGER                       MaxMarks                     INTEGER

    RequiresLab                  BOOLEAN


              ()
    Constructor                                                          ()
                                                               Constructor

    OutputLessonDetails
                      ()                                       OutputAssessmentDetails()


   Figure 27.08 Containment class diagram


   Assuming that all attributes for the Lesson and Assessment Classes are set by values passed as parameters
   to the constructor, the code for declaring the Lesson and Assessment classes is straightforward.
   The code below shows how the course Class is declared.
                                                                                                               (Continued)
                                                                                                      Part 4: Chapter 27: Object-Oriented Programming (OOP)




Python Course class declaration
class       Course:

      def     _init_ (self,              t,      m):          #       sets      up       a   new      course

            self.          CourseTitle                    t

            self.          MaxStudents            =       m

            self. NumberOfLessons                                 =       0

            self.          CourseLesson               =       []

            self. CourseAssessment                                    =   Assessment


      def    AddLesson(self,              t,      d,          r):

            self.__NumberOfLessons                                =       self.__NumberOfLessons                      +   1

            self. CourseLesson.append(Lesson(t,                                                  d,    n))


      def    AddAssessment(self,                      t,           m):

            self. CourseAssessment                                    =   Assessment(t,                 m)


      def    OutputCourseDetails(self):

            print(self._CourseTitle,                                      "Maximum number:                    ",   self.__MaxStudents)
            for    i    in     range(self.__NumberOfLessons):

                  print(self._CourseLesson[i] .OutputLessonDetails())



VB.NET Course class declaration
Class       Course

      Private          CourseTitle As             String

      Private          MaxStudents        As          Integer

      Private NumberOfLessons As                                      Integer            =   0

      Private          CourseLesson(50)                   As          Lesson

      Private          CourseAssessment As Assessment


      Public       Sub      Create(ByVal              t As                String,            ByVal     m As        Integer)

            CourseTitle          =   t

            MaxStudents          =   m

      End    Sub


      Sub AddLesson(ByVal                 t      As           String,               ByVal        d As      Integer,       ByVal   r As   Boolean)
            NumberOfLessons              =       NumberOfLessons                             +   1

            CourseLesson(NumberOfLessons)                                           =   New      Lesson

            CourseLesson(NumberOfLessons).Create(t,                                                   d,     nr)

      End    Sub

      Public       Sub AddAssessment (ByVal                                    t As      String,           ByVal    m As      Integer)

            CourseAssessment                 =   New Assessment

            CourseAssessment.Create(t,                                    m)

      End    Sub


      Public       Sub     OutputCourseDetails()

            Console.WriteLine(CourseTitle                                       &       "Maximum number:              "   & MaxStudents)

            For    i   =   1   To NumberOfLessons

                  CourseLesson(i).OutputLessonDetails()

            Next

      End    Sub

End    Class



                                                                                                                                                    (Continued)
Cambridge International AS & A Level Computer Science




 Java Course class declaration
 class       Course

 {
       private        String          courseTitle;

       private        int   maxStudents;

       private        int    numberOfLessons;

       private        Lesson[]             courseLesson;

       private       Assessment                    courseAssessment;


       public        Course(String                     t,        int m)          //       sets        up       a new     course

       {
             courseTitle              =       t;

             maxStudents              =       m;

             numberOfLessons                       =       0;

             courseLesson                 =    new          Lesson[50];

             //courseAssessment                            = new Assessment();

       }
       public        void    addLesson(String                         t,    int           d,        Boolean        r)

       {
             numberOfLessons                       =       numberOfLessons                      +    1;

             courseLesson[numberOfLessons]                                       =    new           Lesson(t,           d,    nr);

       }
       public        void    addAssessment(String                                t,           int    m)

       {
             courseAssessment                          =    new Assessment(t,                        m);

       }
       public        void    outputCourseDetails()



             System.out.println(courseTitle                                      +        "    -    Maximum number                   of   students:   "   +   maxStudents);

             for     (int    i    =       1;       i   <        numberOfLessons;                     i++)

             {
                   courseLesson[i].outputLessonDetails();




 }
 Here are simple test programs to check it works.


 Python test program
 def       Main():

       MyCourse        =    Course("Computing",                            10)        #       sets        up   a   new       course



       MyCourse.AddAssessment("Programming",                                                    100)       #   adds      an    assignment

       #    add 3     lessons

       MyCourse.AddLesson("Problem                                   Solving",                 60,     False)

       MyCourse.AddLesson("Programming",                                          120,             True)

       MyCourse.AddLesson("Theory",                                   60,    False)


       #    check     it    all       works

       MyCourse.OutputCourseDetails()



                                                                                                                                                                              (Continued)
 VB.NET test program
 Dim MyCourse                    As   New   Course

 MyCourse.Create("Computing",                        10)    '   sets     up    a     new      course

 MyCourse.AddAssessment("Programming",                                 100)     '    adds      an   assessment

  '        add   3    lessons

 MyCourse.AddLesson("Problem                         Solving",         60,    False)

 MyCourse.AddLesson("Programming",                              120,    True)

 MyCourse.AddLesson("Theory",                         60,   False)

  ‘check             it    all   works

 MyCourse.OutputCourseDetails()

 Console.ReadLine()



 Java test program
 Course myCourse                      =   new Course("Computing",              10);      //   sets up   a new course

 myCourse.addAssessment("Programming",                                 100);        //   adds   an assessment

 //        add 3          lessons

 myCourse.addLesson("Problem                         Solving",         60,    false);

 myCourse.addLesson("Programming",                              120,    true);

 myCourse.addLesson("Theory",                         60,   false);

 //        check          it   all    works

 myCourse.outputCourseDetails();




      TASK 27.08

      Write the code required for the Lesson and Assessment classes. Add the code for
      the Course class and test your program with the appropriate simple program from
      Worked Example 27.03.



Reflection Point:
Explain why a class can be regarded as a use-defined type.




      m=    Aclass has attributes (declared as private) and methods (declared as public) that operate on the attributes.
            This is known as encapsulation.

            Python and VB.NET support properties: attributes that also include getters and setters.

            Aclass is a blueprint for creating objects.

            An object is an instance of a class.

            Aconstructor is a method that instantiates a new object.

            Aclass and its attributes and methods can be represented by a class diagram.

            Classes (subclasses) can inherit from another class (the base class or superclass). This relationship between
            a base class and its subclasses can be represented using an inheritance diagram.

            Asubclass has all the attributes and methods of its base class. It also has additional attributes and/or methods.

            Polymorphism describes the different behaviour of a subclass method with the same name as the base class method.

            Containment is a relationship between two classes where one class has a component that is of the
            other class type. This can be represented using a containment diagram.
      Z    A program is to be written using an object-oriented programming language.
                                                                                          A bank account
           class is designed. Two subclasses have been identified:

           *       Personal Account: the account hoider pays a monthly fee and may overdraw
                                                                                            the
                   account up to an agreed overdraft timit.

          *        Savings Account: the account holder must maintain a positive balance and
                                                                                                pets paid


          @        Draw an inheritance ciagram for these classes.
                                                                                                                    i3]
          The design for the BankAccount Class consists of:

          »®   attributes:
               ®       AccountHolderName

               °       TRAN: international Bank Account Number

          ®    methods:
               @       CreateNewAccount

               ®       SetAccountHolderName

               ®       GetAccountHolderName

               *       GekIBAN


          b    Write program code for the class definition of the su perclass BankAccount.
                                                                                                                    5I
          €    -       State the attributes and/or methods recuired for the subclass ParsonalAccount.
                                                                                                                    4|
               ii     = State the attributes and/or methods required for the subclass SavingsAccount.
eee




                                                                                                                    [4]
               iii,    entity the feature of object-oriented program design that combines the attributes
                       and methods into a class.
                                                                                                                    [1]
      2   Abus company in a town has two types of season ticket for their regular custorners:
                                                                                         pay-as-you
          go and contract. Ali season ticket holders have their name and email address recorded.

          A pay-as-you-go ticket holder pays a chosen amount into their account, Each
                                                                                           time the ticket holder
          makes a journey on the bus, the price of the fare is deducted from the arnount held
                                                                                                 in the account.
          They can top up the amount at any time.

          A contract ticket holder pays a fixed fee per month. They can then make
                                                                                     unlimited journeys on the bus.


          using an object-oriented programming language.
                                                                         Part 4: Chapter 27: Object-Oriented Programming (OOP)




    a           Complete the class diagram showing the appropriate attributes and methods.                                          [7]

                                                                    SeasonTicketHolder

                                                           PRIVATE

                                                           TicketHolderName:    STRING




                                                           PUBLIC

                                                           Constructor ()




                                            Pay-As—You—-Go-TicketHolder            ContractTicketHolder




                                                                               Constructor                (Name:       STRING,

                                                                               email    :       STRING,      Fee   :   CURRENCY)




    b       Attributes and methods can be declared as either public or private.

            i         Explain why the SeasonTicketHolder attributes are declared as private.




                                                                                                                                   "NO
                                                                                                                                     a
            li        Explain why the SeasonTicketHolder methods have been declared as public.


                                                                                                                                   NS
    c       Write program code to create a new instance of ContractTicketHolder with:

            °          Identifier: NewCustomer

            *          name:A. Smith

            *         email address: xyz@abc.xx

            ¢     — monthly fee: $10                                                                                               [3]
3   Aqueue abstract data type (ADT) is to be implemented using object-oriented programming.
    Two classes have been identified: Queue and Node. The class diagrams are as follows:

                          QueueClass                                                    NodeClass


    Queue         :   ARRAY[O       :   50]   OF   NodeClass                Data            :       STRING

    Head          :    INTEGER                                              Pointer         :       INTEGER

    Tail          :    INTEGER
        +                  G                                                Constructor ()
    Constructor ()                                                          SetData(d           :    STRING)
    JoinQueue (NewItem                  :   NodeClass)                      SetPointer(x              :   INTEGER)

    LeaveQueue()               :   STRING                                   GetData    ()             :   STRING

                                                                            GetPointer()              :   INTEGER



    a       State the relationship between these two classes.                                                                      [1]
                                                                                                                                                 SS
                                                                                                                                                  — o
                                                                                                                                                        e

                                                                                                                                                 _ __
                                                                                                                                                 SOS
                                                                                                                                                 _
                                                                                                                                                     -O
                                                                                                                                                      e RS
                                                                                                                                                        ae
                                                                                                                                                         —
                                                                                                                                                           Ss
                                                                                                                                                           s—
                                                                                                                                                           —
                                                                                                                                                             Sea,
                                                                                                                                                             .
                                                                                                                                                                  -
                                                                                                                                                                  _
                                                                                                                                                                    ue3
                                                                                                                                                                    --
                                                                                                                                                                      s
                                                                                                                                                     _
                                                                                                                                                     oe   —e _-
                                                                                                                                                                        ce


                                                                                                                                                 __ae____
                                                                                                                                                        —a
                                                                                                                                                              ES H
                                                                                                                                                        __ < ee
                              He g                                                                                                                            _
                                         Ney
                @
                          Nitt
                              alis
                                       e th
                                                    ; ode
                                                                                                                                                              ___
                                            e
                                                    ata
               ®                                          Sttr
                      iNit                                       ibut
                             iali                                       e £0
                                   se t                                         the
                                         he                                            ap
                                                                                        “,
                                                “in                                       P   LY
               TE                                      ter                                          Str
                    S D                                        attr                                      ing
                        rop      ran,
                                                                     i; U
                                                                          le    to 3
    ©                                   COd
                                                e to
              The                                      Shi
                    Que                                        ne N
                           uec                                         oda
                                 ; as                                        cn,
                                        s “O                                         SS.
                                                NSEr                                         1C
             "C                                        uict                                        yli  ng (
                    re
                         sf                                    op IS                                           he g
                             ea N                                      to:                                          et
                                       ey
                                            Wuei
                                                                                                                         IC S
                                                    yes                                                                          et M
                                                                                                                                        eth
                    ali                                                                                                                    ods
                           ce
                                  the
                                         flea
            Write                               d an
                    PrOgr                                 e Ta
                                                               il at
                                                                                                                                                         10]
                             ary ,                                     t,u
a                                      Ode t                                   tes
            The J                               o,Cefi                                  4     -]
                    OLnQ                                   ne the
                            uee                                        ConSst
                                     Meth                                       ructo
        "C                                      odjc t                                       rs
                                                                                              OF Q
              re
                    at                                    o;                                         usuec
                      e 3
                              Ney                                                                                iag.
                                       ODj
        *                                     ect
                                                L
               Ssj                                   Nod
                     c
                     EB)                                   e, O
                         t  he v                                 F N
                                                                     ad      eC
                                  ay,                                         rla
    "                                       Pas                                   s    s
              a8S
                    ign
                                                    se
                                                           a8 p                                                                                         [2]
                          Nod                                 HA
                                 e t                                   M e
                                     o ih                                  bay
    Write                                     e e                                    ;(0 t
                                                                                            he ;
              PTO8r                              ng
                                                       Of Q                                        C8
                      apy O                                    uer
                                                                   e
                                                                                                          attr
                                                                                                               ibu
                                 de t                                                                                p
                                                                                                                     te O
                                          y¢                                                                              F   Neoede
                                                                                                                                    s
                                                                                                                 qeae

                                                                                                                        ee a
                                      cy
                                      a
                                      ?a’

                             ]
                             J
                         ~            ! « -                                                       ars
                                      |      we                                                   4
                                          wes,                                                    ‘


                                          a?                                                      xo’

                                                                  ]   .


                                                                  <   ehe   te                    vr
                                                                              a                   eve
                                                                                                  a
                         mF                       hae                       vr
                                                                             o                    yw
                         a            mars         =<




Chapter 28:
 Low-level programming


By the end of this chapter you should be able to:

      write low-level code that uses various address modes: immediate, direct, indirect, indexed and relative.




                -*.                                                                               ®   ¥

                »=                                                                                =)
           v8            ~~                                                            >          8




                         (       ae                                                         ;
                         *       .                                                          "

            RS                                                                         =o       os Dp
            ]        4

                                                                                                  .
                                                                                                  -



—
           Wad
            bo’          ".                                                           fey         Yat


 :                                                                                     es!
 °
rat         (aa          an
                             :                                                         yy |
                                                                                       Pe)

                 2
            a\
           Ne
 -         a®    «®
Cambridge International AS & A Level Computer Science




28.01 Processor instruction set
The instruction set we will use in this chapter is shown in Table 28.01.

 Instruction                                           Explanation

 Label           Op code          Operand
 Data movement instructions

                 LDM              #n                   Immediate addressing. Load the denary number nto ACC

                 LDD              <address>            Direct addressing. Load the contents of the location at the given address to ACC

                 LDI              <address>            Indirect addressing. The address to be used is at the given address. Load the
                                                      contents of this second address to ACC

                 LDX              <address>            Indexed addressing. Form the address from     <address> + the contents of the
                                                      index register. Copy the contents ofthis calculated address to ACC

                 LDR              #n                   Immediate addressing. Load the denary number nto IX

                 MOV              <register>           Move the contents of Acc    to the given register (IX)

                 STO              <address>           Store the contents of Acc     at the given address

                 STX              <address>            Indexed addressing. Form the address from     <address> + the contents of the
                                                      index register. Copy the contents from Acc to this calculated address”

                 STI              <address>           Indirect addressing. The address to be used is at the given address. Store the
                                                      contents of Acc at this second address*

 “Note: The STX and STI instructions are not given as part of the instruction set in the syllabus for 9618

Arithmetic operations

                 ADD              <address>           Add the contents of the given address to the Acc

                 ADD              #n                  Add the denary number nto the Acc

                 SUB              <address>           Subtract the contents of the given address from the Acc

                 SUB              #n                  Subtract
                                                            the denary number
                                                                          n from the Acc

                 INC              <register>          Add 1 to the contents of the register (ACC or IX)
                 DEC              <register>          Subtract 1 from the contents of the register (ACC or IX)
Comparison and jump instructions

                 JMP              <address>           Jump
                                                         to the given address

                 CMP              <address>           Compare the contents of Acc with the contents of <address>

                 CMP              #n                  Compare the contents of Acc with the denary number
                                                                                                       n

                 CMI              <address>           Indirect addressing. The address to be used is at the given address. Compare the
                                                      contents of ACc with the contents of this second address

                 JPE              <address>           Following a compare instruction,
                                                                                  jump to <address> ifthe compare was True

                 JPN              <address>           Following a compare instruction,
                                                                                  jump to <address> ifthe compare was False

 Input/output instructions

                 IN                                   Key in a character and store its ASCIl value in Acc

                 OUT                                  Output to the screen the character whose ASCII value is stored in Acc

 Bit manipulation instructions

                 AND              #n                  Bitwise AND operation of the contents of ACC with the operand

                 AND              <address>           Bitwise AND operation of the contents of ACc with the contents of <address>

                 XOR              #n                  Bitwise XOR operation of the contents of Acc with the operand

                 XOR              <address>           Bitwise XOR operation ofthe contents of ACC with the contents of <address>

                 OR               #n                  Bitwise OR operation of the contents of ACC with the operand
                                                                              Part 4: Chapter 28: Low-level programming




    Instruction                                   Explanation

    Label         Op code       Operand
                  OR            <address>         Bitwise OR operation of the contents of Acc with the contents of <address>

                  LSL           #n                Bits in Acc are shifted logically n places to the left. Zeros are introduced on the
                                                  right-hand end

                  LSR           #n                Bits
                                                     in Acc are shifted logically
                                                                             n places to the right. Zeros are introduced on the
                                                  left-hand end

    Other

                  END                             Return control to the operating system
    <label>:      <opcode>      <operand>         Labels an instruction

    <label>:      <data>                          Gives a symbolic address <label> to the memory location with contents
                                                  <data>


Table 28.01 Processor instruction set

In the assembly code in this chapter:

e     acc denotes the Accumulator

e     1x denotes the Index Register

e     #denotes immediate addressing

¢     Bdenotes a binary number, e.g. Bo1001010

¢     &denotesa hexadecimal number, e.g. 4A

°     <address> can be an absolute address or a symbolic address.

An instruction set was introduced in Chapter 6.



28.02 Symbolic addresses
A label is a symbolic name for the memory location that it represents. You can treat it like a
variable name. When writing low-level programs, we can give absolute addresses of memory
locations. This is very restrictive, especially if we want to change the program by adding extra
instructions. Writing low-level instructions using symbolic addresses (labels), allows us to
think at a higher level. The assembler will allocate absolute addresses during the assembly
process (see Chapter 6, Section 6.03).



28.03 Problem-solving and assembly-language programs
When writing a solution to a problem using low-level programming, we need to break down
the problem into simple steps that can be programmed using the instruction set available.

One approach is to think in terms of the basic constructs we discussed for high-level languages.
You can use the following examples as design patterns.
Cambridge International AS & A Level Computer Science




Assignment
Table 28.02 shows some examples of assembly language assignments that match the pseudocode.

 Pseudocode        Assembly code          Explanation
examples           examples
A< 34                     LDM #34         To store
                                               a value in a memory location,
                                                                          the value must first be generated in the
                          STO A           accumulator

 Be B+il                  LDD B           To increment the value stored at a memory location: first load the value into the
                          Inc acc         accumulator, increment the value and then store the contents of the accumulator back to
                          STO B           the memory location

 Be B+A                   LDD B           To calculate a value: load the first value from a memory location into the accumulator,
                          ADD A           then add the value stored at the second memory location to the accumulator and then
                          STO B           store the contents of the accumulator
                                                                              to the required memory location

Ac -A                     LDD A           Load the value (assuming eight bits),
                          XOR #&FF       | XORwith 11111111 to produce the one’s complement. Add 1 to get the two’s
                                          complement.
                           INC   ACC
                                          Alternatively, set the ACC to zero and then subtract the value from the ACC and store it
                           STO   A
                                          back in the original address

                   Alternative method:
                          LDM    #0

                           SUB   A

                           STO   A


Table 28.02 Using assignment instructions



  TASK 28.01

  Write assembly code instructions for this sequence of pseudocode statements:
  Ae<e2

  B<-    10

  C<-    A+B

  D<A-B




Selection
Table 28.03 shows some examples of assembly language selections that match the pseudocode.

 Pseudocode         Assembly code           Explanation
 examples           examples
 IF A= 0                     LDD A          Load the contents of the memory location to be tested.
   THEN                      CMP #0         Compare it with the required value (in this example 0).
                                            If the comparison result is false (A does not equal 0), a
      B<eBeil                JPN ENDIF      |.
                                            jump over the THEN part is required; if the comparison
 BNDTE              THEN: LDD B             result is true (A= 0) then the following instructions are
                             Inc Acc        executed. For ease of understanding, the labels THEN
                             STO B          and ENDIF are used.
                    ENDIF:
                                                                                             Part 4: Chapter 28: Low-level programming




 IFA        =B                           LDD   A          Load the contents of A.

   THEN                                  SUB   B          Subtract B.

        OUTPUT           "yY"            CMP   #0         If the result is zero,   A=B.

   ELSE                                  JPN ELSE | Ifthe comparison result is false (A does not equal B),
        OUTPUT           "N" | THEN:     LDM   #89        jump to the ELSE part; if the comparison result is true

                                                          (A= B) the instructions following the THEN label are
 ENDIF                                   OUT
                                                          executed.
                                         JMP   ENDIF                                             ;      ;
                                                          Note that a jump over the ELSE part is required.
                                ELSE:    LDM   #78

                                         OUT

                                ENDIF:


Table 28.03 Using selection instructions



  TASK 28.02

  Write assembly code instructions for this sequence of pseudocode statements:
   IF   A   <>   0

        THEN

            BeA

        ELSE

            B<eB-1




Repetition
Table 28.04 shows an example of repetition in assembly language that matches the pseudocode.

 Pseudocode example | Assembly code                             Explanation
                                   example
 A=     0                                      LDM   #0

 REPEAT                                        STO A            Store the initial value of the counter in A.

        OUTPUT           "*"       LOOP:       LDM #42          Generate
                                                                  the ASCII code for the character
                                                                                                "*"
        AeAgil                                 OUT              and output
                                                                        it.

 UNTIL A =           5                         LDD A            Load the counter value,

                                               INC Acc          increment
                                                                       the counter,

                                               STO A            save it,
                                               CMP #5           test for final value.
                                               JPN LOOP         If final value has not been reached, jump back to
                                                                beginning
                                                                     of loop.

Table 28.04 Using repetition instructions
Cambridge International AS & A Level Computer Science




  TASK 28.03

  Write assembly code instructions for this sequence of pseudocode statements:
  Number        <       1

  Total     <       0

  Max   <   5

  REPEAT

        Total           <        Total     +     Number

        Number                   < Number        +   1

  UNTIL     Number                 =   Max




Input/output
Table 28.05 shows some examples of input and output in assembly language that match
the pseudocode.

 Pseudocode | Assembly code                                Explanation
 examples                   examples
 INPUT A                                IN                 Store a character input from the keyboard at memory location
                                        STO      A         A.


 OUTPUT B                               LDM #-1 | To output a string of characters stored in consecutive
                                        MOV IX    locations, starting at location labelled B, a loop and indexed
                            LOOP:       INC IX             addressing are used.
                                        LDX B              The first time round the loop the index register is 0 and
                                                           the character in memory location B will be loaded into the
                                        OUT                accumulator and output to the screen. Then a check is made
                                        CMP #13          | forthe end of the string (the carriage return character with
                                        JPN Loop | ASCII code 13). If itis not the end of the string, jump back to
                                                           the beginning of the loop.

                                                           To output a number, the number must first be changed into its
                                                           equivalent string and stored in consecutive memory locations.
                                                           Then the above method can be used.

 INPUT A                                LDM #-1 | Store a string of characters input from the keyboard into
                                        MOV IX    consecutive memory locations starting from A.
                            LOOP:       INC IX             Note: The STX instruction is not given as part of the instruction
                                        IN                 set in the syllabus for 9618 (from now on referred to as the
                                                           9618 instruction set). This means a string can not be saved
                                        STX A              with the 9618 instruction set.
                                        CMP      #13

                                        JPN      LOOP


Table 28.05 Using input and output instructions



  TASK 28.04

  Write assembly code instructions for this sequence of pseudocode statements:
  Count     <       0

  REPEAT

        Count               <«   Count       +   1

        INPUT               Character

  UNTIL     Character                  =     "N"
                                                                                        Part 4: Chapter 28: Low-level programming




  TASK 28.05

  Modify your assembly code instructions from Task 28.04 to implement this sequence
  of pseudocode statements:
  Count    <       0

  REPEAT

         Count         <    Count        +   1

         INPUT         Character

  UNTIL    Character             =       "N"

  OUTPUT       Count




28.04 Absolute and relative addressing
An absolute address is the numeric address ofamemory location. A program using absolute
addresses cannot be loaded anywhere else in memory. Some assemblers produce relative
addresses, so that the program can be loaded anywhere in memory.

Relative addresses are addresses relative to a base address, for example the first instruction
of the program. When the program is loaded into memory the base address is stored
in a base register BR. Instructions that refer
                                             to addresses then use the value in the base
register, modified by the offset. Forexample, sTo                [BR]     + 10 willstore the contents of the
accumulator at the address calculated from (contents of the base register) + 10.

Table 28.06 shows an example of instructions using symbolic, relative and absolute addressing.

 Symbolic addressing | Offsetfrom                 | Relative addressing (base              Absolute addressing
                                     base (START) | address stored in base register)

 START:        LDM         #0        0              LDM   #0                                100   LDM   #0

               STO A                 1              STO   [BR]   +   10                     201   STO   210

 LOOP:         LDM         #42       2              LDM   #42                               202   LDM   #42

               OUT                   3              OUT                                     203   OUT

               LDD A                 4              LDD   [BR]   +   10                     204   LDD   210

               INC     ACC           5              INC   ACC                               205   INC   ACC

               STO A                 6              STO   [BR]   +   10                     206   STO   210

               CMP         #5        7              CMP   #5                                207   CMP   #5

               JPN         LOOP | 8                 JPN   [BR]   +   2                      208   JPN   202

               END                   9              END                                     209   END

A:             0                     10             0                                       210   0O


Table 28.06 Symbolic, relative and absolute addressing


It is very important that, at the end of the program, control is passed back to the operating
system. Otherwise the binary pattern held in the next memory location will be interpreted as an
instruction. lf the content of that memory location does not correspond to a valid instruction,
the processor will crash. The instruction END signals the end of the program instructions.

Note: the 9618 instruction set does not include relative (base register) addressing.



28.05 Indirect addressing
Indirect addressing is useful if the memory address to be used in an instruction is changed
during the execution of the program.
Cambridge International AS & A Level Computer Science




One example is when programming subroutines to which parameters are passed by
reference (this is beyond the scope of this book).

Another use of indirect addressing is for a pointer variable.



  WORKED EXAMPLE 28.01


  Writing a program for a simple queue

  At the top level, we can write the problem using structured English:
  Add    a    character       to    the    queue:

  1          Store    the    contents       of    the   accumulator      in   the   memory      location
  pointed          to by    the    tail    pointer.

  2           Increment      the    tail    pointer.

  Remove       a    character       from    the    queue:

  1          Load    contents       of    the memory      location      at    the   head   of   the     queue.

  2           Increment      the    head pointer.


  Table 28.07 shows an example of instructions that implement the above queue-processing algorithms.


      Instruction                                           Explanation

      Label           Op code             Operand
      JOINQ:          STI                 TAILPTR           Store contents of ACC in the memory location pointed to by the tail pointer

                      LDD                 TAILPTR           Increment
                                                                the tail pointer

                      INC                 ACC

                      STO                 TAILPTR


                      IMP                 ENDQ


      LEAVEQ:         LDI                 HEADPTR           Load contents of memory location at the head of the queue

                      OUT                                   Outpu
                                                              the character
                                                                        t

                      LDD                 HEADPTR           Increment
                                                               the head pointer

                      INC                 ACC

                      STO                 HEADPTR

                      IMP                 ENDQ

      ENDQ
         :




      HEADPTR:       | QSTART                               Pointer
                                                              to start of queue

      TAILPTR:       | QSTART                               Pointer to next free location in    queue

      QSTART:         mn                                    Start of   memory reserved for queue, currently empty


  Table 28.07 Queue processing


  Note that the value shown in Table 28.07 at the memory locations labelled HEADPTR and TAILPTR is the
  address ofthe start of the memory locations reserved for the queue. As values are added to the queue, the
  TAILPTR value will increase to point to the memory location at the end of the queue data. When a value is
  taken from the queue, the HEADPTR value will increase to point to the memory location at the head ofthe
  queue data.

  Note: the 9618 instruction set does not include the STI opcode and a character can not be added to the
  queue using the 9618 instruction set.
     Write instructions to reverse a word entered at the keyboard. This requires access to
     an area of memory treated as a stack.



Reflection Point:
Here are the addressing modes you should be able to use when writing low-level code:

    Immediate

    Direct

    Indirect

    Indexed

    Relative

Tick the box next to each addressing mode you can use easily and place a cross in the boxes
next to the addressing modes you have difficulty with.




     =    Aproblem to be solved must be broken down into simple steps that can be programmed using the
          processor’s given instruction set.

     =    Avalue must be copied into the accumulator before it can be processed.

     m    Processing includes:

          «    arithmetic: adding, incrementing, decrementing

          e    comparison: equal or not equal

          «    bitwise operations: AND, OR, XOR, shifting

          «    output to screen.

     =    Toseta value inthe accumulator it can be:

          «    input from the keyboard

          «    created using immediate addressing

          «    loaded from amemory location using direct, relative, indirect or indexed addressing.

     m    Anaddress can be absolute (a number) or symbolic (a label).




1     The instruction set ofa processor with one general-purpose register, the accumulator, includes the
      following instructions.

         Instruction                                    Explanation

         Label          Op code          Operand

                        LDD              <address>   | Direct addressing. Load the contents of the given
                                                        address to ACC

                        STO              <address>    | Store the contents of Acc at the given address

                        ADD              <address>    | Add the contents of the given address to the ACC

                        IN                              Key in a character and store its ASCII value in ACC

                        AND              <address>    | Bitwise AND operation of the contents of ACC with
                                                        the contents of <address>
Cambridge International AS & A Level Computer Science




        Instruction                                           Explanation

        Label             Op code         Operand
                          LSL             #n                  Bits in Acc. are shifted logicallyn places to the left.
                                                              Zeros are introduced on the right-hand end

                          END                                 Return control to the operating system

        <label>:          <data>                              Gives asymbolic address <label>
                                                                                            to the memory
                                                              location with contents <data>


    Key to the above table:
    e        acc denotes the Accumulator.

    e        #denotes immediate addressing.
    e        «denotesa hexadecimal number, e.g. &4A.

    «        <address> can be an absolute address or a symbolic address.

    a___       Explain the operation of the aNp instruction.                                                            [1]

    b         TheASCll code for ‘0’ is the binary value 00110000. The ASCII code for ‘I’ is the binary
              value 00110001.

              Write an AND instruction to convert any numeric digit stored in acc in the form of an ASCII code
              to its eight-bit binary integer equivalent.                                                               [1]

    c         Write the assembly code instructions to convert a two-digit number keyed in at the
               keyboard to its BCD representation. Store the result in the memory location labelled Result.             [7]

                Instruction                                     Explanation

                Label           Op code        Operand
                                                                Input first digit

                                                                Convert from ASCII to its digit value

                                                                Move to upper nibble

                                                                Store in location Result

                                                                Input second digit

                                                                Convert from ASCII to its digit value

                                                                Combine the two values

                                                                Store result

                                                                End of program
               Mask:                                            Mask to convert from ASCII to digit equivalent
                Result:         &00                             Memory location for result

2   Agiven processor has one general-purpose register, the accumulator acc, and one index
    register, Ix. Part of the instruction set for this processor is as follows.

           Instruction                                   Explanation

           Label         Op code       Operand
                         LDM           #n                Immediate addressing. Load the numbern
                                                                                              to ACC

                         LDD           <address> | Direct addressing. Load the contents of the given
                                                         address to ACC

                         LDX           <address> | Indexed addressing. Form the address from
                                                   <address> + the contents of the Index Register. Copy
                                                   the contents ofthis calculated address to ACC

                         LDR           #n                Immediate addressing. Load the denary number
                                                                                                    n
                                                         to   IX
                                                                                Part 4: Chapter 28: Low-level programming




     Instruction                                   Explanation

     Label          Op code       Operand

                    STO           <address> | Store the contents of Acc at the given address

                    STX           <address> | Indexed addressing. Form the address from
                                                   <address> + the contents of the index register. Copy
                                                  the contents from Acc to this calculated address

                    ADD           <address> | Add the contents of the given address to the ACC

                    INC           <register> | Add 1 to the contents of the register (ACC or IX)
                    JMP           <address> | Jump tothe given address

                    CMP           <address> | Compare the contents of Acc with the contents of
                                                   <address>

                    CMP           #n              Compare the contents of Acc with the denary number
                                                  n


                    JPE           <address> | Following a compare instruction,
                                                                          jump to <address>
                                                  if the compare was True

                    JPN           <address> | Following a compare instruction,
                                                                          jump to <address>
                                                  if the compare was False

                    IN                             Key in a character and store its ASCII value in ACC

                    END                            Return control to the operating system
     <label>:      | <op   code> | <operand>       Labels an instruction


     <label>: | <data>                            Gives a symbolic address <label> to the memory
                                                   location with contents <data>


Key to the above table:
e        #denotes immediate addressing.
°e       <address> can be an absolute address or a symbolic address.

Write an assembly language program that outputs a sequence of characters stored in successive
locations, starting at the location labelled: stRING. Output ends when the character in ACC is ‘!’
(ASCII code 33).                                                                                          [8]

     Instruction                               Explanation

     Label           Opcode    | Operand

                                               Set index register
                                                                to zero

                                               Load ACC with character stored at STRING (modified by
                                               index register)

                                               Increment index register

                                               Output character

                                               Is this character the ! key?

                                               No - jump to beginning of loop

                                               End of program
     STRING:                             72 | String stored from here onwards

                                         69

                                         76

                                         80

                                         33
                                                                                    ~        “Siacthis

*                  "                         a              “3 6++)                                {
& &                                  ‘se                       a[b]                                             oS

                                                       as            pi                                              )


    Chapter 29:
    Declarative programming


 By the end of this chapter you should be able to:

    show understanding of and solve a problem by writing appropriate facts and rules based on supplied information

    show understanding of and write code that can satisfy a goal using facts and rules.




     PPR


    HAH
                                                                              Part 4: Chapter 29: Declarative programming




29.01 Declarative programming languages
Declarative languages include database query languages (such as SQL, see Chapter 11,
Section 11.07), regular expressions, logic programming and functional programming.

Prolog is a logic programming language widely used for artificial intelligence and expert
systems.

The Prolog programs in this chapter have been prepared using the SWI-Prolog environment
shown in Figure 29.01 (see www.swi-prolog.org for a free download).


    © SWI-Prolog (AMD64, Multi-threaded, version 6.6.6)

    File    Edit   Settings   Run   Debug   Help
    Welcome to SWI-Prolog (Multi-threaded, 64 bits, Version 6.6.6)                               a
    Copyright (c) 1990-2013 University of Amsterdam, VU Amsterdam
    SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
    and you are welcome to redistribute it under certain conditions.
    Please visit http://www.swi-prolog.org for details.

    For help.           use     ?- help(Topic).    or   ?- apropos({Word).

     1     ?-




Figure 29.01 SWI-Prolog environment




29.02 Prolog basics
There are three basic constructs in Prolog: facts, rules and queries.

The program logic is expressed using clauses (facts and rules). Problems are solved by
runninga query (goal).

A collection of clauses is called a ‘knowledge base’. Writing a Prolog program means writing a
knowledge base as a collection of clauses. We use the program by writing queries.

A clause is of the form:

         Head      :-   Body.

Note that a clause always terminates with a full stop (.)

Prolog has a single data type, called a ‘term’. A term can be:

e        anatom,a general-purpose name with no inherent meaning that always starts with a
         lower case letter

e        anumber, integer or float (real)

e        avariable, denoted by an identifier that starts with a capital letter or an underscore (_)
*        acompound term, a predicate, consisting of an atom and a number of arguments
         in parentheses ().

The arguments themselves can be compound terms. A predicate has an arity (that is, the
number
  of arguments in parentheses).

Prolog is case sensitive.
      Cambridge International AS & A Level Computer Science




      29.03 Facts in Prolog
      A clause without a body is a fact, for example:


       01       capitalCity(paris).
       02       capitalCity(berlin).
       03       capitalCity(cairo).



      The meaning of clause 01 is: Paris is a capital city.
      capitalCity(paris)                    iS acompound term. Both capitalcity and paris are atoms.
      capitalcity is called a predicate and paris is the argument.

      capitalcity has arity 1, as it has just one argument. This can be written as capitalCity/1,
      the /1 showing that it takes one argument.



         TASK 29.01

         Launch the editor (File, New ...) from the SWI-Prolog environment. Enter the three
         clauses, as shown in Figure 29.02. Then save the file (File, Save buffer) as Ex1.

                                                                                  =[0)x!
             File   Edit    Browse      Compile   Prolog    Pce   Help             4\a|
             Ex1.pl |
            capitalCity (paris).
            capitalCity (berlin).
            capitalCity (cairo) “.


500

            Buffer saved in file “Ex1_pl’                                        Line: 1



         Figure 29.02 Example facts in SWI-Prolog editor



      Clauses 01 to 03 are a knowledge base. We can run a query on this knowledge base.
      To ask the question whether Paris is a capital city, we write:
                                                           capitalCity(paris).

      Prolog answers true.
      This means: yes, Paris is a capital city.
      To ask the question whether London is a capital city, we write:
                                                       capitalcity(london).

      Prolog answers false.
      This means: no, London is not a capital city.
      This is because the fact that London is a capital city has not been included in our knowledge base.
                                                                                                       Part 4: Chapter 29: Declarative programming




       TASK 29.02

    Run your own queries. You first need to consult the knowled
                                                                ge base (File, Consult ...)
    from within the Prolog environment. Note that SWI-Pro
                                                           log uses the prompt ?- (see
       Figure 29.03).

        ©© SWI-Prolog (AMD64, Multi-threaded, version 6.6.6

        File    Edit    Settings   Run   Debug    Help
        Welcome to SWI-Prolag (Multi-threaded, 64 bits,
                                                         Version 6.6.6)                                           a
        Copyright (c) 1990-2013 University of Amsterda
                                                       m, VU Amsterdan
        SWI-Prolog comes with ABSOLUTELY No WARRANTY
                                                     . This is free software,
        and you are welcome to redistribute it under
                                                      certain conditions.
        Please visit http: //www.swi-prolog.org
                                                for details.

        For help,           use ?- help(Topic).             or ?- apropos (Word).

         1     ?-
        % c:/Users/Sylvia/My Programming’”CIE Book/Pro
                                                       log/’Ex1. pl                          compiled     0.00
        sec,        4   clauses
        1 ?- capitalCity(paris).
        true.

        2      ?- capitalCity(london).
        false.

        3      ?-




   Figure 29.03 Example queries in SWI-Prolog


   If your query does not get a response, check that you have:

   °         consulted your knowledge base (green text in Figure 29.03)

   e         used lower-case letters appropriately

   °         used a full stop at the end of your query.




29.04 Prolog variables
Let’s add some more facts to our knowledge base. Comments
                                                                                       in Prolog are enclosed in /* and */,


    04          cityInCountry(paris,                     france).   /*   Paris   is    a   city   in   France    */
   05          cityInCountry(berlin,                      germany).
   06          cityInCountry(cairo,                      egypt).
   07          cityInCountry(munich,                      germany).



To find out which country Berlin is in, we can run the query
                                                                                      (see Figure 29.04):
                                            cityInCountry (berlin,           Country).
Note that Country is a variable (it starts with a capital letter).

To find out which cities are in Germany, we can run the query
                                                                                        (see Figure 29.04):
                                                 cityInCountry(City,        germany).
      Cambridge International AS & A Level Computer Science




                                                                                                                                       =/0)x|
       File        Edit       Settings     Run    Debug        Help

        4 c:/Users/Sylvia/’My Programming’CIE                                            Book/Prolog’Ex1.pl                compiled   0.00   Z|
        sec,           8      clauses
        1 ?- cityInCountry(berlin, Country).
        Country = germany.

        2     ?- cityInCountry({City.                               germany).                                                                _|
        City           =      berlin ;
        City           =      munich.

        3     ?-
                                                                                                                                             =i

      Figure 29.04 Instantiations of a variable

      Note how Prolog responds when running a query that includes a variable. When there is more
      than one answer, you need to type a sernicolon after the first answer and Prolog will give the
      second answer. The semicolon has the meaning OR. First city is instantiated to berlin and
      then City is instantiated to munich.



        WORKED EXAMPLE 29.01


        Using a knowledge base

        Consider the following knowledge base:


                  01          vegetable(aubergine).                         /*   aubergine           is    a   vegetable     */
                  02          vegetable(potato).
502
                  03          vegetable(tomato).
                  04          meat(chicken).                   /*     chicken     is     a   type     of       meat   */
                  05          meat(beef).
                  06          meat(lamb).
                                                  SS




                  07          ingredient tagine,                       aubergine,            250).   /*    tagine      contains   250g   aubergine   */
                  08          ingredient tagine,
                                                  Se




                                                                       tomato,       100).
                  09          ingredient stew,
                                                  eS




                                                                    beef,    400).
                  10          ingredient stew,
                                                  Cs




                                                                    potato,      600).




        We can check the ingredients of a tagine by asking:

                     ingredient(tagine,                             Ingredient,        Amount).

        Look at the response Prolog gives in Figure 29.05.


            © SWI-Prolog (AMD64, Multi- ireagec
            File       Edit     Settings    Run        Debug    Help

              ?     ?- ingredientf{tagine,                            Ingredient,        Amount).                                            S|
              Ingredient = aubergine,
              Amount = 250 ;
              Ingredient = tomato,
              Amount = 100.

              8     ?-




        Figure 29.05 Instantiation of variables
                                                                                              Part 4: Chapter 29: Declarative programming




29.05 The anonymous variable
Consider the knowledge base from Worked Example 29.01. If we are not interested in
the amount of each ingredient, we can use the anonymous variable (represented by the
underscore character). The query then becomes

                                     ingredient(tagine,              Ingredient,        _).




29.06 Rules in Prolog
Remember a clause is of the form Head                    :- Body.

A rule’s body consists of calls to predicates, which are called the rule’s goals. A predicate is
either true orfalse, based on its terms. If the body of the rule is true, then the head of the rule
is true too.




  WORKED EXAMPLE 29.02


  Using rules in a knowledge base

  Consider the following knowledge base:


      01       parent(fred,           jack).       /*   Fred    is   the   father of      Jack   */
      02       parent(fred,           alia).
      03       parent(fred,           paul).
      04       parent(dave,               fred).




  We know that G is a grandparent of S, if Gis a parent of P and P is a parent of S.

  We could write this as a rule:
  grandparent(G,           S)        IF    parent(G,     P)    AND    parent(P,    S).

  However, in Prolog the 1F is replaced by :- and the anp_                       is replaced with a comma:


      grandparent(G,             S)        :-   parent(G,      P),   parent(P,    S).




  A person has a sibling (brother or sister) if they have the same parent. We can write this as the Prolog rule:


      sibling(A,      B)        :-
           parent(P,       A),
           parent(P,       B).




  If we run the query


      sibling(jack,         X).



  we get the answers we expect, but we also get the answer that Jack is his own sibling. To avoid this, we
  modify the query to ensure that A is not equal to B:


      sibling(A,      B)        :-
           parent(P,       A),
           parent(P,       B),
           not (A=B).
Cambridge International AS & A Level Computer Science




Question 29.01
What answer do you expect to get from Prolog to the following query?

sibling(dave,       X).




    TASK 29.03

    Write a knowledge base for your own family. You can include more predicates,
    for example:

        Predicate                               Meaning
        male (fred).                            Fred     is   male

        female(alia).                           Alia     is   female


    Write a rule for father.
    Test your program.




    WORKED EXAMPLE 29.03


    Adding arule to a knowledge base

    Using the knowledge base from Worked Example 29.01, we want to know which dishes contain meat. We are
    not interested how much meat, so we don’t need to know the value of the third argument ofthe predicate
    ingredient/3. We can write the rule:

    containsMeat(X)       :-
          ingredient(X,    Meat,   _),
          meat (Meat).

    The query containsMeat(X). returns
                                     xX = stew.




29.07 Instantiation and backtracking
Prolog responds to a query with an answer, such as the one in Worked Example 29.03:

X   =    stew.


The = sign is not an assignment as in imperative programs. The = sign shows instantiation.

How does Prolog use the knowledge base to arrive at the answers? One way to see exactly
what Prolog is doing is to use the graphical debugger.




    WORKED EXAMPLE 29.04

    Use the knowledge base from Worked Example 29.03. After consulting the knowledge base, start the
    debugger (Debug, Graphical debugger) from the Prolog environment. Then type: trace.      and then the goal
    as shown in Figure 29.06.


                                                                                                                 (Continued)
                                                                                                 Part 4: Chapter 29: Declarative programm
                                                                                                                                               ing




     ©° Swi Prolog (AMD64, Multi-threaded
                                          , version               6.6.6)
     File    Edit     Settings    Run    Debug    Help
     Welcome to SWI-Prolog (Mult
                                 i-threaded, 64 bits, Version
     Copyright (c) 1990-2013 Unive                             6.6.6)                                              4
                                   rsity of Ansterdan, VU Anmste
     SWI-Prolog comes with ABSOLUTELY                            rdan
                                       NO WARRANTY. This is free softw
     and you are welcome to redistribu                                 are,
                                        te it under certain conditions
     Please visit http: //www.swi-                                     .
                                   prolog.org for details.

     For help.              use ?- help(Topic).             or ?- apropos (Word).

     1      ?-
     % c:/Users/Sylvia/My Progr
                                amming’CIE Book/Prolog’Ex3.pl
     sec,        12    clauses
                                                                                                 compiled   0.00
     “% The graphical                   front-end will       be used       for subsequent      tracing
     1 ?- trace.
     true.

     [trace]           1    ?- containsMeat(X).




  Figure 29.06 Switching on the trace facilit
                                                                  y


 The graphical debugger window opens as
                                                                      shown in Figure 29.07,

      c:/users/sylvia/my programming/ci
                                                   e book/prolog/ex3.pl

   Tool      Edit          View   Compile        Help

  Bindings




         vegetable (aubergine)                      .
                                                                                                   I>



         vegetable (potato).
         vegetable (tomato) .
         meat (chicken).                  /*     chicken     is   a     type   of meat   */
         meat (beef).
         meat (lamb).
         ingredient (tagine, aubergine,
                                        250).
         ingredient (tagine, tomato, 100).
         ingredient (stew, beef, 400).
         ingredient (stew, potato,                         600).
  a] containeM
             (x)
               eat
                 :~
                            ingredien   (X,
                                          t Meat,              _),
                            meat (Meat) ..
                                                                                                   «|




 L

Figure 29.07 Graphical debugger



Using the space bar you can step through
                                         the program. When Prolog gives an answe
                                                                                     r in the Prolog Environment
window, remember to input a semicolon,
                                         so that Prolog will go and check for anoth
                                                                                    er possible answer.


If you don’t use the graphical debugger but type
                                                                           trace. youcansee the trace in the SWI-Prolog
                                                                                                                        window, as
shown in Figure 29.08.



                                                                                                                                     (Continued)
Cambridge International AS & A Level Computer Science




                                                     ia   /My F                                         -/o)x|
      File       Edit   Settings       Run   Debug        Help

      1 ?-                                                                                                    Z|
      % c:/Users/Sylvia/My                           Programming’CIE   Book/Prolog’Ex3.pl   compiled   0.00
      sec, 1 clauses
      1 ?- trace.
      true.

       [trace]            1       ?- containsMeat
                                              (XZ).
                 Call:        (6)      containsMeat(_G464) ? creep
                 Call:        (7)      ingredient (_G464, _G536, _G537) ? creep                               il
                 Exit:        (7)      ingredient(tagine, aubergine, 250) ? creep
                 Call:        (7)      meat(aubergine) ? creep
                 Fail:        (7)      meat(aubergine) ? creep
                 Redo:        (7)      ingredient(_G464, _G536, _G537) ? creep
                 Exit:        (7)      ingredient(tagine, tomato, 100) ? creep
                 Call:        (7)      meat(tomato) ? creep
                 Fail:        (7)      meat({tomato) ? creep
                 Redo:        (7)      ingredient(_G464, _G536, _G537) ? creep
                 Exit:        (7)      ingredient(stew, beef, 400) ? creep
                 Call:        (7)      meat(beef) ? creep
                 Exit:        (7)      meat(beef} ? creep
                 Exit:        (6)      containsMeat(stew) ? creep
      X      =    stew        ;
         Redo:                (7)      ingredient(_G464, _G536, _G537) ? creep
         Exit:                (7)      ingredient(stew, potato, 600) ? creep
         Call:                (7)      meat{potato) ? creep
         Fail:                (7)      meat({potato) ? creep
         Fail:                (6)      containsMeat(_G464) ? creep
      false.

       [trace]            2       ?-

                                                                                                              d|

   Figure 29.08 SWI-Prolog trace of goal containsMeat
                                                   (X)


  The following terminology is used when discussing a trace:

  *          Call is the initial entry to a predicate

  ¢          creep indicates that Prolog is moving to the next predicate

  e          Exit is a successful return

  e          Redo indicates that the predicate is backed into for another answer

  e          Fail indicates that Prolog can find no more solutions.




29.08 Recursion
Recursion for imperative languages is covered in Chapter 24. Recursion for declarative
languages is where a rule is defined by itself, or more precisely, a rule uses itself as a sub-goal.

Let us expand the Family knowledge base from Worked Example 29.02.

We want a rule that defines whether person Ais an ancestor of person B. If Ais a parent of B,
then Ais an ancestor of B. Similarly, if person Ais the parent of P, who is the parent of B, then
Ais an ancestor of B. This is true for the parent ofa parent ofa parent of B. In general, ifAisa
parent ofX and X is an ancestor of B, then Ais an ancestor of B. We can write this information
as the rules shown in Figure 29.09.


                                                                   = The base case }
  ancestor(A,                           B)     :-         parent(A,    B).

  ancestor(A,                           B)     :- parent(A, X),
                                                                ancestor (X, B). —_ The general case }

Figure 29.09 Recursive rules
                                                                                                   Part 4: Chapter 29: Declarative programming




Note that recursion in declarative programming must follow the equivalent rules that
imperative programming must follow. A recursive rule must:

e    havea base case

e    havea general case

e    reach the base case after a finite number of calls to itself.



    TASK 29.04

    Add the ancestor rules to the Family knowledge base and check that the following
    query gives the correct results:
    ancestor(A,          jack).




    WORKED EXAMPLE 29.05


    Creating the factorial function in Prolog

    In Chapter 24, Worked Example 24.01, we programmed the factorial function using recursion with imperative
    programming. We can also program this function using recursion in Prolog.


     factorial(0,         1).                             /*   base    case:      0!      =   1      */
     factorial(N,         Result)       :-                /*   Result    =   N!                      */
         Mis     N   -    1,                              /*   assign N-1         to M               */
         factorial(M,           PartResult),              /*   PartResult             =    (N-1)!    #*/
         Result      is    PartResult        *   N.       /*   Result    =   N    *       (N-1)!     */




    TASK 29.05

    Enter the code from Worked Example 29.05 into the Prolog editor. Save it and
    consult it. Then pose the following query:
    factorial(5,         Answer).

    Do you get the correct answer?




29.09 Lists
A listis an ordered collection of terms. It is denoted by square brackets with the terms
separated by commas or in the case ofthe empty list, []. For example [1, 2, 3] or [red, green,
blue]. An element can be any type of Prolog object. Different types can be mixed within one
list. Lists are used in Prolog where arrays may be used in procedural languages.

Any non-empty list can be thought of as consisting of two parts: the head and the tail. The
head is the first item in the list; the tail is the list that remains when we take the first element
away. This means that the tail of a list is always a list.

Lists are manipulated by separating the head from the tail. The separator used is a vertical
line (a bar):|

If Prolog tries to match [H|T] to [car,               lorry,   boat,    ship],
                                                                             it willinstantiateu
                                                                                              to car and
Tto [lorry,      boat,         ship].
                                                                                                                                                      |
The clause definition showHeadAndTail({H Tl,                                                                             H,     T).   can be used to pase
                                                                                                                                                      the query:

showHeadAndTalil({fred,                                               jack,              emma],                   Head,         Tail).

Prolog responds with:

Head             =        fred,
Tail             =        fjack,            emma].




myList (HIT).

Prolag responds with:

H     =
            a




T     =      [2,          3).

The clause definition emptyList(A}                                                               :- A =                []. can be used    to pose the query:
                                                                                                                                                      1   4




                                      AY
                                       ‘




Prolog responds with:

false.



4                                     *                   =
Somat
% Ne  Pe ot eRe
             ahaty ot he               Say ete SSS
                                               ata atc
                                                     RS tdSSgov oRoy
                                                                   at             Neen       .
RUSE             SP       CREE                     MYO GCEES                                          perc

                                                                      a

append(ia,                       bj],           fc,      dj,         MyList).


produces MyList =                                        fa,    b,         ¢,     a].

append(FirstList,                                         [c,       da],        fa,      b,              c,       dd).


produces FirstList =                                                [a,    bl].




produces:

crue,




member(X,fa,                           b,        oc,      al).


produces:

A=          @         ,



A                     i
            QQ
      H

            or 1
a

      i




2?                                    *                        Pe                                                  s
Ry    we         LT        KK    SE               nang    th        eR ey                                    ay
8    RSET    SRP SWS        SH        SERS       PYERR SN ES          Se                 ~       34          LEVSS         <i
LESto SP OSH
           Gk ESP
             :
                                                          SL Sse
                                                               ss wi                             ile says
                                            :




write('megssage:                                 '), Outputs message:

write(X}.                       outputs the value currently instantiated with the variable x.

The built-in predicate read(a)                                                  reads a vaiue from the keyboard into variable A,

read(Name).                       waits for an atom to be input from the keyboard and instantiates the variabl                                                     cy
                                                                                                                                                                   No




Name with that vaiue,
                                                                                   Part 4: Chapter 29: Declarative programming




Note that the input must start with a lower case letter and not have spaces or be enclosed
in quotes.

nl moves the output to a new line.

We can write user-friendly programs using the read and write predicates.



  WORKED EXAMPLE 29.06


  Using the read and write predicates

  Note how the interface with the user in the code below is written as a rule with the separate steps separated
  by commas (representing AND).


  assert/1 adds the clause given as the argument to the knowledge base.

  retractall1/1 takes the given clause out of the knowledge base, so the next time the
  program is run, the new facts will be added and used in the goal.


      /* Weather knowledge base */
      weather (good) :-
             temp(high),
             humidity(dry),
             sky(sunny).
      weather (bad) :-
             (humidity (wet);
             temp (low);
             sky (cloudy)).

      /*     interface     */
      go:-

             write('Is     the    temperature high or                 low?   '),
             read(Temp),        nl,
             write('Is     the    sky   sunny or            cloudy?    '),
             read(Sky),     nl,

             write('Is     the    humidity dry or wet?                 '),
             read(Humidity),          nl,
             assert (temp(Temp)),
             assert(sky(Sky)),
             assert (humidity (Humidity)),
             weather (Weather),
             write('The weather              is    '),    write(Weather),
             retractall(temp(_) ),
             retractall(sky(_)              ),
             retractall(humidity( ) ).



  To run the program, type go.




  TASK 29.06

  Test the recursively defined rule writelist/1 to output the elements of a list.
  writeList([]).
  writeList([H|T]):-write(H),                    nl,     writeList(T).




Reflection Point:
Can you explain the difference between a fact and a rule?
Cambridge International AS & A Level Computer Science




  Summary
                                                                                      Part 4: Chapter 29: Declarative programming




Exam-style Questions

1 A logic programming language is used to represent, as a set of facts and rules, details of
    cities of the world. The set of facts and rules are shown below in clauses labelled 1 to 17.
    01       capital(vienna).
    02       capital(london).
    03       capital(santiago).
    04       capital(caracas).
    05       capital(tokyo).
    06       cityIn(vienna,          austria).
    07       cityIn(santiago,           chile).
    08       cityIn(salzburg,           austria).
    09       cityIn(maracaibo,            venezuela).
    10       continent(austria,             europe).
    11       continent(chile,            southAmerica).
    12       continent(uk,          europe).
    13.      continent(argentina,               southAmerica).
    14       iVisited(vienna).
    15       iVisited(tokyo).
    16       capitaloOf(City,         Country)
                  IF    capital(City)      AND    cityIn(City,      Country).
    17       europeanCity (City)
                   IF    cityIn(City,      Country)     AND      continent(Country,   europe).

    These clauses have the following meanings:

        Clause         | Meaning

        01              Vienna is a capital.

        06              Vienna is in Austria.

        10              Austria is in the continent of Europe.

        14              | visited the city of Vienna.

        16              City is the capital of Count ry if
                        City isa capital and itis in Country.

        17              City isacityin Europe if City isin Country and Country is in Europe.

    a___     Write down the extra clauses needed to express the following facts:

             i         London isin the UK.
                                                                                                                 rm


                                                                                                                       ——
                                                                                                                   —_—
                                                                                                                 —_|




             ii        | visited the city of Strasbourg.

    b        Theclause cityIn(City,             austria) would return the result: vienna,   salzburg.

             Write down the result returned by the clause:
             continent(Country,                southAmerica).                                                     [2|

    ¢        Complete the rule to list countries that | have visited
             countriesIVisited(Country)                 IF   ...                                                 [3]

2   Inaparticular country, to become a qualified driver you must:

    e        havea       licence: there is a minimum age at which a person can be issued
             with a licence and it is different for cars and trucks

    e        passa theory test: it is the same test for cars and trucks

    e        passa       driving test for a specific vehicle (car or truck).
Cambridge International AS & A Level Computer Science




  A declarative programming language is to be used to represent the knowledge base shown below:
  01       minimumAge(car,                  18).
  02       minimumAge(truck,                      21).
  03       age(fred,        19).
  04       age(jack,        22).
  05       age(mike,        17).
  06       age(jhon,        20).
  07       age(emma,        22)
  08       age(sheena,          1 9).
  09       hasLicence(fred).
                                       ie




  10       hasLicence(jack).
  11       hasLicence(mike).
  12       hasLicence(jhon).
                      (
                                       SS




  13.      hasLicence(emma).
                      (
  14       hasLicence(sheena).
  15       allowedToDrive(X,                     V)
                 IF   hasLicence(X)                    AND   minimumAge(V,      L)
                      AND    age(X,              A)
                      AND   A     >=        L.

  16       passedTheoryTest (jack).
  17       passedTheoryTest (emma).
  18       passedTheoryTest(jhon).
  19       passedTheoryTest (fred).
  20       passedDrivingTest(jhon,                           car).
  21       passedDrivingTest(fred,                           car).
  22       passedDrivingTest(jack,                           car).
  23       passedDrivingTest(jack,                           truck).
  24       passedDrivingTest(sheena,                              car).
  25       gualifiedDriver(X,                         V)
                 IF   allowedToDrive(X,                      V)
                      AND   passedTheoryTest
                                          (X)
                      AND   passedDrivingTest(X,                          V).

  These clauses have the following meanings:

      Clause           Meaning

   01                  The minimum age for
                                         a car licence is 18.

   03                  Fred is aged 19.

   09                  Fred has a licence.

      15               Person X is able to drive vehicle v if person X has a licence and the age A of person X is
                       greater than or equal to the minimum age L to drive vehicle v.
                                                                                                                          |




  a        i     Giveone example of a fact in this knowledge base.
                                                                                                                    rm


                                                                                                                         a
                                                                                                                     a




           ii    Give one example of a rule in this knowledge base.
                                                                                                                    —_




  b        State the output produced from these clauses:
           i     passedDrivingTest(Who,                            truck).
                                                                                                                    me

                                                                                                                      EE
                                                                                                                         ss
                                                                                                                     -e




           li    allowedToDrive(mike,                         car).
                                                                                                                    m—

                                                                                                                     Fe
                                                                                                                    —_




           lii   NOT(hasLicence(sheena)).

  ¢        Write aclause to output:

           i     all qualified car drivers
                                                                                                                    Ww N




           ii    all drivers who have passed the theory test but not a driving test.

  d        =To produce the output from a clause, the inference engine uses a process
           called backtracking.

           Consider
                 the clause:
                                                  AllowedToDrive(mike,          car).

           identify the order in which clauses are used to produce the output. For each clause, describe
           the result that it returns.
Glossary

Abstract class a base class that is never used to create      Asymmetric key encryption there is a public key and a
objects directly                                              private key one of which is used for encryption and the
                                                              other for decryption
Abstract Data Type a collection of data with associated
operations                                                    Attribute a column in a relation that contains values

Acceptance testing testing of software by customers           Attributes the data items of a class (also sometimes
before sign-off                                               referred to as fields)

Accumulator a general-purpose register that stores a          Authentication verification of a user’s identity
value before and aft er the execution of an instruction by
                                                              Authorisation definition of a user’s access rights to system
the ALU
                                                              components

Actuator a hardware device that receives a signal from a
                                                              Back propagation of errors An algorithm for machine
computer and adjusts the setting of a controlling device
                                                              learning that optimises the values for parameters which
Adaptive maintenance amending a program to enhance            are adjustable. It is applied first to the nodes in the output
functionality or in response to specification changes         layer and then works backward through the nodes in
                                                              hidden layers until finally the input nodes are considered.
Address bus a component that carries an address. This
can be to the memory controller
                             to identify a location in        Bandwidth a measure of the amount ofdata that can be
memory which is to be read from or written to or it can be    transmitted per second
to the |/O system to identify the source or destination of
                                                              Base case an explicit solution to a recursive function
the data
                                                              Beta testing testing of software by a limited number of
Addressing mode when the instruction uses a value this
                                                              chosen users before general release
defines how the operand must be used to find the value
                                                              Binary coded decimal (BCD) storage of a binary value
Algorithm a sequence of defined steps that can be carried
                                                              representing one denary digit in a nibble
out to perform a task
                                                              Binary file a file designed for storing data to be used by a
Alpha testing testing of software in-house by dedicated
                                                              computer program
testers
                                                              Binary prefix examples are kibi, mebi, gibi and tebi
Analogue data data obtained by measurement of a
                                                              representing factors of 21°, 27°, 2°° and 2°° respectively to
physical property which can have any value from a
                                                              define the magnitude of a value
continuous range ofvalues
                                                              Binary search repeated checking of the middle item in an
Argument the actual input expression or value with which
                                                              ordered search list and discarding
                                                                                              the half of the list which
the subroutine is being called
                                                              does not contain the search item
Arithmetic shift uses the shift to carry out multiplication
                                                              Bit depth the number of bits used to represent each of the
or division ofa signed integer stored in the accumulator
                                                              red, green and blue colours
Array index row or column number of an individual array
                                                              Bit rate the number of bits transmitted per second
element
                                                              Bit a digit in the binary number system written using either
Assembler a program used to translate an assembly
                                                              of the symbols 0 and 1
language program into machine code
                                                              Black-box testing comparing expected results with actual
Assembly language a low-level language related to
                                                              results when a program is run
machine code where opcodes are written as mnemonics
and there is a character representation for an operand        Bridge a device that connects two segments of a LAN
  mole sart a sort method whyere             adjacent pairs of values
                                                                                                          a         ne        es   os   f   ae,   nae




are compared anc swapped

                                                                        Data Brvacy 2 requirement for data to beavailable only to



                                                                        (ala protectivnlaw a law that relates to cata privacy




                                                                        Dnata securitydata thatwere stored mustbe avaliable
                                                                        unchanged when neeced which reauires that only
                                                                        authorised users have had access and that cata can be
iy value the actual value is passed into the procedure                  recovered if lost or corrupted

    2 a proup of eight bits treated as a single unit
                                                                        Ps   ta    ba         Sone
                                                                                                eb agey Tye dard arey   Baa   ge   FAR      A            a
                                                                        Dateoave Behririsirator (PRAl a Derson wd USes
   aoe




                                                                        the DBMS tocu stomisse the databaseto suituser and
Caiie a transmission using copper wire orfibre-optic

Candidate
        a RY a key that could be chosen as the
                                                                                                                                                              called



consnductive ayer thaattindergoOBS 5a chan,weEnvelectTical              representing fact ors
                                                                                                                 miples are kilo, mega, Besa and tera
                                                                                            of 10°, 10°, 10? and 10" espectively to
statewhen a finger touches the screen
                                                                        definet                                 de of a vaiue.

                                                                                  uy igarring where a system uses an artificial neural
                                                                        network with an exceptionally large number of hidden
Class a type tha tcombines a data structure with the
 nethoads
                 that operate on the data structure
                                                                                  ary funioers which are also Known as cecimal
Client-server anarchitecture where a client runs an                     numbersSs are written using one ofthe symbols
application provided by a server on a network                           0,1,2,3,4,5,6,7,8,9 for each denary digit
         noe
     Ba
   anes es


                                                                                  siseher             i         “2 fives access to software toals
dependent only ontthe input:values
   Sent
  ESRI
     EE TS



                                                                        provided
                                                                              by a DBMS for creating tables

                                                                            Hgital data cata that has been stored as a binary value
 istruction can be more                                                 which can have one of a discrete range of values
of data from memory
CPA SSPSEP
     STP,         asnec
           Liar a specia [fsVp eof method thatis called to
S be
QO ran




                new object anc initialiseits attributes
                                                                        state has been reacheszewhere loading one page causes a
     o
     0




   NUaHNTeNnt a re atfonen wnicn one class                 has ¢        reed for another page tobe loaded almost immeciately
                                                                        Bu ttheleacing o i this new pape causes the same

                              fopnition of wnership of a created

                                                                             BYPaif:            PHS       =                   (ONS!
                                                                                                                                a hierarchical cistribute

                           nance correcting identified errors           database installed on domain name servers that is
                                                                        esponsinls for mapping a domain name to an |P address
wyeke 8!
      ghuttsimilar to a logical shift but bits shift ed from
                                                                                                                                            of values for each drawing
               c reappear at the other end

  ais bus a component that can carry data from the
processor to the memory or to an output cevice or can                   Drawinglst contains one
                                                                                        pee
                                                                                              set of values for each drawing

carry‘data fromthe memory or from an input device
                                                                        Urawing abject a component definedi by peametric
                                                                        "          oe oy          s

               ‘heerify @ requirement for data to be accurate anc
                                                                        formulae and associated properties
                                                                                                                                       ae
                           re                                    oO


formulae and associated properties                                                of two individual bits




                                                                                  some of them have different topologies or supporting



nrHimeratad deta tyge anon-composite user-defined
are        ane       we   met   what.   ye               7   1        7   ;   ]


                                                                                                       ution, with explanations and data types
cata type for which                     the definition identifies all possible




                                                                                  defined as the product of the width and the height values
which identities the file and contains information about the
coding used
                                           ees
                                                                                  which contains one attribute from the table being
                                                                                  searched and pointers to the tupies in that table
fixed set of possible states with a set of inputs that change
                                                                                  inferitance all attributes and methods of the base class
                                                                                  are copied   to the subclass
           eyarail hardware or software that monitors and controls
network traffic
                                                                                         into one program    and tested to ensure the modules
                                                                                  interact correctly
numbers that stores a value for the mantissa and a value
for the exponent




rareier key an attribute in one table that refers to the
primary key in another table
                                                                                  fora required value

limit for its use but no source code provided
                                                                                  emitting diodes and with   liquid crystal cells sandwiched
                                                                                  between polarisers
when the user is free to use it as they wish

      fh     adidier circuit a circuit which performs binary addition
of two incividual bits and an input carry bit




re               >




                                                                                  if not to behave as intended
returns a single valve; function call is part of an expression


                                                                                  Boolean operators, which may be equated to a defined
                                                                                  outcome
clatter a method to access its associated attribute
                                                                                  Lage gate a component of a logic circuit that has an
                                                                                  operation matcning that of a Boolean operator
        x                         skiff wnrere bits in the accumulator are shit ed to                                       Cicada defines the action associated with the instruction
the ghtor to the ieft and a zero moves into the bit position
vacated
                  an




subsequent decodingto recreate €cwactly the orvipinal ile
            wD


                       om

                                 ire


                                             7
                                                 eal


                                                        ral

                                                               oe


                                                                         vhs
                                                   wt




                                                                    st
             ut
        a




                            ue




                                            -




                                                              Ae
                                       a
    F




                                       $




                                                                                   (on)


                                                                                                                                               :                      ;              a sottware platform that provides
        easy compression coding techniques that cause some
informationte be iclost
                     so that the exact original file cannot                                                                 fa cilities for pregrams to be run which are of benefit toa
                                                                                                                            user
be recovered in subsequent decoding
                                                                                                                            CverHow a condition when the result of a caiculation is too
                                                                                   r makes decisions ab out which prOCess
t                      te




stored in memory should have access te the CPU                                                                              large to fit into the number of bits defined for storage

                                                                                                                                                              ciwhertwo BCD nibbies are stored in one byte
                                                                                                                                                                                           BC




                                                                                      ailest number index of an array
                                                                                                                            Paging where 2 large process is civided inte pa al es which
                                                                                                                            have to be the same size
                                                                                                                                                                                                                         Oo




number of bits that comprises an opcode and, rnLost often,                                                                  Maranieter a value passed between modules
one operand
                                                                                                                                                    eter the variable(s) used inside a subroutine which

                            ig igarning where a system improvesits                                                          will rake values passed into a subroutine at call tirne
performance e throtign anatysis of previousperformance                                                                      Sar           a             st     MODY        My   ay
                                                                                                                            Meriactive maintenarice modifying a program to improve
                                                                                                                                                                                     Be   caret   :    ee     pes   ey    -    les   pe   pe



                                                                                                                                      -



                                                                                                                            performance or Meintanap ny
causing harm to a system                                                                  or its contents

Mash tomelowy contains direct links between devices


                                                                                                                                                                                       for which the value is the address in

MERE Multiple instruction Strearn Multiple Data stream;
    nultiole processors asynchronously processing paraliel
Sata input
                                                                                                                                                                                                      address ofthe nodeit


            (Sf Multiple instruction Stream Single Data stream; does
                                                                                                                              oroithe method behaves differently                                                              for different
not exist in a single architecture
                                                                                                                                                               the hierarchy

                                                                                                                                                             keyanattribute or a combination of                          attributes for
                                                                                                                                                                                       in each tuple and that valueis unique

Nestedigenloop containing anotherloop
                                                                                                                                                                      « owned by and only accessed by an
                                                                                                                                                             ayer
                                                                                                                                                                          whe
                                                                                                                                              woe
                                                                                                                                                    "




                                                                                                                                                                    fee
                                                                                                                                          3




                                                                                                                            combination“of two o¢r more logic propositions
                                                                                                                            Prececire ase
                                                                                                                                        aerice of steps that is given an identifier
Norm compastio dats tyoe qa cata type defined without
                                                                                                                            and can be called to perform a sub-task
reference toanother data type




weinersarewhen the bit stream content is transmitted at
                                                 en by the user
                                                                                                                            Pracess a orogram that has peeve execution
                                                                                                                            Neat
                                                                                                                               es
                                                                                                                                  :




One'scormmlernent the binary number obtained by
subtracting eachdigit ina binary number frorn1
                                           fan                                 3
                                                                                                                            programming
                                                                                                                                                                ..

                                      i class member that includes the attribute                               ation the special type of table which   is usedina
                                                  randsetter method calls to access/set the              -elationat database
                                                                                                         Homeater a device that connects two
                                                                                                                                           c ables and provides a
                            ¥defines one aspect of the appearance of the                                 full-strenpth signal to the second cable
         awiving, object
     a




                                                                                                         Heneating group a set of attriputes that have        more than
Praoerty defines one aspect
                         of the appearanceof the                                                         one set o}Cyalues when theother attributes each have a
drawingobject

                  eeaia                   set of rules for datat                missionwhich are                                     a flexible surface that caus
                                 sender and receiver                                                                              trical resistive layers heneath‘when
Peaudocace a way of using keywords and identifiers to
cescribe an algorithm without following the syntax of a
particular programming language

    Sublic cloud owned by a cloud service providerfor general                                                                         cto terminate a sequence of
                                             S




                                          eeesor softwere tools provided bya DBMS to                                         that acts as a node on the internet
     ‘low creation andexecution ofa query
              —




                                                                                                                                 e define the order ofthe calculations to
                                 ec to select data from
                                                      a database subject to
          oh
                  ae
                        om




                                                                                                                  Hiri array an error that causes program execution to
                       mi fie a file that stores records at specific addresses                           crash or freeze
thatcan be accessed directly


                                                                                                                                                                            oO
                                                                                                         Sarmigiing
                                                                                                                  rate the       number of samples taken per second
:                 fon                             ee                        : volatile memory that can
                                                                                                                       vesobution the    numberof bits used to store each
be read from orwritten
                     to anynumber
                         yt       of tir

Read-only memory   (2OM   non-volatile memory that
    OR      x a Le  _ 7 %  ~~         -




cannot be written to but can be readfrorn any number of


                                                                                                         Sereen resolution the product ofwidth anc height values
                                                                                                         ror the number of pixeis that
                                                                                                                                     the screencan display

                                                                                                              ecoriiary
                                                                                                                      Key a candidatekeythathas not been chasen
ecard a collection offelds containing data values
                                                                                                         as the primary key
receding variable vaiues in a trace table
                                                                                                         Sogrientation where a large process is divided into
Hacursive routine a function or procedure definedin terms                                                segments for loading into memory but the segments are
                                                                                                         not constrained te be the same size

                                                                                                         Serisor a hardware devicethal measures a property anc
instruction is simpler, requiring sinienaltoading ofof‘data                                              transmits a value to a controlling computer
from memory
                                                                                                             eciential circa? a circuit in which the output depends on
                                          integritythe use of 2 foreign key to ensure that               the input valiues and the previous output
a value can
          veebe entered in one table when the same
                                                                                                                                oviding a service to end-systems
                                                              ; in the referenced table
Qo




                                          a
                                                  xX,
                                                         pa
          o
                   QS
                        Ss
                             G
                                 08)



                                             0
                                                    is
<=




                                                                                                         Set a collection of data items that lacks any structure;
    lggYession analysis finding a mathematical function
                                                                                                         contains no duplicates and has a number of defined
that provides the best fite the actual outcomes when
                                                   alculated from piprevious inputs                      operations
                                                                                                                  that can be performed on it
         ad
2
           fon)
                  OQ
                   3
                           a)
                                oa)
                                      ran)
                                             =
                                             a)
                                                  -)
                                                  a)




                                                                                                         Setter a method to set the value
                                                                                                                                        cf its associated attribute
                                                                  ne where an agent learns by
                       ng graded revwards fo ractions taken                                                   unranware soitware providedfree of charge for a limited
                                                                                                         fe
                  =
a
     i@)
          i.)


                       a
                         GQ
                                 ag




                                                                                                         Po
                                                                                                         2




                                                                                                         period    but mo source code provided
                                                                                                                                                                       ane
SR18 Single instruction StreamMultipie Data stream;                                                                                                i hreact part ofa program which is handled as an individual
processing of paraliel data                                                                       input requiring one control unit            pracess when being executed
instructing multiple processing units                                                                                                        Togeloey the contiguration of a network that defines how
                          Singte Instruction Stream
                                                  S ingle Data stream; a single                                                              the various devices on the network are connected
DFOCeSSOF accessing one memory
                                                                                                                                                   PAGE talteag table witha column                                         foreachvariable that
                                                 eigawyeach end-system ts linked
                                                                               to a central device

                                                                                                        stores the addressofthefirst                                                                    storing data for one instance of the



                                                                                                                                                                     mplerent                      the one’s complement of
                                                                                                                                                                                                                         a binary


                    oe         Dare
                                  w we Toney                                    day tewie   +   ta hI    tt
                                                                                                              that gives infor nationabout                      yh                     ISSR Swi Vere2 the machine learning
                                                                                                                                                                                       :




                               PP aYisitign tanie                                           a    teole
                                                                                                                                                                                       Ia     ee   ay




                                                                                                                                             takes place entsively |throtugh the system analysing
                                                                                                                                                                                               and
                                                                                                                                             categorising the avaiiabie data

               lines olution i nto smaller andsmaller Steps                                                                                          eet       Beene              a   fh       teva
                                                                                                                                                   ingar boned tne highest number index of an array
                                                                                                                                                                                                      ned rms              ;              ey




                                                          chart
                                                            a graphical representationof the modular
                                                                  a solution                                                                                                          cata tyme where the programmer incluce
                                                                                                                                             the definition in the program
                                                                                        statements usedto describe :an                       Yaelicetion a check that data entered is of the correct type
                                                                                                                                             and format; it does not guarantee that datais accurate

                                                                                                                                                   ‘srigisie a storage location for a data value that has an



 a                                                                    surfing where sample datais cupolied to the                            NF    ee
                                                                                                                                             Warrier
                                                                                                                                              MRPRRASS
                                                                                                                                                      5         a
                                                                                                                                                               ormr
                                                                                                                                                               ROP
                                                                                                                                                                    ae,
                                                                                                                                                                   GRR SES        hc @ graphic consisting of                         drawing objects
system with associated data relating te the outcome of its                                                                                   defined in a drawing list

                                                                                                                                                          P            SPAR                sraphic consisting of drawing objects
Sagiter a connecting devicethat can send a unicast                                                                                           defined in a drawing list
                                                                                                                                                              ation confirmationof data received by a system
Ssyrrieel fable a cata structure in which each record
                                                                                                                                              WEPSUSt iiviary d —D agi Ne mechanism that allows 4
                                                                                                                                             WFR    tee
                                                                                                                                                   fhetioat
                                                                                                                                                           &     -
                                                                                                                                                               peer
                                                                                                                                                                              -



contains the name and attributes of an identifier
                                                                                                                                              program to use more                                     memory addresses than are available
                              reiri key anecryptionone private key is held by both                                                            in main memory
                                                                               iver andiis used for both encryption anc
ra
      a
           3
                   CQ
                   a
                              —TM




                                                a
                                                      CQ
                                                                 *

                                                                     a
                                                                       (any
                                                                           D
                                                                               <




Syntax erraran error in which
                            a progranvi staternent does
notfollowthe rules of the languag
                                                                                                                                             computers                                             nt sites,"possibly thousands ‘of
                                                                                                              s of activity outside the       kilometres apart
processor
                                                                                                                                                                s&ecess Point (WAP! the connecting device ina
                                                                                                   2 emulation of computer
                                                                                                                                             Batseba
                                                                                                                                              WIPES GOS 3 INGAAS,
                                                                                                                                                              ee Abo              bware ely   Tendo
                                                                                                                                                                     PPPS
                                                                                                                                                                                                        d
                                                                                                                                                                          PRS
                                                                                                                                                                                                            ae
                                                                                                                                                                               ALP
                                                                                                                                                                                                                 ot   at
                                                                                                                                                                                    Lae HC}
                                                                                                                                                                                                                               PhAST EE
                                                                                                                                                                                            rrovides
                                                                                                                                                                                                                                                 +
                                                                                                                                             Qrgrsles      os mee he  aS   baa  TRS     wae    fi  1c
                                                                                                                                                                                                                                                     the
                         dats carefullychosen vaiuesthat will test a program                                                                 furniction ina WIFI LAN

                                                                              ctlent thatcarries out at least some of the
                                               aoe




                                                                                                                                                     reiess          a transmission usingradia, microwave or infrared
ood




                    ao




                                                                 ie
      ae




                                        penn
       neal


                   a4




                                                     Pe
                                                      ‘cr
                                                            oa




                                                                      a3
              mn




                         a”


                                    3




                                                                                                                                             Ward a smali number of bytes that can be hancled as a unit
                              ‘Hert a client that only provices inputand receives                                                             by the cornputer system
output from the apolicatior
Taret=).4

A algorithm, 400-403                           Application-layer protocols, 335-336             Bandwidth, 32
Absolute addressing, 493                          email protocols, 335-336                      Base case, 435
   assembly language program using, 95            FTP (File Transfer Protocol), 336             Base class/superclass, 468
Abstract class, 470                               HTTP (HyperText Transfer                         declaring
Abstract Data Type (ADT), 227, 415                     Protocol), 335                                     in Java, 474-476
Abstraction, computational thinking, 179       Arguments, 267                                             in Python, 471-472
Acceptance testing, 304                        Arithmetic Logic Unit (ALU), 82                            in VB.NET, 473-474
Accumulator, 82                                Arithmetic operations, 100-101, 103-104          Base-2 number system. See Binary numbers
Actuator, 113                                  Arithmetic operators, 245-246                    Base-10 number system. See Denary
Adaptive maintenance, 307                      Arithmetic shifts, 102                                    numbers
Addition, of binary numbers, 11, 12            Array index, 212                                 Base-16 number system. See Hexadecimal
Address bus, 83, 84, 85                        Arrays, 212                                               numbers
Addressing mode, 97-98                             one-dimensional, 212-218, 276-277            Basic input/output system (BIOS), 368
Adjacency list, 426                                two-dimensional, 218-225                     Beta testing, 304
Adjacency matrix, 425                          Artificial intelligence (Al), 153-155, 397-408   Big O notation, 429-431
ADT. See Abstract Data Type (ADT)                  defined, 398                                 Binary coded decimal (BCD), 13-14
Advanced Encryption Standard (AES), 391           impact of, 154-155                               packed, 13, 14
Al. See Artificial intelligence (Al)              machine learning. See Machine learning        Binary file, 317
Algorithms, 180-182, 411-431                      neural networks, 406-408                      Binary numbers, 3-4
    A’, 400-403                                   overview, 398                                    addition, 11, 12
    Abstract Data Types, 415                       usage of graphs in, 398-403                     conversion to denary number, 5
   assignments, 184-187                        Artificial neural network, 406-408                  denary number conversion to, 5
    Big O notation, 429-431                    ASCII (American Standard Code for                   hexadecimal number conversion to, 6
    binary search, 413-415                                 Information Interchange) coding         one’s complement, 8
   binary trees, 418-421                                   scheme, 15-16                           subtraction, 11-12
   bubble sort, 216-218, 412                       extended, 16                                    two’s complement, 8, 9-10, 13
   defined, 180                                    facts about, 15                              Binary prefix, 7
   design, 180                                    7-bit version, 15                             Binary search algorithm, 413-415
   dictionaries, 428-429                       Assembler, 93                                    Binary trees, 418-421
   Dijkstra’s, 398-400                            two-pass, assembly process for, 95-97         BIOS. See Basic input/output system (BIOS)
   dry-running/walk through, 300-304           Assembly language, 93                            Bit depth, 18
   expressing, 182-184                            addressing mode, 97-98                        Bitmaps, 18-20
    hash tables, 426-428                          instructions. See Instructions,               Bits, 3
    insertion sort, 412-413                              assembly language                         carry, 102
    linear search, 214-215, 412                   and problem-solving in low-level                  manipulation to control devices, 115
    linked lists, 415-417                                programming, 489-492                   Bit streaming, 40-41
    logic statements, 188-192                     programs                                      BitTorrent protocol, 337
    loops. See Loops                                  tracing, 104-106                          Bitwise logic operation instructions,
    modules, 202-206                                  for two-pass assembler, 95-97                      assembly language, 102
   queues, 422-423                                    using absolute addressing, 95             Black-box testing, 299
    round-robin, 372                                  using relative addressing, 95             BNF. See Backus-Naur Form (BNF)
   scheduling, 371-372                                using symbolic addressing, 94, 95         Boolean algebra, 356-357
   stacks, 421-422                             Assignments, 184-187                                applications, 358-359
   stepwise refinement, 199-201                   construct, 182                                   expression, creation from truth table, 358
   variables, 184                                 variable, 245                                   identities/law, 357
   writing, 182                                Assignment statements, 245                         representation of logic circuit, 359
Alpha testing, 304                             Association for Computing Machinery              BOOLEAN data type, 210
ALU. See Arithmetic Logic Unit (ALU)                     (ACM), 147                             Boolean operators, 67-68, 250
Analogue data, 20, 21                          Asymmetric key encryption, 388                   Boolean values, 249
Analogue-to-digital converter (ADC), 20, 114   Atomic data types, 210                           Bot, 136
    sampling, 20-21                            Attributes, 160, 460                             Bridge, 36
Analysis, program development life cycle       Authentication, of user, 137-138                 British Computer Society (BCS), 147
           stage, 286                          Authenticity, 387                                Bubble sort algorithm, 216-218, 412
AND gate, 70, 71                               Authorisation, 139                               Buffers, memory, 54
AND operator, 67                                                                                Built-in data types, 314
   truth table for, 69                                                                          Built-in functions, 260-262
Anonymous variable, 503                        Back propagation of errors, 407                      random number generator, 262
ANSI (American National Standards              Backtracking, prolog, 504-506                       Slicing, 261
           Institute), three-level             Backup software, 126                                string manipulation, 260
           architecture, 168                   Backus-Naur Form (BNF), 378, 379                    truncation, 261
Anti-virus software, 138                       ‘Bad sector, 125                                 Bus topology, 30
                                                                                                ion
                                                                                                                                                     SS




By reference                                        Cloud computing, 39
   defined, 271                                     Coaxial cable, 33                                  Constructs, for computing algorithms, 182,
   passingparameters to procedures,                 Coding, program development life cycle
         Zil ‘73                                                stage, 286                             Containment/aggregation, 479-483
                                                    Collision, 37, 218                                 Context-sensitive prompts,129-130
  “Unicode UTF-8 format, 16                         Colour depth, 18                                   Control bus, &3,  84
By value                                            Combinationalcircults,
                                                                        353                            Control systems, 113-114
   defined, 269                                     comments, 247-248                                  Control unit, 82, 341
   passingparameters to procedures,                 Commerrcial softwa:re, 151-152                     Copyright t, 150-151
           210-2771                                 Comm unication                                     Corrective maintenarice, 395
                                                       protocols. See Protocols                        Count-controlled loops, 255-257
                                                       transmission modes, 330-331                     CPU. See Central processing unit (CPU)
                                                    Compact disc (CD), 56                              Cryptograptly, quantum, 393-394
                                                    Compare instructions, assemblytanguag              Current instruction register (CIR), 83
   coaxial, 33                                                 99-100                                  Cyclic shift, 102
   defined, 32                                      Comparison operators, 249
   fibre-optic,   33                                Compilers, 127-129
   twisted pair, 33                                    analysis-synthesis model, 376                   DAC. See Digitai-to-analogue converter
   types, comparisons between, a                       back-end synthesis stages,379                               (DAC;
   vs, wireless transmission, 34-3                     front-end analysis stages. See Front-end
                                                                                                          access restriction to, 139
                                                    Complex Instruction Set Computer (CISC),              commenProtection of, 149
                                                               341-342                                    Input,
           102                                      Composite type, 211
           tement, 253-25!                          Composite user-defined data types, 315                output ave
CCD. See Ch1arg@e-coupied                           Compression techniques, 21-23
CD.
  See Compact
           disc {CD}                                   lossless compression,21-22                         representation, See Data representation
Cell phone network, 38                                 lossy compression, 22, 23                          storage, 51-52
Central processing u nit(CPU), 81-83                   ae       ional   thinking                          test, 299
   architecture,81.                                                                                       transmission modes, 29-30
   arithmetic and logic unit, 82                                                                          validation, 140, 144
                                                       decomposition 120
                                                       data modelling,18
   contro! unit, 82, 341                                             If                                   verification, 140-141
   process scheduling, 370 72                          detined, 179                                    Database
                                                       pattern recognition, 180
Character code                                      Computer architectures                                nermalisation, 165-167
   ASCH! code, 15-16                                   massively parailel computers, 345-346              relatio nai, 160-161
   celine’, 14                                         Multipte Instruction Stream Multiple Data       Database administrator (DBA), 168, 169
                                                               Stream, 345                             Database management system (DBMS),
CHAR data type, 210                                    Multipie Instruction Stream
                                                                                 ¢single Data                      168-176
Charge-coupied device (CCD), 63                               Stream, 8                                   data integrity in, 170
Check digit metho
              thod,     of data verification, 14¢      Singie instruc tion S tre am MultipleData          detined, 169
CIDR. See Clas‘less inter domain tcrouting                     Stream ve3a                                faciities proviided by, 169
           (CIDR)                                      Single Instruction Strear         Single Data      feature of, 169
Ciphertext, 387                                                Stream, 344, 445.                          Structuresd Query L anguage, 170-173
CIR, See Current instruction register (CIR)         Computer-contr ole denvi ronment, 114              Data bus, 83, 84
Circuits. See Logic creuits                         Computer system                                    Data
                                                                                                          Definition' Langua
Circuit ewitching, 33                                  architectures, See Computer                     Data Encryption Stan
Circular queue, 229                                            architectures                           Data integrity
CISC. See Comolex instruction Set                       entral proces sing unit, 81-83                    in database management system, 170
                                                       Q0




           Computer {CISC}                              ontrol systtems, 113-114                          defined,
                                                                                                                134
Class,as data tyoe, 315                                data iiput,52                                   Data Manipulation   Language (DML), 171-173
Classes, in OOP, 460-461                               data output, 52                                 Data rnodeliing, computational thinking,
   abstract, 470                                       data storage, 51-52                                         180
   hase/siaperclass, 468, 471-476                      fetch-execute (F-E} cycle, 87                   Data movement instructions, assemoly
   creating, 462                                       hardware.        See Ha rdware
                                                                                    re                             language, 98-99
   dec! aring, 463                                     interrupt handling, 88~                         Data privacy, 134
       in Java, 467                                    ve ports, 86                                    Data protection law, 134
       ir Python, 463-4 &                                    vitaring systems, 113                     Data redundancy, 159
                                                       3eformar ce, factors contributing,
                                                                                        85             Data representation, 313-325
   defined, 160                                        security of. See Security                          data types. See Data types
   derived/subciass, 468, 471-476                      system bus, 83-84                                  file organisation, 317-320
   designing, 461                                      systern software.See System software               real numbers, 320-325
   instantiating, 468                                       r Neumann mode! of, 81                     Data security
Classiess inter-domainrouting (CIDR), 43             comput‘ing professional, 147-148                     defined, 134-135
Client-server model, 28-29                          cofi dentiality, 387                                  protectionmeees, 139-140
Closed ‘oop feedback control system, 114            Constant, declaration
                                                                        of, 244-245
                                                                                                                                                       =
                                                                                                                                                 Sahat


                                                                                                                                                i.

                                               Drawingobject, 17                             Finite state macnine (FSM), 293,             294
   Abstract Data Type,227,415                  Dry-running al gor ithm, 300-304                       two's complement, state-            nsition
                                               Dynamic                    W{DLLY 127                            Ciagram for, 296
                                               Dynamic RAM!HORA 53                           rirewall, 138
   comsosite user-defined, 315                 Dynamic syntax         checks, 130            rireaWire, 86
   enumerated, 314-StS                                                                       Firrnware, 341
   non-composite, 314, 315                                                                   Firstcome first served (FCFS}, 372
   erter, 34 9-316                                             e ElectricallyErasable PROM   First-in first-out
                                                                                                             (FIFO} 372
                                                             (EELOM)                             ixed-point representation, 320,
                                                                                                                               32
                                                               Pas able
                                                                      1 PROM (EEPROM) 54              conversion of representat Ons, 33.324
                                                                                             Moating@-point reptcoentatonn 220, 323
                                                                                                      precision/normalisation,322-323

                                               ACADssulaticion,6.
                                                mb

                                                                                                           om version
                                                                                                                    of representat fons,       323s
DBA. See Database administrator (DBA)          Encryption, 3 i388                                          recisiion/normalisation, 322-323
DBMS, See Database managementsystem               asymmetrickey, 388                                       roblems with       using, 324-325
                                                   matho ds, oer~388




                                                                                             —
           (DBMS)




                                                                                                 os



                                                                                                      —
                                                                                                      >
                                                                                             y
    . See Data Definition Language                 oublic key,392                            Foreign
                                                                                                  an Key, 16]
                                                  SYMMEEIC fey, 388, 391-392




                                                                                                      on
chiweingsy) 136-131                                                                          FOR | oO255 -257
Decimal numbers, See Denary numbers            End-of-fle (EcOF)marker, 226-227, 281-282     FOR. TEXT looo,19
Decimal prefix,7                                                                             Free SOfeware 152
Declarative programming, 498-509.Se            Ensity-real             modeling, 162-165     Freeware, 152
          Prolog                               Enumeratted fata oe, 314-315                  Front-end nays
        guages, 499                            EGFmarker See cade file (EOF) marker
   para digm, 4 44                             EPROM, See Erasable PROM(EPROM)                        semantic ar 1BLYSIS,378
Decomposition,       computational thinking,   Erasable PROM (EPROM), 54                              stages, 376
           1280                                Errors, 125                                            syntax analysis, 377
aa
 cryption, ar                                      back propagation of, 407                     SM, See Finite state maces (FSM)
                                                  detectionand recovery, 124                 FTP (File Transfer Protoco)), 336
Denar ynumnbers, 3
Deep Learning, 407-408
                                                                                                 +




                                                  and interru Ipts,                          ruil addercir wie oo a8
   binaryniumber conversion to, 5                  logic, 297, 298                           Full duplex mode, datatransmission,30
   conversion to binary number, 5                  orevention, 306                           Function header, 268
    rexadecimal numbers conversio                  run-time, 298, 455                        Functions, 202,265-267
   i,
   nm



   numbers types within, 6-8                      syntax, 207                                         but tein, See Built-in functions
Derivedclass /subclass, 468                       ty}pes of, 296~.298                                 passing parameters to, 268-269
                                               Ethernet, 36-37, 334-33
                                                                            Cr




   declar ing
    q
   “a




        inJ ava, 474-476                           sub-layers, 334
        in Python, 471-472                     Ethics, 147                                       arbage collectio n, 479
                                                                                             Seneral cat ,43

                                                                                                                      on Q
        IA VB.NET, 473-474                     Exception handling, 455-456
   nstantiating, 476                           Exponential notation, 320                     Geastationary Earth orbit (GEO},
                                                                                                                            35
DES, SeeData Encryption Standard(DES;          Extended ASCIi code, 16                       Getters, 461
Design, program development life cycle                                                       Global Positioning System (GPS), 35
           Stage, 286                                                                        Giobal variable, 206
   using State-transition diagrams, 293-296    Factoriai function, 435, 436                  Gosling, James, 242
   using structure charts, 289- 292            FCFS. See  First come first served (FCFS)
Developer interface, 169                       Fetch—execute     (F-E} cycle, 87-88          Graph plotters, 60
Device driver, 55                              eo optic cable, <33
‘Dial-up’ connections, 38                       IFO. SeeFirstin first-out (FIFO!                      directed, 424-425
Diaphragm. 63                                    ie-based system, iittat ons of, 158-159              labet led/weilighted, 424
                                               File compression |utility program, 126                 OE         ee aoe -40:
                                                                                       o>)




seus naries, 428-429
  gital cert ficates, 388-391                  File header, 20                                               Na gorit ‘, 400+
Digital data, 26,21                            Fite processing, 448-455                                      Dijkstra’ sal HiEAIN,398-400
  gital sign‘ature, 138, 388-39]                  operations for, 448                        Guide:J media, SE etCaor
       to- analogue c onverter (DAO), il           random-access,        453-45              Guls.See             Graphical   user interfaces (GUIs)
iikstra’s algorit im, 398. 405                    sequential, 449-452
Direct-access files, 318-319
Directedgraphs, 424-425                                                                      Halfadder circuit, 352 352, 353
Directive,93                                                                                          Booleannalgebora logic expression for,3
Disaster recovery, 137                            ee         acces ee                        Half duplext mode, data              transmission, 30
Disk defragmenter, 125
Disk formatter, 124 “125                          organisatior 37-320                                 b
Disk thrashing, 375, 376                          peer-to-peershlar
DLL. See Dynamic ‘inked library (DL I             processing, Ssee File -acess!
DML. See Data Manipulation |. anguage              random, 448                               Hlardwar €,5h sa
DNS, See Domain mame service (DNS                 sequential, 318                                     embedded   sSystems,52-53
Domain name service (DNS), 46-47                  sen 318                                             functional: 1 OEE view of, 51-52
DRAM. See Dynamic RAM (DRAM)                        haring, networking and,
                                                                          29                          input devi ces. See Input devices
Drawing list, 7                                      xt,226-227, 317                                  LAN, 35-36
                                                                                                             ion
                                                                                                                                            =
                                                                                                                                                             e




                                                                 rtegers                                          post-candition loop, 258
       outputkdeavices" cos Output:devices
                          g
                                                                       internal coding for, 8-10                  pre-condition ope 53. 259
       secondary stoage devices, 55-58                                 signed, 8,10                               selection construct. See Selection
    Hash tables, 426-428                                         integrated DevelopmentEnvironmeee                        construct
    Hexadecimal numbers, 4-5                                           code biocks,expanding
                                                                                       and collapsing,            text files, 279-282
       binary number conversion to,
                                  6                                           130                                 two- dimensional array, 27‘B27




                                                                                                                                                      o
       conversion                                                      context-sensitive prompts, 129-130         variabie declarations, 244
          to binary numbers,                                           debugging, 130-131                     JK flio-flop, 354-356
          to denary numbers-                                                                                  Ju
                                                                                                               UMP Instructions, a ssembly
                                                                                                                                         iz
High Definer Muitimedia Interface                                      prettyprinting, 129
                                                     on
                                                          DMI)
                 pe £86                                          integration testing, 304
                                                                 integrity, 387
HostD..on                                                        internal clock, 82                           Karnaugh mans (K-maps}, 360-
HTTP (Hypertext Transfer Proto cal}, 335                         internal coding                              Keyboard, ie
                                                                       for integers,8-10                      Keylogger,     136
Hybrid network, 32                                                     ofrnumbers, &--14                      K-macs, 50.262
                                                                       of text. See Character code
                                                                 internet,28
en’ fier table, 187                                                    applications, 38-41
        yybubble so rtalgorithim, 216                                                                                                 network (LAN)




                                                                                                                                               am
                                                                       bit streaming, 40-41
       for linesar search algorithm, 214
                               ron
                               r
                                   a!




                                                                       cloud computing, 39
IEEE,
  See Institute              of Electrical and                         infrastructure, 37-38
                              ~£




                               i




                     Electronics Ennitreers (EEE)                      protons
                                                                            cal, 41
EEE 802.3, 36                                                           ecuntty threats, 135                      java,129
                                                                                                                        |
    EFEE-CS/ACM JointTask               F orce Software                usage
                                                                           of, 154                            Laser printer, 60
                     Engin     Coyde of Ethics>, 149
                         neering                                       World Wide Web, 38-39                  Lexical analysis, 377
            iples,       147-148                                 internet Engineering
                                                                                   Task Force (IETF), 393     Librarysystem, im:aleme:tation of, 469-476
                      ternet EngineeringTask Force               internet ServiceProvider USP),37, 45-46      Licensing,software, 151-152
                                                                 interpreters, 127-129                        Light-emitting diodes      {LEDs}, 59
     EF... THEN, we                 Statement, 251               interrupts, errors and,371                   Linear search algorithra, 23fee
IF...THEN remert 250                                             intrusion, detectionof 138                   Linked lists, 220- 236,415
eee a ssoltion, 18                                               i/O ports, 86                                    adding nodes in, 236- ore
                                                                 ioT(internetof         Things},
                                                                                              53                  deleting no des in, 230--233
                                                                 iP (Internet Protocall), 333                     elements, 229
                                                                 iP addressing                                Li quid- crystal display (LCD),
                                                                                                                                            58
                                                                  Xv




|   MAP (internet Message ‘AceSS Prottocol}, 336                                 inter-domain routing, 4      Lt sts
|     mediate access store (AS),
                               8                                                       46
      perative programming varadigm, 444                               IPv4 acksiressi ng, 41-42                  prolog, 507-509
Index, 169                                                             IPv6 addressing,
                                                                                      5, 46                   Local area network es 21-28
                                                                       network addresstransiation, 45
Indirect addressing, 493-494                                           Static, 45-46                              topologies, See Topologies, network
Inheritance, 468-477                                                   sub-netting, 43-44                         wired,35-36
      defined, 468, 469                                          iPv4 addressing, 41-42                           wireless, 36
nnet       printers,59                                           PNG addressing, 46                           Loca i variable, 206
Input
    devices                                                      iSP. See Internet Service Provider (ISP)     Logical Link Control {LCC} protocol, 334
       keyboard, 61                                              iteration. See Loops                         Logicai shift, 101-102
      screen,61-62                                               iterative model, in prograrn development     Logic bomb, 135
      touch screens, 62                                                       life cycle, 288                 Lagic circuits, 70, 351-356
      webcam 3                                                   iX. See Index register (IX)                      Boolean algebora reypresentation of, 359
Input,output | nstructions, assembly                                                                              full adder, 352-353
          lanpuage, 9S                                                                                            half adder,351-352
Input/out put 4/0syste,368-369                                            29, 242-243                             sequential, 353-356
Input statements, 247                                                  assigament of variables, 245           Logic errors,297, 298
insertion sort algorithm, 442-413                                      20Hea expressio ns, on on              Logic ex ression
Instituteof Elesctrical and ElectronICS                                          de claratic                  Logic gates, 70-71.
                     Engineers (EEE},
                                    36, 147                                                                       defined,ed, 70
Instructions, assembly language                                                                                   syrabolis Ae
      arithreetic operations,100-161, 103-104                                                                     truth tables, 70
      bitwise logic operation, 102                                                                            Logicproposition, 67
      compare, 99-100                                                  fuinctions, 288.GT                     Logic statemnen ts, 188-192
      data rmavement,98-99                                             earbage colle:ction strategies, 479    Loops, 192-199
      input/output, 99                                                 input statements, 247                      count-controlled/POR, 255-257
      UMP, ¢99-1090                                                    instantiating class, 468                   POR...NEXT, 193
      register transfer notation, 103                                  instantiating suclas 8,476                 nested, 198-
      shift operations, 101-102                                                                                   pos e-conditiorrm,257-258
INT EGERdatatype, 210                                                  output statements, 246-247                 pre-condition 258-259
                                                                       polyrnorphisim in, 478                     REPEAT ONT TL, 192
Lossless compression, 21-22                    NAND gate, 70, 72
Lossy Comipression, 22,23                         fulladder circuit, 353
Low-Earth-orbit (LEO) satelli tes, 35             ralf adde rcircult, 352-352
                                                                                                                          are




Lower bound, 212                                  SR ae1D-tHOD, 355                                                  sorting in,015. -218
Low-level programmine 487-495                  NAN® operator,
                                                            6                                                        working with, 213
   absolute address,4                          NAT. See Netwark“address transiation (NAT)                     One's com
                                                                                                                      npleme nt,8
   absolute address!heAI3                      NestediF statement, 191, 252-253                               One-to-many (:M} relation, 162, 164
   indirect addressing, 493-494                Nested loops, 198-199, 219                                     Oneto-one (1:4) relation, 162, 164
     aracigm, 444                              NedD, 43                                                       OOP. See Object-oriented orograraming
   sroblem. solving using, 489-492             Network address translation(NAT),
                                                                               45                                      (COP)
   xa}




   pracessor instruction set, 488-489          Network Interface Card (NIC),36                                Opcode, 92
   relative addressing, 493                    Netwark/networking                                                    lookup table, 96
   symbolic addresses, 489                        cell phone, 38                                              Open source softwa re, 152
Low-level sch eduler 376                          clie nt-server odes 28-29                                          ae




                                                  Ethernrel, 36-3                                                    eresting system (OS)



                                                        o Sag
                                                     er

                                                  an            file
                                                                   sh
                                                                    wt   aring,29                                    deefined, 122
MAC addresses, 335
                                                             rid,
                                                                    .                                                device management, 123




                                                                    a cA 63
Machine code, 97, 115 126                         ne                     see Internet                                error detection and recovery, 124
                                                                ‘ares,
                                                             rn

   instructions, 92-93                            LOC:                   21-28
                                                                               .




                                                          AL3

Machine tearning, 154, 403-406                                                                                       file rnanagement, 123
                                                  Oo



                                                        ee
                                                             SS




   defined, 404                                                                                                      memory management, 123
                                                          c



                                                  Re)


   regression analysis, 405-406                   topologies. see Fopologies, network                                program hardware interface,      123
   reinforcement learning, 404                    transmission media.                      See Transmission          purposes of, 368
   requirementstor, 403                                           media                                              resource management, 123
   supervisedlearning, 404                        wide area, 27
   unsupervised learning, 404                  Neural netw ork, artificial, 466-408                                  structure, 368-369




                                                                                                                                     = OO
                                               Nibble, 4
                                               Nic, See Network
                                                              In terface (card (NIC}
Malware                                        Nodes, linke:dlists, 229, 230-233                                                C, 245-246
   defined, 135                                Non-composite data type, 314, 315                                     Bo:oolean, B6T -68, 250
   types of, 135-136                           Non-repudiation, 387                                                  comparison, 249
                                                                                                                                                            a
Many-to-raany (M:M) relation, 162, 163         NOR gate, 10, fh
Mary-ta-one (M: 1} relation, 162, 163             SRflip-flop with, 353-354
Massively parallet compute 5, 345 346          Normaisation, 165-167
                            mB




                            Cpl                NOR oO
                                                   operator, 68                                               ORgate,
                                                                                                                    70, 73
                                               NOF gate, 70, 71                                                      truth table for, 360
Medium Access Control(MAC) pr otocal,334       NO? operator, 67                                               OR operator, 67
Medium-earth-orbit (MEO) sate!     lites, 35   Null pointer, 229                                              OS. See Operatingsystem {QS}
Memory                                         Numbers                                                        Qutput devices, 58-61
                                                  conversion  of stringto, 261-262
   cache,
        85                                        fanco rm, generatar,  262                                          printer, 59-60
   management, 123, 372-37!                             eal, 320-3?
                                                                 305
                                                                                                                     screen display, 58-59
   oartitions/segments,     -                  Number systems, $< See also Binary                                    virtual reality headset,59
   random “acc88,93                                               numbers Denary numbers;                     Output statements,246-247
   read-only,
            53-54                                                 Hexadecimal numbers                         Overflow Jil
                   4Oo ia




   virtual, 373.3-37!                             internal coding, 8-14                                       (Swnershio, :and cop yright, 150-154
Memory data register (MDRI, 8                  Numerical| Algorithrns Group (NAG) library,
Meshttopology, 30-.                                               aac




                                                                  Lo
Message,
       3
Methods, 460                                                                                                       .ret swicing 330-331
Microcontroller, 52                            Object-orientedprogramming (OOP),                              Pa

Microphone, 63                                                    453-483                                     Palrameters
ae eee nan 341                                    advantag es af 461                                                 defined, 267
    D. See
       See    Mulitiple In structionStream
          Multigle D ata Stream(MIMD)
MIMD.                                             classesin. See Classes, in OOP                                     passing
                                                  code, writing, 463-468                                                   to functions, 268-269
MISO. See Multiple instruction Stream Single      conc
                                                     cept of, ?460
                                                                                                                            o procedures, 269-273
             Data Stream (MISD}                   contain:ment/aggsregation, 479-483                                       to subroutines, 267
Mnemonic, 93                                      garbage collection, 479                                      artitions, memory, 372-373
                                                                                                              “oo~




Modules, 202-206                                  mineritance, an Ail                                         rattern recognition, X30
                                                                                       i




Monitoring systems, 113                           oaradim, 4
Multimedia ports, 86                              polym Orohisia,n AT6- AT?                                   PCT, See —ctive~capacith oto       ie

Multiple Instruction Stream Multiple Data      Oblects                                                        Peer-to-peer (P2P} file sharing,
                                                                                                                                             =
          Stream (MIMD), 345                      defined, 460                                                Sear. to-peernetworking, 23
Multiple Instruction Stream Single Data           designing,461                                               Perfective maintenance, 307-308
             Stream (MISD}, 345                On demand, G                                                   Pharming, 136
                                               One-dimensional (1Dlbarearray,212-218
                                                  accessing, 212 2 3,271           1       7                  Physical addresses, 335
                                                                                                                    garbage collection strate




                                                                                                                                                       é8
                                                                  functiiONS, 265-267




                                                                                                                                                             NS
                                                                                                                                                                oO
                                                                                                                                                             —~
         Physic. al Cadin a        Sublayer (PCS)\ protocol,
         fe)   Ones



                                                                  grammar, 318-379                                  input statements, 241
         Physical Meclium Attachment(PMA} protocol,               input statements, 247
                        334                                       iteration. See Foops                              instantiating ss
         Picture element (pixel), 18                                                                                one-dimens                    a5.276. 217
         Pipelining, 342-343                                      output s tatements , 246-247                      outputstatements,a24                L7
         Place values                                             procedures,26 2-2 4 r




                                                                                                                    polymorphism | n, 47&
                                                                  Bython, See Python
                                                                                      B




                                                                                      Ve



                in binary    number representation, 3                                                               pre--condition loop¥5, 258-259
                                                                                                                       ection construc See Selection
                                                                                         a




                in denary nuraber         representation,-        selection construct. See Selection
                in hexadecimal number reprresentation, 4                 construct                                            CO nstr uct
                                                                                                                    sticing
         Pot ater,9                                                   assignment, 245                               vont fils, 279. -282
                nul, 223                                              de Clarations, 253- 244                       two-dimensional array, 278-279
                start, 229                                        VB.NET, See VB.NET
         Pointer data type, 315-316                            Programming paradiams
                                                                  declar ative, 444




                                                                                                              AH
                                                                                                            oft
         Pointer variable, 315, 316
         Point-to-point sopology, 30                              defined, 444                                                (OKD        systé




                                                                                                                                     we
         Pola “ised hent,5                                        imperative, 444                                  Uartlim     ee
         Polymorphism 6. ATT                                      low-level, 444                                   Want”1 Key Dis                       Di sysstems, 394
         POP3 (Past ¢Mifica Protaco: VELSIO                       object-oriented, 444                      Guery, 169
         Post- condi tion loop,257-258                         Projective capacitive touch (PCT), 62        ON
                                                                                                            Query processor,
                                                                                                                                           169


         POTS (olain oldteleohone.service), 38                                                                      eues, 228-229, 422-42:




                                                                                                                                                  ae
                                                               Prolog, 499
         P2Pfile sharing. See Peer-to-peer (P2P) file             anonym
                                                                       ous variable, 503
                   sharing                                           cKtrac King, 504-5)
         Pre-condition loops,258-259                              basiccs, 499                              RAB madei. See Rapid Application
         Prefixes                                                 factsin, 500                                       Development (RAD) model
                                                                  instantiation, 504-506                    RAM. S¢e Random-accesss memeory(RAM)
                decimal, 7                                        lists, 507-509                              fandom-accessfiles, 318
                                                                  recursian, 506-507                                 processing, 453~<‘55
          primary key, 161                                        rules in, 503-504                         Random-accessmemory (RAM), 53
          Primitive
                 data t yor s, 210                                Varjables, 5& 00-504                      Random file, 448
          Prin ter                                             Property 461                                 Rapid Application Development (RAD)
                                                                                                                               model, 288-289
     5




                inkjet, 59                                        ofobject, 17
ae                                                             rotee’s                                      Read-only memory (ROM), 53-54
                laser,60
          Private ¢!iOid,39                                       polication-layer. See Apptication-layer
                                                                                                                    tyeres
                                                                                                                         of /54



          Problem statement, $7                                          protoce IS                         REAL data type, 216
          Procedure header, 270                                   defined, 331                              Real numbers, 320-325, See aise Fixed-point
          Pracedures, 202, 262-264                                SecureSocket                                                 representation; Floating-point
                passing parameters                                Te SP Su ite, 3                                              representation

                                                               Protocal stack, 33                            Real-time streaming media,                40
                                                                                                            Reasoning. apaation of Al, 154
                      by reference, 271-273
                      by value, 270-271                           the!met, 334~
                                                                                                            Record           data type, 315
                                                                                                            meet ds, 317, 447-448
                                                                  arrays in.‘See Arrays                             cor d type, Ali
                                                                  data types. See Data types                       scursion,434-441. See also Re cursive
                                                                  deriving from structure chart,                               Subroutine
          Pracessors, 85, 341                                     loops. See Loaps                                   benefits, ae
                Complex InstructionSet Computer,                  selection construct. See Se action                 Grawbacks, 4
                                                                                                                         OB, ¢
                                                                                                                             506--
                        an                                               construct
                instruction set,   in low-leve                    syntax, 240                                Recursive Fun ction, 438-439
                        proeranming, 4 88-489                  PSTN. See re‘Bic switch ed telephone          Recursive routine, 435
                ReducedInstryaction Set Computer,                               K (PSTN)                     Re Cursive subroutine
                                                               Public cloud 39                                       programming, 436-437
                         5




           Program develoment tite cycle                       Public good, Mg 150                                   running, 429. 440
                iterative model in, 2&8                        ee He key enicr yption, 392                           tracing,437-439
                RAD meadel, 288-289                            Public switched teleoshone etwork (PSTN),     Reduced mistruction S                 Computer (RISC),
                    in, 286- 287
                stages
                waterfall model
                              in, 287-288                      Pytnon, 240-241                                  olpelining, 342-343
           Program loraries, 126-127                              assignment ofvariables, 245                Referentialintegrity, 161
           Prograrmmabie ROM (PROM), 54                           Boolean expressions, 249-250               Registers, 82-83

           Programming ianguages, 240                             comments, 247-248                          Registeor transfer notation,88
              arithmetic operators, 245-246                       constant Geciarations, 244-245                “assembly language, 102
                Boolean exoressions, 249-250                      count-controlied/FORtoop, 256              negiesssion analys!sis,405-406
                                            in functions
                built-in functions. See Built                     datatypes, 248-249                                 nforcement lea rning, 404
                comments, 247-248                                 declaring class in, 463-464                Relotio: 160
                constantdeclarations, 244-245                     baseand d erived, AT1-472                  Relatio nal database, 160-161
                data types. See Datatypes                         functions, 265-267                         Relational operators, 188
                                                                                         Setters, 461                                                                                   program design using,289-292
                                                                                         She EWoOTre, 152
                  teY, 36
                                                                                         Shift i| nstructions, assembly language,                                             Structured Query Language (SQL), 170-173
Re eating groug, 166, 167                                                                                         iol          lee
                                                                                                                                                                                 DataDefinitian Language,170-171
REPBRAT...UNTI L loop , 192                                                              Sik ned              intepers,             &                                                   Data Manipulation Language, 171-173
Repetition construct, 182
                                                                                         1




                                                                                                       representations ¢of, 10
                                                                                                                                                                              ubclae s. SeeDerived class/subdclass
                                                                                                                                                                                tubtesting, 298
cesistive touch screen,
                      62                                                                    MD. See Singie> Instruction Stream Multiole




                                                                                         ~
al




 eturn value, 265                                                                                                 Data Stream {SIMD}                                          Sub-netting, 43-44
x




      tur
2
      i




 feversefPolish fNotation (RPN},                                   -




                                                                                         Simpiex rode, data transmission, 30                                                  Subroutine interface, 267




                                                                               tS
                                                                                xX
yom




                                                                        7O




                                                                                    NO
                                                                   StS

 SC. See ReducedInstruction Set                                                          Sirnplified DES (S- DES), 391                                                        Subroutines, passing parameters to, 267
2




                      Computer (RISC)                                                    Single InstructionSttres 1 Multipie Data                                             Subtraction, ofbinary numbers, 11-12
Robots, 154, 155                                                                                                  Stream (SIMD),344-345                                       Superclass. See Base class/superclass
Rogue vaiue, 193-194                                                                                              truction Sream Singie bata                                  Supervised leaning, 404




                                                                                                               at
ROM, See Read-only memory (ROM}




                                                                                                                  ie
Round-rabin algorithnm, 372                                                              SISD.See Sinigie Instruction Stream Single                                           Symbolicad ddrres Ses, 4&9
Router,36, 333                                                                                                    Data Stream (SISD}                                          Symbolicad dreeSS ing, assembly language
                                                                                                                                                                                                      S


RPN. See Reverse Polish Notation (RPN)                                                   Sticing, in Python, 261                                                                              programusing, 94,95
RSA (Ri vest: SrarnirAdieman), 392                                                       SMTP “Simo le Mall Transfer Proto                                                    Symbol table, 377
Rulesof precedence, 246                                                                  Software                                                                             Symmetric key encryption, 388
Run-time errors, 298, 455                                                                   development. See Software/pro                                                               methods 391 392
                                                                                                                  development                                                 SYNTSX,      PSeludoccode, 240
                                                                                                                                                                              Syntax analysis, 377
Sampling                                                                                            transiation. See Translation                                              SvNtaX ee
   anaicOBuE: to-digital converter, 20-21                                                           virtual machines, 3460-347                                                System dus, &3-8
                                                                                         Software licensi                                                                           address bus, 3 84
          reselution, 24
                                                                                                                               oa


                                                                                                                                        4
                                                                                                                                    3




                                                                                                       commercial software, 151-152                                                 control bus, 83, 84
Satellites ,35                                                                                         apen/free licensing, 152                                                     databus, 83, 84
Scheduling algoritams                                                                    Software/program development                                                         System clack, 82
Scientific nota’tion 306                                                                               adaptive matt wenannce, 307                                            System software, 122
Screen, input device, 61-62                                                                            corrective maintenance, 306                                                      input/output system, 368-369
Screen resolution, 18                                                                                  errors, 296-298                                                                  language transiators, 127-129
S-DES. See Sim plified £ ES(                                                                           iterative model,2
                                                                                                       life cycle. See a ora develo:
                                                                                                                                                                                        memery management, 373-375
Secondary key, 164
                                                                                                                                                                          =         operating system. See Oo ratin esystem
                                                                                                                                                                 =I
                                                                                                                                                        a)
                                                                                                                                                             3
                                                                                                                                                             o

                                                                                                                                                                      =




Secon dary storage clevices, 55-58                                                                                cycle                                                                       (03)
          magnetic meedia, 55-56                                                                       perfective              m ainwenanice, 307                                       process scheduling, 370-372
          optical media, 56                                                                            RAD model, |,
                                                                                                                   2 288-289                                                            program lbraries, M612
          solid-state media, 57-58                                                                  waterfall n ode! , 287-288
Secure Socket Layer                                                                      Solid-state drive ~3 58                                                              System virtual machines, 346-347
Security, 386-394                                                                        Solid-state media,
          concerns,
                 367                                                                     Sorting, in one-dime                                  onal array, 215-218
          data, See Data security                                                        Sound, 20- 21                                                                        TCP (Transmission Control Protocol,
          Gigital certificates, 388-391                                                                                   4
                                                                                                       n‘peranesoutput of §3
                                                                                                                                                                                              337- -333


                                                                                                                                                                              TCEP/FP 331-333
          digital signatures, 388-391
                                                                                         oa i 9




          ericryotion, 387-388                                                                                                                                                      application-iayer protocols associated
                                                                                                                         ae
                                                                                                                         fa)
                                                                                                                  jess
                                                                                               oO


                                                                                                         eed
                                                                                                              a
                                                                                              SS
                                                                                                        <




                                                                                                                               turredQuery Language (SQt)                                     with, 335-336
                                                                               o




                                                     ting syste ym

                      activity, a                                                                                                           AM
                                                                                                                                             (SRAM)                           Test data, 299, 305
          protectionmea
                                                                                         SSL protoc ol See Secure Socket Layer (SSL
                                                                                                                  protocol                                                    Testing, program development life cycie
                                                                                         Stacks, 227-228, 421-422                                                                             Stage, 286-287
          >
                                                                                            prot ocoal, 331                                                                         acceptance, 304
Seiectlon co}nstruct, 182, 188, 190-194                                                     star topology,
                                                                                                       31, 36                                                                       alpha, 304
              !       tate ment, 253-255                                                 Start pointer, 229
                                      -BLSE statem ent, 251                              State-transition diagrams
          IF.. THEN staterrent, —                                                                      defined, 294
          nestediF statement, 252-2                                                                 for intruder detection systern, 295
      mantic analysis,378                                                                              program design using, 293-296                                                    purpaseof, 297
                                                                                                    for two's calmpleme Nt FSM, 296                                                 strategy, 304
Seguence canstruct, 182                                                                           ate-transition table, 293, 23                                                     stub, 298
                                                                                         law (4
                                                                                              ae




       panies 318
sequent:                                                                                      tatic RAM(SRAM}, 53                                                                   white-box, 299-300
                                                                                              a




                     ssing, 449-452                                                               cosSe refinement, 199-201
                                                                                              a
                                                                                                  Dp




                     logic circ Wits, 353-356                                                                                                                                 Text, internal coding of.See Character code
                                              Cad



                                                            Cad



                                                                  GW

                                                                        con)
                                                    rl Jt



                                                                       on




                                                                                                   ss




                                                                                                        8 210
                                                                                              a




                                                                                                         ga




                     ~ lon, 354-356                                                                                                                                           Text files, 317
                                                                                                        manipulation functions, 260
                                  wo




                                                                                                                                                                                    appeniding to, 226, 280-281
                                 ww



                                        s




                                        355
                            oS




                                                                                         Struccturecharts                                                                           end-c¢‘file marker, 226-227, 281-282
                                                                                                       defined, 289                                                                     voadling from, 226, 280
                                                                                                       derivingpseudocode from, 232-293                                             writing to, 226, 279
                                                                                          |
Thick-client, 23                            Validation, data, 140, 142                      WirelessAccess Point (WAP), 36
Thin-client, 28                             Values                                          Wireless localarea network (WLAN), 36
Threads, 371                                                                                Wireless Netwo rk Interface Card (WNIC),
                                                                                                                                   36
Threats, security, 135-136                     copying, i                                   Wireless     smission, 33-34
   internet/net mors 135                        rogue, 193-194                                 mabetransmis sion VS., 24-35
   malware, 135-136                            swapping, 186                                WLAN. SeeWireless   focal area network
    yulnerabiilties, 136                        updating,     165                                      WLAN)
TLS. See Transport Layer Security (TLS)     Van Allen salts, 35                             WINIC, See Wireless Network interface Card
Topologies, network, 29-32                  van Rossurn, Guido, 246                                    (WNIC)
    bus, 30                                                                                 Word, 85
    defined,30                                 anonymous, 503                               World Wide Web (WWW) 38-39
    mesh, 30-31                                assignment, #45                              Worm, 135
    point-to-point, 30                         declaration, 243-244
    star 31,36                                 global, 206
                                                local, 206                                  XOR operator, 68
                                                pointer, 315, 316
                                                prolog, 500-501

  a “lation” Software, 375-382
                                            VB.NET, 241-242
                                               assignment of variables, 245
 ransrnission media                             Boolean expressions, 249-250
    cable,32-33                                constant cee rations, |244-245
    wireles
          SS, 33-34                            COUML-CO
                                               data nee 28 “
                                                                    led/FOR toop, 256
Transmission modes, 330-331
    CHU!itwiching,330                          declaingcla
    data, 2 9-30
    packet shin, 390-3
Transport LayerSecurity
                      {TLS}, 393                                      on strategies AT9
Trojan horse, 136
Truncation, 251
Truthtables, 69
   Boolean algebra expression creation           ne-dimensiot
                from, 358                      onoutpet stateme nt : V6 AT
    fulladder (352                              polymer phism in, 478
    half adder, 354                             post: ond: tion loop, ee
                                                       ne tion loops, 2
    logic gates, 70                                   tion   construct. Se » ciexction
    for OR gate, 360                                          truct
    SR “ip-tlop, 354                           stub testing, 238
                                               text files, 279- 282
Ts ed pal rcable,33                            two-dimensional
                                                             array, 278-273
Two-dimensional 2D) arrays, 218-225            varlabie declarations, 244
   y ‘e) we .




    accessing, 218-219, 278-276             Vector graphics, 17-18
      ore
        eation, 218                         Ver ification , data, M0. 14}
    declaration, 218                            check digit method, 140
    working with, 219                          during data transfer, 141
Two-pass assembler, assembly process for,   Video Graphics     Array (VGA) port, 86
                95- -OF
                                            Virtual machines, S46~347
Two’s complement, 8,         9-10, 13       Virtual memory, 373-375


                                            Virus, 135
Unguided media. SeeWirelesstransmission        categories, 136
Unicode, 16                                 Virus-checking program,
                                                                 126
UniversalCharacter Set {UCS) scheme, 16     Voice recognition/synthresis, 153
unliversal resource locator{!URL) 47        von Neumann, John, 81
Universal Seria{Bus (USB)!
                         BE
JUnsuinervised |learning, 40
Upper bound, 212                            Walk through, algorithm, 306-304
URL. See Universal
                 resource locator (URL)     WAN. See Wide area network (WAN)
USB. see Universal Seraa1 Bu 5 (USB)        WAP, See W ireless Access     Point (WAP]
 ser authentication, 137-138                Waterfall model,|            sram development
user-defined data typeoo314, 315                     life cycle, Say Re
Wtiity software, 124-12
    backup softwareee                       Weighted gra‘aphs, 424
    disk defragmenter,      125             White-box‘testin12, 299-300
   disk formatte Prnee    25                Wide area network (WAN), 27
   file carnpres cion, 126                  WiFi LAN, 36
   VITUS- cheekingprogram, 126              Wired tocal area network, 35-3
                                                                                 cy ~
Acknowledgements

The authors and publishers acknowledge the following sources of copyright material and are grateful for the permissions
granted. While every effort has been made, it has not always been possible to identify the sources of all the material used,
or to trace all copyright holders. If any omissions are brought to our notice, we will be happy to include the appropriate
acknowledgements on reprinting.




Cover Photo: Westend61/Getty Images

Galushko Sergey/Shutterstock; Solomonkein/Shutterstock; Pingingz/Shutterstock; Photo by Frank Wojechowski, used
with permission of Michael McAlpine and Princeton University; Nikita Veremcuks/EyeEm/Getty Images; ilbusca/Getty
Images; digitalreflections/Shutterstock;




Chapter Openers

polygraphus/Shutterstock; dgbomb/Shutterstock; Pingingz/Shutterstock;

agsandrew/Shutterstock; Raimundas/Shutterstock; Best Backgrounds/Shutterstock; Toria/Shutterstock; deepadesigns/
Shutterstock;

Gino Santa Maria/Shutterstock; kubais/Shutterstock; bluebay/Shutterstock; Best Backgrounds/Shutterstock; Kheng Guan
Toh/Shutterstock;

Best Backgrounds/Shutterstock; foxaonl1987/Shutterstock; Kheng Guan Toh/Shutterstock; bluebay/Shutterstock; James
Steidl/Shutterstock; Lukas Rs/Shutterstock; kentoh/Shutterstock; jijomathaidesigners/Shutterstock;

kentoh/Shutterstock; mistery/Shutterstock; kentoh/Shutterstock;

Titima Ongkantong/Shutterstock; Best Backgrounds/Shutterstock;

Mike McDonald/Shutterstock; Tashatuvango/Shutterstock;

Best Backgrounds/Shutterstock
